<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Texture In Unity | ZeroUltra</title><meta name="keywords" content="Unity,Texture"><meta name="author" content="Roger"><meta name="copyright" content="Roger"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="这篇文章主要讲一下Unity中的贴图数据操作和内存计算方式以及相关优化 Unity中Texture中各种关系以及Apply()方法先抛出一个我无意间浏览到的一个博主写的关于Texture Texture2D  RendererTexture 之间的关系. 链接:http:&#x2F;&#x2F;fargesportfolio.com&#x2F;unity-texture-texture2d-rendertexture&#x2F;  这里">
<meta property="og:type" content="article">
<meta property="og:title" content="Texture In Unity">
<meta property="og:url" content="https://zeroultra.github.io/2020/04-21-2020-4-21-Texture-In-Unity/index.html">
<meta property="og:site_name" content="ZeroUltra">
<meta property="og:description" content="这篇文章主要讲一下Unity中的贴图数据操作和内存计算方式以及相关优化 Unity中Texture中各种关系以及Apply()方法先抛出一个我无意间浏览到的一个博主写的关于Texture Texture2D  RendererTexture 之间的关系. 链接:http:&#x2F;&#x2F;fargesportfolio.com&#x2F;unity-texture-texture2d-rendertexture&#x2F;  这里">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zeroultra.github.io/img/default_cover4.jpg">
<meta property="article:published_time" content="2020-04-21T12:59:12.000Z">
<meta property="article:modified_time" content="2020-04-21T12:59:12.000Z">
<meta property="article:author" content="Roger">
<meta property="article:tag" content="Unity">
<meta property="article:tag" content="Texture">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zeroultra.github.io/img/default_cover4.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://zeroultra.github.io/2020/04-21-2020-4-21-Texture-In-Unity/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Texture In Unity',
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2020-04-21 20:59:12'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="ZeroUltra" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/headicon.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">28</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/default_cover4.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ZeroUltra</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Texture In Unity</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-04-21T12:59:12.000Z" title="发表于 2020-04-21 20:59:12">2020-04-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-04-21T12:59:12.000Z" title="更新于 2020-04-21 20:59:12">2020-04-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Unity/">Unity</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Unity/UnityAssets/">UnityAssets</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>这篇文章主要讲一下Unity中的贴图数据操作和内存计算方式以及相关优化</p>
<h1 id="Unity中Texture中各种关系以及Apply-方法"><a href="#Unity中Texture中各种关系以及Apply-方法" class="headerlink" title="Unity中Texture中各种关系以及Apply()方法"></a>Unity中Texture中各种关系以及Apply()方法</h1><p>先抛出一个我无意间浏览到的一个博主写的关于<code>Texture</code> <code>Texture2D</code>  <code>RendererTexture</code> 之间的关系.</p>
<p>链接:<a target="_blank" rel="noopener" href="http://fargesportfolio.com/unity-texture-texture2d-rendertexture/">http://fargesportfolio.com/unity-texture-texture2d-rendertexture/</a></p>
<p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162206492.PNG"></p>
<p>这里说一下 <code>Texture2D</code>的<code>Apply</code>操作,当我们使用<code>SetPixel``SetPixels</code> <code>ReadPixels</code>定要调用Apply方法,不然显示的还是原来的图,这里有个链接具体看下:<a target="_blank" rel="noopener" href="https://blog.csdn.net/carefreeq/article/details/52635524">https://blog.csdn.net/carefreeq/article/details/52635524</a></p>
<blockquote>
<p><strong>赋值完后为什么要Apply</strong></p>
<p>因为在贴图更改像素时并不是直接对显存进行更改，而是在另外一个内存空间中更改，这时候GPU还会实时读取旧的贴图位置。</p>
<p>当Apply后，CPU会告诉GPU你要换个地方读贴图了</p>
</blockquote>
<p>所以图片存在内存中,CPU指向这个图片地址,GPU根据CPU拿过来的地址来显示,如果更改了图片数据,没用调用Apply. 那么GPU没用接收到CPU发来的指令就不会更改这个图的显示.下面的代码,当我没调用Apply的操作时,显示的还是原图,当我调用之后显示的就是纯红色了</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">BtnClick</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Texture2D tex = <span class="keyword">new</span> Texture2D(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    tex.LoadImage(File.ReadAllBytes(desktopPath + <span class="string">&quot;/111.jpg&quot;</span>));</span><br><span class="line">    Color[] colors = tex.GetPixels();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; colors.Length; i++)</span><br><span class="line">        colors[i] = Color.red;</span><br><span class="line"></span><br><span class="line">    tex.SetPixels(colors);</span><br><span class="line">    <span class="comment">//tex.Apply();  这里更改</span></span><br><span class="line">    rawImg.texture = tex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Apply是一个很昂贵的操作,所以官方建议我们在使用这个方法之前,尽可能把数据操作完毕!</p>
<h1 id="Unity中Texture内存计算方式"><a href="#Unity中Texture内存计算方式" class="headerlink" title="Unity中Texture内存计算方式"></a>Unity中Texture内存计算方式</h1><p>任何贴图(Unity可识别的格式)导入到Unity中都有Unity自己的图片计算方法.而且可能一张100K大小的图片导入Unity就是好几M,同样一张图png和jpg两个格式假如一个100k一个50k,但是导入Unity中都是2M.那么Unity的计算格式是怎么样的呢?</p>
<p>我做了一个1024*1024的图片导入到Unity中,不勾选<code>Generate Min Maps</code>,然后设置格式RGBA32那么此时的格式大小</p>
<p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162206494.PNG"></p>
<p>这里可以看到图片大小是4M,其计算方法–&gt;这里格式设置的是<code>RGBA32 bit</code>,这个格式意思就是<strong>每一个像素用了32个bit去填充</strong>,而我们都知道一个byte等于8个bit,所以这里每个像素都占用了4个byte,而1m&#x3D;1024kb,所以:</p>
<blockquote>
<p>总的像素大小&#x3D;1024x1024(宽度x高度)</p>
<p>那么总大小&#x3D;总像素x每个像素大小&#x3D;1024x1024x4&#x3D;4M</p>
</blockquote>
<p>如果我们将图片换成RGB24,那么大小应该是;</p>
<blockquote>
<p>​	1024x1024x3&#x3D;3M</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162206495.JPG"></p>
<p>所以在Unity中图片的内存大小是根据其格式定义的,具体要看每个像素占用的字节大小.</p>
<h1 id="Texture2D中的RawData"><a href="#Texture2D中的RawData" class="headerlink" title="Texture2D中的RawData"></a>Texture2D中的RawData</h1><p>Unity中有<code>tex.LoadRawTextureData()</code>和<code>tex.GetRawTextureData()</code>两个方法,Get是获取图片的原始数据Load是从原始数据中加载.</p>
<p>这在我项目中要频繁加载外部纹理(用完就处理掉)需要更快的加载纹理,这个方法加载速度要比IO读取和UnityWebRequest快很多</p>
<p>要获取图片的RawData,就必须导入让Unity识别一遍,所以在开始就可以对纹理进行处理,先用IO读取获取到Texture2D(这里new Texture2D可以不用设置宽高)</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Texture2D tex = <span class="keyword">new</span> Texture2D(<span class="number">0</span>, <span class="number">0</span>,TextureFormat.RBGA32,<span class="literal">false</span>);</span><br><span class="line">tex.LoadImage(File.ReadAllBytes(<span class="string">&quot;xxxx/1.png&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>这个时候我们已经得到了一个Unity Texture2D,接着我们使用代码获取RawData,然后保存</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">byte</span>[] bs = tex.GetRawTextureData();</span><br><span class="line">File.WriteAllBytes(<span class="string">&quot;xxxx/1.png.bytes&quot;</span>, bs);</span><br></pre></td></tr></table></figure>

<p>保存这个二进制文件之后,可以发现文件大小就是此图片在Unity看到的大小(在这用上面的图格式是RGBA32,那么这个二进制文件就是4M)</p>
<p>这里需要注意一点的是,当我们使用<code>LoadRawTextureData</code>的时候,<strong>必须要指定原始图片的Width,Height和TextureFormat(minchan可以不管)</strong>,如下</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Texture2D tex2 = <span class="keyword">new</span> Texture2D(<span class="number">1920</span>, <span class="number">1080</span>, TextureFormat.RBGA32, <span class="literal">false</span>);</span><br><span class="line">tex.LoadRawTextureData(File.ReadAllBytes(<span class="string">&quot;xxxx/1.png.bytes&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>所以你在保存RawData的时候,应该<strong>记录一下图片的一些属性</strong>,可以把数据写到文件名,然后用字符串操作得到相应数据,我这里使用了二进制保存.</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">WriteTexture2DToRawData</span>(<span class="params">Texture2D texture, <span class="built_in">string</span> filePath</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">byte</span>[] bs = texture.GetRawTextureData();</span><br><span class="line">        <span class="keyword">using</span> (BinaryWriter bw = <span class="keyword">new</span> BinaryWriter(File.OpenWrite(filePath)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提前把前三个写入</span></span><br><span class="line">            bw.Write(texture.width);</span><br><span class="line">            bw.Write(texture.height);</span><br><span class="line">            bw.Write((<span class="built_in">int</span>)texture.format);</span><br><span class="line">            <span class="comment">//bw.Write(texture.streamingMipmaps);</span></span><br><span class="line">            <span class="comment">//------</span></span><br><span class="line">            bw.Write(bs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>然后在读取的时候</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Texture2D <span class="title">LoadTexture2DFromRawData</span>(<span class="params"><span class="built_in">string</span> rawdataPath</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">using</span> (BinaryReader br = <span class="keyword">new</span> BinaryReader(File.OpenRead(rawdataPath)))</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">//先读取前三个宽 高 格式</span></span><br><span class="line">         <span class="built_in">int</span> w = br.ReadInt32();</span><br><span class="line">         <span class="built_in">int</span> h = br.ReadInt32();</span><br><span class="line">         <span class="built_in">int</span> format = br.ReadInt32();</span><br><span class="line"></span><br><span class="line">         <span class="comment">//在读取剩下的texture raw data</span></span><br><span class="line">         <span class="comment">//此时的br.BaseStream.Position=12</span></span><br><span class="line">         <span class="built_in">byte</span>[] bs = br.ReadBytes((<span class="built_in">int</span>)(br.BaseStream.Length - br.BaseStream.Position));</span><br><span class="line">         TextureFormat textureFormat = (TextureFormat)format;</span><br><span class="line">         Texture2D texture = <span class="keyword">new</span> Texture2D(w, h, textureFormat, <span class="literal">false</span>);</span><br><span class="line">         texture.LoadRawTextureData(bs);</span><br><span class="line">         texture.Apply();</span><br><span class="line">         <span class="keyword">return</span> texture;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>OK</p>
<h2 id="2020年5月15日22点11分更新补充"><a href="#2020年5月15日22点11分更新补充" class="headerlink" title="2020年5月15日22点11分更新补充"></a>2020年5月15日22点11分更新补充</h2><p><strong>问题:当把图片写入成二进制文件的时候实在是太大了</strong></p>
<p><strong>解决方案:把byte压缩</strong></p>
<p>查了资料,C# 中已经有了相关类(We are so lucky 😍)</p>
<p>压缩类:<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.compression.gzipstream?view=netcore-3.1">https://docs.microsoft.com/zh-cn/dotnet/api/system.io.compression.gzipstream?view=netcore-3.1</a></p>
<p>开源地址:<a target="_blank" rel="noopener" href="https://github.com/microsoft/referencesource/tree/master/System/sys/system/IO/compression">https://github.com/microsoft/referencesource/tree/master/System/sys/system/IO/compression</a></p>
<p>压缩有<code>Gzip</code>压缩(压缩快,但是稍大)和<code>Brotli</code>(压缩慢些,但是压缩后文件小)</p>
<p>新建一个Byte[]压缩类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">using System.IO;</span><br><span class="line">using System.IO.Compression;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 压缩和解压缩 本类使用的是Gzip压缩</span><br><span class="line">/// https://docs.microsoft.com/zh-cn/dotnet/api/system.io.compression.gzipstream.-ctor?view=netcore-3.1</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">public class CompressDecompressUtil</span><br><span class="line">&#123;</span><br><span class="line">    #region 压缩字节</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 压缩byte[](采用的GZip压缩 还有种是Brotli压缩)</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;rawBytes&quot;&gt;原始byte[]数据&lt;/param&gt;</span><br><span class="line">    /// &lt;returns&gt;压缩后的bytes[]&lt;/returns&gt;</span><br><span class="line">    public static byte[] CompressBytes(byte[] rawBytes)</span><br><span class="line">    &#123;</span><br><span class="line">        //声明一个MemoryStream流用来存放压缩后的byte[]</span><br><span class="line">        using (MemoryStream compressStream = new MemoryStream())</span><br><span class="line">        &#123;</span><br><span class="line">            //创建一个GZipStream 用来压缩</span><br><span class="line">            using (var conpressionGzipStream = new GZipStream(compressStream, CompressionMode.Compress))</span><br><span class="line">            &#123;</span><br><span class="line">                conpressionGzipStream.Write(rawBytes, 0, rawBytes.Length);</span><br><span class="line">                //或者</span><br><span class="line">                // gzipStream.CopyTo(compressStream);</span><br><span class="line">            &#125;</span><br><span class="line">            return compressStream.ToArray();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 解压缩字节</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;compressBytes&quot;&gt;经过Gzip压缩后的byte[]&lt;/param&gt;</span><br><span class="line">    /// &lt;returns&gt;返回原始的byte[]&lt;/returns&gt;</span><br><span class="line">    public static byte[] DecompressFormBytes(byte[] compressBytes)</span><br><span class="line">    &#123;</span><br><span class="line">        //声明一个compressStream表示原来的压缩流</span><br><span class="line">        using (var compressStream = new MemoryStream(compressBytes))</span><br><span class="line">        &#123;</span><br><span class="line">            //从原来的压缩流 解压出 原始数据</span><br><span class="line">            using (GZipStream decompressiongzipStream = new GZipStream(compressStream, CompressionMode.Decompress))</span><br><span class="line">            &#123;</span><br><span class="line">                using (var resultStream = new MemoryStream())</span><br><span class="line">                &#123;</span><br><span class="line">                    //用read比较麻烦</span><br><span class="line">                    decompressiongzipStream.CopyTo(resultStream);</span><br><span class="line">                    return resultStream.ToArray();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    #endregion</span><br><span class="line"></span><br><span class="line">    //todo</span><br><span class="line"></span><br><span class="line">    #region 压缩文件</span><br><span class="line"></span><br><span class="line">    #endregion</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>然后上面的读取 和写入方法稍微修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">   /// 从二进制文件中加载图片</span><br><span class="line">   /// 如果使用了Gzip压缩,文件后缀必须有&quot;.gz&quot;</span><br><span class="line">   /// 配合WriteTexture2DToRawData方法来使用</span><br><span class="line">   /// &lt;/summary&gt;</span><br><span class="line">   /// &lt;param name=&quot;rawdataPath&quot;&gt;图片rawdate路径&lt;/param&gt;</span><br><span class="line">   /// &lt;param name=&quot;useGzipDecompress&quot;&gt;是否使用gzip解压缩,如果使用了gzip压缩的话&lt;/param&gt;</span><br><span class="line">   /// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">   public static Texture2D LoadTexture2DFromRawData(string rawdataPath, bool useGzipDecompress)</span><br><span class="line">   &#123;</span><br><span class="line">       using (BinaryReader br = new BinaryReader(File.OpenRead(rawdataPath)))</span><br><span class="line">       &#123;</span><br><span class="line">           //先读取前三个宽 高 格式</span><br><span class="line">           int w = br.ReadInt32();</span><br><span class="line">           int h = br.ReadInt32();</span><br><span class="line">           int format = br.ReadInt32();</span><br><span class="line"></span><br><span class="line">           //在读取剩下的texture raw data</span><br><span class="line">           //此时的br.BaseStream.Position=12</span><br><span class="line">           byte[] bs = br.ReadBytes((int)(br.BaseStream.Length - br.BaseStream.Position));</span><br><span class="line">           //用&amp;&amp; 不用 &amp;</span><br><span class="line">           if (useGzipDecompress &amp;&amp; Path.GetExtension(rawdataPath) == &quot;.gz&quot;)</span><br><span class="line">           &#123;</span><br><span class="line">               bs = CompressDecompressUtil.DecompressFormBytes(bs);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           TextureFormat textureFormat = (TextureFormat)format;</span><br><span class="line">           Texture2D texture = new Texture2D(w, h, textureFormat, false);</span><br><span class="line">           texture.LoadRawTextureData(bs);</span><br><span class="line">           texture.Apply(false);</span><br><span class="line">           return texture;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   /// &lt;summary&gt;</span><br><span class="line">   /// 将图片保存到二进制文件,</span><br><span class="line">   /// &lt;/summary&gt;</span><br><span class="line">   /// &lt;param name=&quot;texture&quot;&gt;图片&lt;/param&gt;</span><br><span class="line">   /// &lt;param name=&quot;savePath&quot;&gt;保存路径(例如:xxx.png.bytes)&lt;/param&gt;</span><br><span class="line">   /// &lt;param name=&quot;useGzipCompress&quot;&gt;是否使用Gzip压缩&lt;/param&gt;</span><br><span class="line">   public static void WriteTexture2DToRawData(Texture2D texture, string savePath, bool useGzipCompress)</span><br><span class="line">   &#123;</span><br><span class="line">       byte[] bs = texture.GetRawTextureData();</span><br><span class="line">       if (useGzipCompress)</span><br><span class="line">       &#123;</span><br><span class="line">           bs = CompressDecompressUtil.CompressBytes(bs);</span><br><span class="line">           savePath += &quot;.gz&quot;; //加个后缀名</span><br><span class="line">       &#125;</span><br><span class="line">       using (BinaryWriter bw = new BinaryWriter(File.OpenWrite(savePath)))</span><br><span class="line">       &#123;</span><br><span class="line">           //前12个byte 用来保存图片的宽度 高度 和格式</span><br><span class="line">           //提前把前三个写入</span><br><span class="line">           bw.Write(texture.width);</span><br><span class="line">           bw.Write(texture.height);</span><br><span class="line">           bw.Write((int)texture.format);</span><br><span class="line">           //bw.Write(texture.streamingMipmaps);</span><br><span class="line">           //------</span><br><span class="line">           bw.Write(bs);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>食用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void Instance_OnKeyDown1()</span><br><span class="line">  &#123;</span><br><span class="line">      Texture2D tex2 = TextureUtility.LoadTexture2DFromIO(path + &quot;222.png&quot;);</span><br><span class="line">      TextureUtility.WriteTexture2DToRawData(tex2, path + &quot;222.png.bytes&quot;, true);</span><br><span class="line">      rawImage.texture = TextureUtility.LoadTexture2DFromRawData(path + &quot;222.png.bytes.gz&quot;,false);</span><br><span class="line">      Debug.Log(&quot;end&quot;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>我在画图中画了一个1024*1024纯红图片,如果没有压缩那么是4M,压缩后直接成5kb!!! 压缩算法 就不多解读了,具体可以查看源码。</p>
<h1 id="Texture-优化"><a href="#Texture-优化" class="headerlink" title="Texture 优化"></a>Texture 优化</h1><p>2020年11.16更新</p>
<p>移动端考虑图片压缩方式使用ASTC方式压缩了,在ios和android可以通用该压缩方式.</p>
<p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162206496.jpg"></p>
<h2 id="ASTC-压缩"><a href="#ASTC-压缩" class="headerlink" title="ASTC 压缩"></a>ASTC 压缩</h2><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162206497.png"></p>
<p>后面是每个像素占据的bit,例如ASTC4*4 每个像素占据8bit&#x3D;1kb,对于1024x1024大小的图,在unity中压缩后大小就是1m</p>
<h3 id="适配机型"><a href="#适配机型" class="headerlink" title="适配机型"></a>适配机型</h3><ol>
<li><p><strong>IOS</strong></p>
<p>苹果从A8处理器开始支持 ASTC，iPhone6及iPad mini 4以上iOS设备支持，2014年的iPhone 5s及iPad mini 3以前的设备不支持。</p>
</li>
<li><p><strong>Android</strong></p>
<p>所有支持OpenGL ES 3.1和部分支持OpenGL ES 3.0的GPU</p>
<p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162206498.jpg"></p>
</li>
</ol>
<p>就算部分机型不支持该压缩,也可以有fallback</p>
<p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162206499.jpg"></p>
<h3 id="使用ASTC压缩比率选择"><a href="#使用ASTC压缩比率选择" class="headerlink" title="使用ASTC压缩比率选择"></a>使用ASTC压缩比率选择</h3><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162206500.jpg"></p>
<p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162206501.jpg"></p>
<p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162206502.jpg"></p>
<p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162206503.jpg"></p>
<p>​	</p>
<p><strong>总结:</strong>  <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162206504.jpg"></p>
<ol>
<li>如果图片没有透明通道,再导入的时候应该设置不导入,不然会影响ASTC压缩</li>
<li>压缩还是要具体打包看图片质量</li>
</ol>
<h2 id="导入设置"><a href="#导入设置" class="headerlink" title="导入设置"></a>导入设置</h2><h3 id="正确设置没有透明通道图片的导入格式"><a href="#正确设置没有透明通道图片的导入格式" class="headerlink" title="正确设置没有透明通道图片的导入格式"></a>正确设置没有透明通道图片的导入格式</h3><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162206505.jpg"></p>
<h3 id="Alpha-Is-Transparency"><a href="#Alpha-Is-Transparency" class="headerlink" title="Alpha Is Transparency"></a>Alpha Is Transparency</h3><p>​	解释为Alpha 是否是半透明, Unity只处理全透明,如果开启了此选项,就是有半透明效果,<code>如果图片没有透明通道可以关闭这个选项</code></p>
<p>​	<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/340754532">聊聊 Unity 的 Alpha Is Transparency 有什么用 - 知乎 (zhihu.com)</a></p>
<h3 id="Texture中的过滤模式"><a href="#Texture中的过滤模式" class="headerlink" title="Texture中的过滤模式"></a>Texture中的过滤模式</h3><p><code>就是像素与像素之间过度</code></p>
<p>过滤模式会提供多种方案来使得纹理投影到物体表面的过程变得更为顺滑自然。一般来讲，Unity提供了三种模式：</p>
<p><code>Point（no filter）</code>——Point模式为不过滤的采样方式.<code>类似PS像素一块一块的</code>,的使用最近点采样的方法，当UV坐标没有刚好对应Texture上的一个采样点时，它会选择最近的一个采样点作为该坐标的采样值。当纹理没有拉伸变形时，这样速度是最快的，且效果理想。但如果拉伸变形了，会出现马赛克现象。</p>
<p><code>Bilinear</code>——双线性过滤模式。<code>两个像素点之间平衡,看起来更平滑</code>,简单来讲，它会对相邻的像素进行模糊化处理，使得像素之间的变化更为圆润平滑，不会有明显的锯齿感或者马赛克化。但这只涉及单个“平面”的操作，所以一旦涉及mipmap层级间的处理，双线性过滤就会有些“力不从心”，某些表现效果会大打折扣。</p>
<p><code>Trilinear</code>——三线性过滤模式。和Bilinear模式类似，但是额外优化了mipmap层级间的转换效果，它会在mip层级间进行模糊处理，弥补了Bilinear模式的不足。</p>
<p>这里我们延伸讲一下关于“mipmap”的概念。简单来讲为了更好地应对纹理贴图在不同距离和大小情况下的表现效果，以提升渲染的速度和降低图像锯齿化的影响，Unity会以纹理原尺寸为基础，预设几个等比例缩放的“复制品”，在实际使用中会根据情况加载对应的mipmap贴图，从而提升渲染性能，放大缩小的过程也因为mipmap层级的选择而更为快捷。</p>
<p>回到规则本身，Trilinear模式对表现效果的提升，是以GPU的额外开销为代价的。同等条件下，三线性过滤的GPU占用是最高的。所以如果对纹理的细致程度不那么敏感（比如像素类游戏），或者不涉及mipmapping的应用（比如2D游戏），那么就没有必要去选择Trilinear模式。</p>
<p>所以建议开发团队对本条规则检测下的纹理资源，依据项目实际需求进行相关的过滤模式的修改</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/158740249">ASTC纹理压缩格式详解</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/269535734">纹理优化：不仅仅是一张图片那么简单</a></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://zeroultra.github.io">Roger</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zeroultra.github.io/2020/04-21-2020-4-21-Texture-In-Unity/">https://zeroultra.github.io/2020/04-21-2020-4-21-Texture-In-Unity/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zeroultra.github.io" target="_blank">ZeroUltra</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Unity/">Unity</a><a class="post-meta__tags" href="/tags/Texture/">Texture</a></div><div class="post_share"><div class="social-share" data-image="/img/default_cover4.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/05-08-2020-5-08-Font-In-Unity/"><img class="prev-cover" src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202212171913054.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Font In Unity</div></div></a></div><div class="next-post pull-right"><a href="/2020/02-13-2020-2-13-UGUI%E8%87%AA%E9%80%82%E5%BA%94/"><img class="next-cover" src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202212171812021.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">UGUI自适应</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/02-04-2020-2-04-UGUI%E4%BC%98%E5%8C%96/" title="UGUI优化"><img class="cover" src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202212171812021.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-04</div><div class="title">UGUI优化</div></div></a></div><div><a href="/2020/02-13-2020-2-13-UGUI%E8%87%AA%E9%80%82%E5%BA%94/" title="UGUI自适应"><img class="cover" src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202212171812021.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-13</div><div class="title">UGUI自适应</div></div></a></div><div><a href="/2020/05-08-2020-5-08-Font-In-Unity/" title="Font In Unity"><img class="cover" src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202212171913054.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-08</div><div class="title">Font In Unity</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Unity%E4%B8%ADTexture%E4%B8%AD%E5%90%84%E7%A7%8D%E5%85%B3%E7%B3%BB%E4%BB%A5%E5%8F%8AApply-%E6%96%B9%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">Unity中Texture中各种关系以及Apply()方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Unity%E4%B8%ADTexture%E5%86%85%E5%AD%98%E8%AE%A1%E7%AE%97%E6%96%B9%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">Unity中Texture内存计算方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Texture2D%E4%B8%AD%E7%9A%84RawData"><span class="toc-number">3.</span> <span class="toc-text">Texture2D中的RawData</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2020%E5%B9%B45%E6%9C%8815%E6%97%A522%E7%82%B911%E5%88%86%E6%9B%B4%E6%96%B0%E8%A1%A5%E5%85%85"><span class="toc-number">3.1.</span> <span class="toc-text">2020年5月15日22点11分更新补充</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Texture-%E4%BC%98%E5%8C%96"><span class="toc-number">4.</span> <span class="toc-text">Texture 优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ASTC-%E5%8E%8B%E7%BC%A9"><span class="toc-number">4.1.</span> <span class="toc-text">ASTC 压缩</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E6%9C%BA%E5%9E%8B"><span class="toc-number">4.1.1.</span> <span class="toc-text">适配机型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8ASTC%E5%8E%8B%E7%BC%A9%E6%AF%94%E7%8E%87%E9%80%89%E6%8B%A9"><span class="toc-number">4.1.2.</span> <span class="toc-text">使用ASTC压缩比率选择</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E8%AE%BE%E7%BD%AE"><span class="toc-number">4.2.</span> <span class="toc-text">导入设置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E8%AE%BE%E7%BD%AE%E6%B2%A1%E6%9C%89%E9%80%8F%E6%98%8E%E9%80%9A%E9%81%93%E5%9B%BE%E7%89%87%E7%9A%84%E5%AF%BC%E5%85%A5%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.2.1.</span> <span class="toc-text">正确设置没有透明通道图片的导入格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Alpha-Is-Transparency"><span class="toc-number">4.2.2.</span> <span class="toc-text">Alpha Is Transparency</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Texture%E4%B8%AD%E7%9A%84%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.2.3.</span> <span class="toc-text">Texture中的过滤模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">4.3.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('/img/category_img.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Roger</div><div class="framework-info"><span>框架 </span><a href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">犯我中华者虽远必诛</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 's1tU09u71SORzEXhzkOUv8Sj-gzGzoHsz',
      appKey: '3tEBA5yTAbHngderFMTaV0Gx',
      avatar: 'wavatar',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/unitychan.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":true},"react":{"opacity":0.8},"log":false});</script></body></html>