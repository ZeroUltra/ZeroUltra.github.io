<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZeroUltra</title>
  
  <subtitle>业精于勤荒于嬉</subtitle>
  <link href="https://zeroultra.github.io/atom.xml" rel="self"/>
  
  <link href="https://zeroultra.github.io/"/>
  <updated>2024-01-01T04:01:21.000Z</updated>
  <id>https://zeroultra.github.io/</id>
  
  <author>
    <name>Roger</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Unity中的内置资源以及打AB包注意事项</title>
    <link href="https://zeroultra.github.io/2024/01-01-Unity%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E8%B5%84%E6%BA%90%E4%BB%A5%E5%8F%8A%E6%89%93AB%E5%8C%85%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%20-%20%E5%89%AF%E6%9C%AC/"/>
    <id>https://zeroultra.github.io/2024/01-01-Unity%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E8%B5%84%E6%BA%90%E4%BB%A5%E5%8F%8A%E6%89%93AB%E5%8C%85%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%20-%20%E5%89%AF%E6%9C%AC/</id>
    <published>2024-01-01T04:01:21.000Z</published>
    <updated>2024-01-01T04:01:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于Unity中的内置资源"><a href="#关于Unity中的内置资源" class="headerlink" title="关于Unity中的内置资源"></a>关于Unity中的内置资源</h1><p>内置资源主要分为两个来源：<code>Resources/unity_builtin_extra</code> 和<code>Library/unity default resources</code></p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202401020126553.png?token=AJD3J3KVTHDABV43IRPKYBDFSL3AI" alt="image-20240102012629532"></p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202401020015476.png?token=AJD3J3LW6P6EONPUS2LJ2E3FSLSUY" alt="image-20240102001507173"></p><p>可以通过代码得到资源类型</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> assets = AssetDatabase.LoadAllAssetsAtPath(<span class="string">&quot;Resources/unity_builtin_extra&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> assets2 = AssetDatabase.LoadAllAssetsAtPath(<span class="string">&quot;Library/unity default resources&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li><p>Resources&#x2F;unity_builtin_extra下资源对应的guid始终为0000000000000000f000000000000000。</p></li><li><p>Library&#x2F;unity default resources下资源对应的guid始终为0000000000000000e000000000000000。</p></li></ul><h2 id="Library-unity-default-resources"><a href="#Library-unity-default-resources" class="headerlink" title="Library&#x2F;unity default resources"></a>Library&#x2F;unity default resources</h2><p>这里面资源是固定的，是一些<code>shader和GUISkin(IMGUI资源),Arial字体和一些Unity内部texture(如logo,development标记..)</code>等等，虽以<code>Library</code>开头但是在library文件夹中找不到它，<code>这个文件一定会全部打进包里，unity版本不同可能里面的也资源不同</code>。</p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202401020009365.png?token=AJD3J3PT6XKNEJEGMSFIURDFSLR6W" alt="image-20240102000909809"></p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202401020012306.png?token=AJD3J3INV2JN2VD6EEAA6H3FSLSJW" alt="资源"></p><h3 id="打包AssetBundle"><a href="#打包AssetBundle" class="headerlink" title="打包AssetBundle"></a>打包AssetBundle</h3><p>如果某些assetbundle包中包含了这些资源将不会的打进ab包中， 即<code>永远不会造成ab资源冗余</code>,很像unity自己打了一个ab包</p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202401020037667.png?token=AJD3J3MCEI4GGVRA5VAOKMDFSLVII" alt="7bbaaeda323863e954df35032a0e6d6c"></p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202401020038636.png?token=AJD3J3MW5QGDLJR22OIG3YLFSLVLC" alt="image-20240102003808039"></p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202401020038021.png?token=AJD3J3N7WAPVEAGUT5SOIXTFSLVNW" alt="image-20240102003850870"></p><p>由上图可见，我在Text组件中用了Arial字体属于<code>unity default resources</code>,不会打进ab包。同样我在gameobject_1中用了一个脚本引用了GUISkin也是没有打进ab包的(只是打了一个mono脚本)</p><h2 id="Resources-unity-builtin-extra"><a href="#Resources-unity-builtin-extra" class="headerlink" title="Resources&#x2F;unity_builtin_extra"></a>Resources&#x2F;unity_builtin_extra</h2><p>里面包括资源：Shader，Material，Texture(都是UGUI的图,看文章开头图,这些图原格式都是psd,具体可以ugui源代码)以及Sprite(UGUI的精灵图),内置资源在发布时是会按需裁剪的,影响他的大小因素(现在所知),来自Project Setting-&gt;Graphics-&gt;Always included shaders的size大小</p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202401020048876.png?token=AJD3J3OEZUB226P4IRA6NZ3FSLWQ2" alt="image-20240102004814241"></p><p>通过解包来看里面的资源(手机版暂没发现),里面都是shader</p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202401020112830.png?token=AJD3J3LZME7AES4BNSJZE5LFSLZLY" alt="image-20240102011228983"></p><h3 id="打包AssetBundle-1"><a href="#打包AssetBundle-1" class="headerlink" title="打包AssetBundle"></a>打包AssetBundle</h3><p>这里面的资源不会剥离,而是会随着ab包打进,如果有两个uiprefab的ab包，都引用了其中的Sprite资源(例如Background)，那么他会打进两个ab中，<code>会造成冗余,需要注意</code></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/386625317">Unity实践—Unity 内置资源独立打包 - 知乎 (zhihu.com)</a></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/669070779">Unity冗余资源全面优化 - 知乎 (zhihu.com)</a></p><p><a target="_blank" rel="noopener" href="https://blog.uwa4d.com/archives/1577.html">Unity 5.x AssetBundle零冗余解决方案 - UWA问答 | 博客 | 游戏及VR应用性能优化记录分享 | 侑虎科技 (uwa4d.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于Unity中的内置资源&quot;&gt;&lt;a href=&quot;#关于Unity中的内置资源&quot; class=&quot;headerlink&quot; title=&quot;关于Unity中的内置资源&quot;&gt;&lt;/a&gt;关于Unity中的内置资源&lt;/h1&gt;&lt;p&gt;内置资源主要分为两个来源：&lt;code&gt;Resourc</summary>
      
    
    
    
    <category term="Unity" scheme="https://zeroultra.github.io/categories/Unity/"/>
    
    <category term="Assets" scheme="https://zeroultra.github.io/categories/Unity/Assets/"/>
    
    
    <category term="Unity" scheme="https://zeroultra.github.io/tags/Unity/"/>
    
    <category term="Assets" scheme="https://zeroultra.github.io/tags/Assets/"/>
    
  </entry>
  
  <entry>
    <title>UnityEngine.Object和System.Object</title>
    <link href="https://zeroultra.github.io/2024/01-01-UnityEngine.Object%E5%92%8CSystem.Object/"/>
    <id>https://zeroultra.github.io/2024/01-01-UnityEngine.Object%E5%92%8CSystem.Object/</id>
    <published>2024-01-01T04:01:21.000Z</published>
    <updated>2024-01-01T04:01:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="由编辑器引发的思考，普通类是UnityEngine-Object？"><a href="#由编辑器引发的思考，普通类是UnityEngine-Object？" class="headerlink" title="由编辑器引发的思考，普通类是UnityEngine.Object？"></a>由编辑器引发的思考，普通类是UnityEngine.Object？</h2><p>​起因是我想在Unity的Inspector界面绘制一个普通类（类似每个Mono脚本的Script字段），一个普通类应该默认继承的是<code>System.Object</code>，而使用EditorGUILayout.ObjectField绘制的是一个UnityEngine.Object,该如何绘制呢？</p><p>我写了个测试代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NewClass</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Print</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">Debug.Log(<span class="string">&quot;this NewClass&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NewMonoBehaviour2</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> UnityEngine.Object obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我将新建的普通类拖上去居然能拖入！！！那么自己建的普通类属于UnityEngine.Object吗？？？</p><p>然后我又答应了一下这个<code>obj</code>所在的父类</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NewMonoBehaviour2</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> UnityEngine.Object obj;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">Start</span>()</span></span><br><span class="line">     &#123;</span><br><span class="line">         PrintInheritanceChain(obj.GetType());</span><br><span class="line">         <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintInheritanceChain</span>(<span class="params">Type type</span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         Type baseType = type.BaseType;</span><br><span class="line">         <span class="keyword">if</span> (baseType != <span class="literal">null</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             Debug.Log(<span class="string">&quot;  继承 from: &quot;</span> + baseType.ToString());</span><br><span class="line">             PrintInheritanceChain(baseType); <span class="comment">// 递归调用，打印父类的继承链</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>打印结果是：<code>继承 form UnityEngine.TextAsset</code>-&gt;<code>继承 form UnityEngine.Object</code>-&gt;<code>继承 form System.Object</code></p><p>此时我怀疑的信了普通类也是继承了UnityEngine.Object，问了一下AI，都说普通类如果没有强声明继承System.Object，那就是隐氏继承了UnityEngine.Object</p><p>疑惑了一会我改了代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NewMonoBehaviour2</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">public</span> NewClass _newClass; <span class="comment">//自定义类 不继承MonoBehaviour</span></span><br><span class="line">     <span class="keyword">public</span> UnityEngine.Object obj;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">Start</span>()</span></span><br><span class="line">     &#123;</span><br><span class="line">         _newClass = <span class="keyword">new</span> NewClass();</span><br><span class="line">         PrintInheritanceChain(_newClass.GetType());</span><br><span class="line">         <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintInheritanceChain</span>(<span class="params">Type type</span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         Type baseType = type.BaseType;</span><br><span class="line">         <span class="keyword">if</span> (baseType != <span class="literal">null</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             Debug.Log(<span class="string">&quot;  继承 from: &quot;</span> + baseType.ToString());</span><br><span class="line">             PrintInheritanceChain(baseType); <span class="comment">// 递归调用，打印父类的继承链</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>此时打印的只有一个，就是<code>继承 form System.Object</code></p><p>查阅了资料最后得出结论</p><ul><li>不管是普通类还是继承了Mono的类，只要是C#文件，在<code>编辑器中</code>都会当成MonoScript文件来对待，把它当成Unity中可识别的资源（<a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2021.3/ScriptReference/MonoScript.html">MonoScript - Unity 脚本 API</a>）,这里就解释了为什么一开始能拖到面板上，并且打印的是继承TextAssets,UnityObject…</li><li>当在运行时，声明一个普通类需要通过<code>new</code>来声明，这个时候它是来自于.net内存中（先这么叫），所以就是继承System.Object</li></ul><h2 id="UnityEngine-Object和"><a href="#UnityEngine-Object和" class="headerlink" title="UnityEngine.Object和?.  ??"></a>UnityEngine.Object和?.  ??</h2><p>首先微软没有提供<code>?? ?.</code> 这两的重写，所以UnityEngine.Object不支持，官方文档 <a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2020.3/ScriptReference/Object.html">Object - Unity 脚本 API</a></p><p>那么在如下代码为什么发现又是可行的呢？</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NewMonoBehaviour2</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> TestMono _testMono; <span class="comment">//自定义脚本继承了MonoBehaviour</span></span><br><span class="line">    <span class="keyword">public</span> BoxCollider2D _collider2D;  <span class="comment">//Unity中的Collider</span></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//物体添加了这个mono脚本和BoxCollider2D</span></span><br><span class="line">        _testMono ??= GetComponent&lt;TestMono&gt;(); <span class="comment">//获取到了</span></span><br><span class="line">        _collider2D ??= GetComponent&lt;BoxCollider2D&gt;(); <span class="comment">//没获取到</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>从结果看，大可以这么认为，自己的脚本继承Mono属于C#层，可以使用??，但是BoxCollider2D是Unity引擎的C++层，所以不适用??，  再加上雨松的一篇文章：<a target="_blank" rel="noopener" href="https://www.xuanyusong.com/archives/4713">Unity3D研究院之UnityEngine.Object和System.Object</a>，就更确信无疑了。</p><p>但是我们知道继承的Mono也是来继承自UnityEngine.Object，官方说了不支持?? ?. 这里发现是支持的，还为自己找了借口，难道错了吗？</p><p>查看<a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2020.3/Manual/overview-of-dot-net-in-unity.html">Unity 中的 .NET 概述 - Unity 手册</a>中有说到</p><blockquote><h3 id="Unity-C-和-Unity-C-共享-UnityEngine-对象"><a href="#Unity-C-和-Unity-C-共享-UnityEngine-对象" class="headerlink" title="Unity C# 和 Unity C++ 共享 UnityEngine 对象"></a>Unity C# 和 Unity C++ 共享 UnityEngine 对象</h3><p>使用诸如 <a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2020.3/ScriptReference/Object.Destroy.html">Object.Destroy</a> 或 <a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2020.3/ScriptReference/Object.DestroyImmediate.html">Object.DestroyImmediate</a> 等方法销毁 UnityEngine.Object 派生对象时，Unity 会销毁（卸载）原生对应对象。无法使用显式调用销毁 C# 对象，因为垃圾回收器会管理内存。一旦不再引用托管对象，垃圾回收器便会收集并销毁它。</p><p>如果再次访问已销毁的 &#96;UnityEngine.Object，则 Unity 会为大多数类型重新创建原生对应对象。此重新创建行为的两个例外是 <a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2020.3/ScriptReference/MonoBehaviour.html">MonoBehaviour</a> 和 <a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2020.3/Manual/ScriptableObject">ScriptableObject</a>：一旦被销毁，Unity 便绝不会重新加载它们。</p><p>MonoBehaviour 和 ScriptableObject 会覆盖相等 (<code>==</code>) 和不相等 (<code>!=</code>) 运算符。因此，如果将销毁的 MonoBehaviour 或 ScriptableObject 与 null 进行比较，则当托管对象仍然存在且尚未进行垃圾收集时，运算符会返回 true。</p><p>因为 <code>??</code> 和 <code>?.</code> 运算符不可重载，所以它们与从 <code>UnityEngine.Object</code> 派生的对象不兼容。在托管对象仍然存在的情况下对销毁的 MonoBehaviour 或 ScriptableObject 进行使用时，这些运算符不会返回与相等和不相等运算符相同的结果。</p></blockquote><p>主要最后一句：<code>因为 </code>??<code>和</code>?.<code> 运算符不可重载，所以它们与从 UnityEngine.Object 派生的对象不兼容。在托管对象仍然存在的情况下对销毁的 MonoBehaviour 或 ScriptableObject 进行使用时，这些运算符不会返回与相等和不相等运算符相同的结果。</code></p><p>意思是如果对销毁的Mono进行<code>?? ?.</code>操作，不会返回正确的结果，代码如下</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NewMonoBehaviour2</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//自定义脚本继承了MonoBehaviour</span></span><br><span class="line">    <span class="keyword">public</span> TestMono _testMono;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//物体添加了这个mono脚本</span></span><br><span class="line">        _testMono ??= GetComponent&lt;TestMono&gt;();</span><br><span class="line">        Debug.Log(_testMono == <span class="literal">null</span>);  <span class="comment">//结果:false</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//销毁 要等一帧 际的对象销毁操作始终延迟到当前更新循环结束，但始终在渲染前完成</span></span><br><span class="line">        <span class="comment">//https://docs.unity.cn/cn/2020.3/ScriptReference/Object.Destroy.html</span></span><br><span class="line">        Destroy(_testMono); </span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        Debug.Log(_testMono == <span class="literal">null</span>); <span class="comment">//结果:true</span></span><br><span class="line">        _testMono ??= <span class="keyword">this</span>.gameObject.AddComponent&lt;TestMono&gt;();</span><br><span class="line">        Debug.Log(_testMono == <span class="literal">null</span>); <span class="comment">//结果:true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_testMono == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;testmono is null?&quot;</span>); <span class="comment">//打印了该条信息</span></span><br><span class="line">            _testMono = <span class="keyword">this</span>.gameObject.AddComponent&lt;TestMono&gt;();</span><br><span class="line">            Debug.Log(_testMono == <span class="literal">null</span>); <span class="comment">//结果:false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码结果来看，销毁了之后通过??就是不对的结果。这里的销毁时Unity引擎对Mono C++上的销毁，但是C#托管代码还在（UnityEngine.Object重写了&#x3D;&#x3D; !&#x3D;，可以通过<code>System.Object.ReferenceEquals(go, null)</code>来判断是否还存在），此时用??判断结果是不为null，所以获取不到。</p><h2 id="最后建议"><a href="#最后建议" class="headerlink" title="最后建议"></a>最后建议</h2><ul><li>对于继承<code>MonoBehaviour或者ScriptableObject </code>+Unity内置类都不要使用?? ?.    只对自己使用的普通类使用</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;由编辑器引发的思考，普通类是UnityEngine-Object？&quot;&gt;&lt;a href=&quot;#由编辑器引发的思考，普通类是UnityEngine-Object？&quot; class=&quot;headerlink&quot; title=&quot;由编辑器引发的思考，普通类是UnityEngine.</summary>
      
    
    
    
    <category term="Unity" scheme="https://zeroultra.github.io/categories/Unity/"/>
    
    <category term="Assets" scheme="https://zeroultra.github.io/categories/Unity/Assets/"/>
    
    
    <category term="Unity" scheme="https://zeroultra.github.io/tags/Unity/"/>
    
    <category term="Assets" scheme="https://zeroultra.github.io/tags/Assets/"/>
    
  </entry>
  
  <entry>
    <title>书记：《Unity游戏优化第三版》</title>
    <link href="https://zeroultra.github.io/2023/12-24-%E4%B9%A6%E8%AE%B0%EF%BC%9A%E3%80%8AUnity%E6%B8%B8%E6%88%8F%E4%BC%98%E5%8C%96%E7%AC%AC%E4%B8%89%E7%89%88%E3%80%8B/"/>
    <id>https://zeroultra.github.io/2023/12-24-%E4%B9%A6%E8%AE%B0%EF%BC%9A%E3%80%8AUnity%E6%B8%B8%E6%88%8F%E4%BC%98%E5%8C%96%E7%AC%AC%E4%B8%89%E7%89%88%E3%80%8B/</id>
    <published>2023-12-24T13:32:38.000Z</published>
    <updated>2023-12-24T13:32:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>内容来自《Unity游戏优化第三版》，书中内容也不一定全对，有比较基础的部分，做个简要记录</p><h1 id="第二章-脚本策略"><a href="#第二章-脚本策略" class="headerlink" title="第二章:脚本策略"></a>第二章:脚本策略</h1><ul><li>获取组件采用泛型获取即：<code>GetComponent&lt;T&gt;</code></li><li>移除MonoBehaviour中空定义，即如果不需要Update OnGUI等Unity的回调函数，直接删除</li><li>避免在运行时修改Transform的父对象</li></ul><blockquote><p>在Unity早期版本中，Transform组件的引用通常是在内存中随机排列的<br>也就是在多个Transform迭代是相当慢的，会存在缓存丢失的可能</p><p>修改GameObject的父节点为另一个对象不会造成显著的性能下降，因为Transform操作起来像堆数据结构，插入和删除的速度相对较快</p><p>但是在Unity5.4以后，Transform组件的内存布局发生了很大的变化<br>Transform组件的父子关系操作起来更像动态数组，Unity尝试将所有共享相同的父元素 Transform 按顺序存储在预先分配的内存缓冲区中的内存中，并在 Hierarchy 窗口下的深度进行排序<br>这样做的好处就是可以进行更快的迭代，尤其是物理和动画系统。</p><p>缺点：<br>1.如果将一个 GameObject 的父对象重新指定为另一个对象，父对象必须将新的子对象放入预先分配的内存缓冲区中，并根据新的深度对所有这些 Transform 排序<br>2.如果没有预先分配足够的空间来容纳新的子对象，就必须扩展缓冲区，以便以深度优先的顺序容纳新的子对象</p><p>通过 Object.Instantiate() 实例化新的 GameObject 时，其默认的父节点是 null，都放在 Hierarchy的根元素下<br>这里的所有元素同样也需要分配一个缓冲区来存储他当前的元素以及以后可能添加的元素<br>如果需要<strong>立即</strong>将Transform的元素重新修改为另一个元素，刚才的缓冲区就白分配了<br><strong>尽可能使用参数，跳过缓冲区分配的步骤</strong></p></blockquote><p>​在Instantiate()Gameobject的时候,如果要进行父对象变化,可以先直接传入,避免变化</p><p>​有多个变化,尽量使用一次性变化,例如使用<code>SetPositionAndRotation</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;内容来自《Unity游戏优化第三版》，书中内容也不一定全对，有比较基础的部分，做个简要记录&lt;/p&gt;
&lt;h1 id=&quot;第二章-脚本策略&quot;&gt;&lt;a href=&quot;#第二章-脚本策略&quot; class=&quot;headerlink&quot; title=&quot;第二章:脚本策略&quot;&gt;&lt;/a&gt;第二章:脚本策略&lt;</summary>
      
    
    
    
    <category term="Unity" scheme="https://zeroultra.github.io/categories/Unity/"/>
    
    <category term="优化" scheme="https://zeroultra.github.io/categories/Unity/%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="Unity" scheme="https://zeroultra.github.io/tags/Unity/"/>
    
    <category term="优化" scheme="https://zeroultra.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Unity中的优化</title>
    <link href="https://zeroultra.github.io/2023/10-25-Unity%E4%B8%AD%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <id>https://zeroultra.github.io/2023/10-25-Unity%E4%B8%AD%E7%9A%84%E4%BC%98%E5%8C%96/</id>
    <published>2023-10-25T06:54:49.000Z</published>
    <updated>2023-10-25T06:54:49.000Z</updated>
    
    
    
    
    <category term="Unity" scheme="https://zeroultra.github.io/categories/Unity/"/>
    
    <category term="优化" scheme="https://zeroultra.github.io/categories/Unity/%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="Unity" scheme="https://zeroultra.github.io/tags/Unity/"/>
    
    <category term="优化" scheme="https://zeroultra.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Unity&amp;Zapworks</title>
    <link href="https://zeroultra.github.io/2023/07-30-Unity&amp;Zapworks/"/>
    <id>https://zeroultra.github.io/2023/07-30-Unity&amp;Zapworks/</id>
    <published>2023-07-30T15:51:22.000Z</published>
    <updated>2023-07-30T15:51:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unity使用zapworks开发webgl平台AR项目"><a href="#Unity使用zapworks开发webgl平台AR项目" class="headerlink" title="Unity使用zapworks开发webgl平台AR项目"></a>Unity使用zapworks开发webgl平台AR项目</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li><a target="_blank" rel="noopener" href="https://docs.zap.works/universal-ar/unity/">Zapworks官网</a></li><li>支持webgl,android,ios三个平台</li><li>支持的技术有:<ul><li><p>图像跟踪(Image Tracking)</p></li><li><p>面部跟踪(Face Tracking)</p></li><li><p>即时世界跟踪(Instant World Tracking)类似slma技术</p></li></ul></li><li>其他具体看官网</li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="图像识别需要训练自己的图片对象"><a href="#图像识别需要训练自己的图片对象" class="headerlink" title="图像识别需要训练自己的图片对象"></a>图像识别需要训练自己的图片对象</h3><p>​打开<code>Zappar-&gt;Editor-&gt;Open Image Trainer</code></p><p>​<img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202307310014586.png" alt="image-20230731001418550"></p><p>​选择使用即可</p><h3 id="自定义开始模板语言"><a href="#自定义开始模板语言" class="headerlink" title="自定义开始模板语言"></a>自定义开始模板语言</h3><p>官方的语言很多都不支持</p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202307310017073.jpeg" alt="IMG_9694" style="zoom:67%;" /><p>根据办法:<a target="_blank" rel="noopener" href="https://forum.zap.works/t/camera-permission-message/8441">Camera Permission Message - Universal AR - ZapWorks Forum</a></p><p>下载回答中<a target="_blank" rel="noopener" href="https://zapworksforumuploads.s3.dualstack.eu-west-1.amazonaws.com/original/2X/1/1e762c65ba63210f1f7aaca34653ced03f447faf.zip">custom_permission.zip</a></p><p>然后修改对应的index.html文件,然后修改permission.js文件里面的注释(这段注释代码是插入html解释)</p><p>如下:</p><p> 在unity中打开<code>Zap ArSetting</code></p><p>   <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202307310028848.png" alt="image-20230731002804575"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//修改index.html文件中代码</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://libs.zappar.com/zappar-cv/2.1.4/zappar-cv.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">//在原来基础上增加这行,注意正确路径地址</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;permission/permission.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//WaitForZCVLoad();</span><br><span class="line">//改成下面</span><br><span class="line">custom_permission_request_ui_async(PermissionResolve);</span><br><span class="line">function PermissionResolve(success) &#123;</span><br><span class="line">        console.log(&quot;permission allowed: &quot;+success);</span><br><span class="line">    if(success)</span><br><span class="line">        WaitForZCVLoad();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> //修改permission.js中代码 </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;zappar-title&quot;</span>&gt;</span>自定义标题<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;zappar-text&quot;</span>&gt;</span>提示信息<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;custom-permission-request-button&quot;</span>&gt;</span>按钮信息<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​      </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Unity使用zapworks开发webgl平台AR项目&quot;&gt;&lt;a href=&quot;#Unity使用zapworks开发webgl平台AR项目&quot; class=&quot;headerlink&quot; title=&quot;Unity使用zapworks开发webgl平台AR项目&quot;&gt;&lt;/a&gt;Un</summary>
      
    
    
    
    <category term="Unity" scheme="https://zeroultra.github.io/categories/Unity/"/>
    
    <category term="Zapworks" scheme="https://zeroultra.github.io/categories/Unity/Zapworks/"/>
    
    
    <category term="Unity" scheme="https://zeroultra.github.io/tags/Unity/"/>
    
    <category term="Zapworks" scheme="https://zeroultra.github.io/tags/Zapworks/"/>
    
    <category term="AR" scheme="https://zeroultra.github.io/tags/AR/"/>
    
  </entry>
  
  <entry>
    <title>Unity小记</title>
    <link href="https://zeroultra.github.io/2023/07-05-Unity%E5%B0%8F%E8%AE%B0/"/>
    <id>https://zeroultra.github.io/2023/07-05-Unity%E5%B0%8F%E8%AE%B0/</id>
    <published>2023-07-05T04:01:21.000Z</published>
    <updated>2023-07-05T04:01:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Camera-Main问题"><a href="#Camera-Main问题" class="headerlink" title="Camera.Main问题"></a>Camera.Main问题</h2><p>​<code>camera.main是个静态属性，用起来好用，但是其中内部使用的是</code>GameObject.FindGameObjectWithTag&#96;</p><p>所以再Update或者经常使用这个函数的地方需要注意。</p><p>​这个问题也直接导致了UGUI相关的耗时，在Canvas Renderer modes使用<code>Screen Space-Camera</code>或者<code>World Space</code>的时候如果要获取相机使用内部函数也会导致一些问题</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">UnityEngine.UI</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">AddComponentMenu(<span class="string">&quot;Event/Graphic Raycaster&quot;</span>)</span>]</span><br><span class="line">    [<span class="meta">RequireComponent(typeof(Canvas))</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GraphicRaycaster</span> : <span class="title">BaseRaycaster</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//……</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">override</span> Camera eventCamera</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (canvas.renderMode == RenderMode.ScreenSpaceOverlay || (canvas.renderMode == RenderMode.ScreenSpaceCamera &amp;&amp; canvas.worldCamera == <span class="literal">null</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">return</span> canvas.worldCamera != <span class="literal">null</span> ? canvas.worldCamera : Camera.main;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2021-12-19更新"><a href="#2021-12-19更新" class="headerlink" title="2021&#x2F;12&#x2F;19更新"></a>2021&#x2F;12&#x2F;19更新</h4><p>官方2020.02版本更新了这个问题(不管他改不改 还是自己记录)</p><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/K5tIJmd5ZquTQdJnctn1RQ">有史以来最快的Unity编辑器版本，Unity 2020.2 中的性能优化 (qq.com)</a></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202204291912660.png" alt="image-20211219203011654"></p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ol><li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/murongxiaopifu/p/7823487.html">https://www.cnblogs.com/murongxiaopifu/p/7823487.html</a> </li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/cyf649669121/article/details/83661023">https://blog.csdn.net/cyf649669121/article/details/83661023</a></li></ol><h2 id="Unity中-的使用问题"><a href="#Unity中-的使用问题" class="headerlink" title="Unity中 ?? ?.的使用问题"></a>Unity中 <code>??</code> <code>?.</code>的使用问题</h2><p><code>??</code>是c#的一个语法糖,叫<code>空合并运算符</code>,如果左边不为空返回左边,否则返回右边</p><p>例子a&#x3D;b??c,如果b不为空,则a&#x3D;b,否则a&#x3D;c</p><p>在unity中我们可能这样使用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T t=<span class="keyword">this</span>.gameobject.GetComponent&lt;T&gt;()??<span class="keyword">this</span>.gameobject.AddComponent&lt;T&gt;();</span><br></pre></td></tr></table></figure><p>获取某个物体上面的Component,<code>但是我们获取Unity中内置的组件的时候这个方法得到的结果是永远不会为null</code></p><p>比如我们获取一个物体上面的相机,假如这个物体上面没有添加相机组件</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> camera = GetComponent&lt;Camera&gt;() ?? gameObject.AddComponent&lt;Camera&gt;();<span class="comment">//Camera组件不会被添加</span></span><br><span class="line"><span class="keyword">var</span> custom =  GetComponent&lt;CustomScript&gt;() ?? gameObject.AddComponent&lt;CustomScript&gt;(); <span class="comment">//CustomScript组件正常被添加</span></span><br></pre></td></tr></table></figure><p>原因是Unity底层是C++,而且C#源码<code>??</code> <code>?.</code>不能重载</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202212171836029.png" alt="image-20221217183624831"></p><p>总结:不要使用<code>?? ?.</code>操作unity 对象</p><h4 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h4><ol><li><a target="_blank" rel="noopener" href="https://www.xuanyusong.com/archives/4713">https://www.xuanyusong.com/archives/4713</a></li><li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/2020.3/Manual/overview-of-dot-net-in-unity.html">Unity 中的 .NET 概述 - Unity 手册 (unity3d.com)</a></li></ol><h2 id="UGUI-点击Bug"><a href="#UGUI-点击Bug" class="headerlink" title="UGUI 点击Bug"></a>UGUI 点击Bug</h2><p>​<code>当UI中父物体实现了IPointerDownHandler接口,而子物体实行了IPointerClickHandler接口的时候 ,点击子物体时候不会触发 Click事件.</code></p><p>​原因是UI源码中鼠标按下的时候会寻找实现了<code>IPointerDownHandler</code>这个接口的物体,从子物体向上寻找,所以这里就找到了父物体,然后鼠标抬起,找到实现了Click接口的物体,然后通过判断两者是否一直来触发Click事件. 这里寻找到了父物体,而寻找到click物体是子物体,所以判断不一致无法触发</p><p>链接:<a target="_blank" rel="noopener" href="https://www.cnblogs.com/msxh/p/10588783.html">https://www.cnblogs.com/msxh/p/10588783.html</a></p><p><a target="_blank" rel="noopener" href="http://www.sikiedu.com/course/468/task/35891/show">http://www.sikiedu.com/course/468/task/35891/show</a></p><h2 id="UnityWebRequest-UnEscapeURL和UnityWebRequest-EscapeURL"><a href="#UnityWebRequest-UnEscapeURL和UnityWebRequest-EscapeURL" class="headerlink" title="UnityWebRequest.UnEscapeURL和UnityWebRequest.EscapeURL"></a>UnityWebRequest.UnEscapeURL和UnityWebRequest.EscapeURL</h2><p>要想知道这两个参数是什么意思,需要理解Http中URL的特殊字符</p><blockquote><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1074824">Url参数中出现+、空格、&#x3D;、%、&amp;、#等字符的解决办法 - 云+社区 - 腾讯云 (tencent.com)</a></p><p>Url出现了有+，空格，&#x2F;，?，%，#，&amp;，&#x3D;等特殊符号的时候，可能在<a target="_blank" rel="noopener" href="https://www.yisu.com/">服务器</a>端无法获得正确的参数值，抑或是造成不能正常下载文件(作为Download Url时候)，如何是好？解决办法：就是需要将这些字符转化成服务器可以识别的字符；但是为何Url中有这些字符就会出现问题呢？这就得涉及到URL编码与解码问题了</p><p>一般来说，URL只能使用英文字母、阿拉伯数字和某些标点符号，不能使用其他文字和符号。Url的编码格式采用的是ASCII码，而不是Unicode，这也就是说你不能在Url中包含任何非ASCII字符，例如希腊字母or中文。比如，世界上有英文字母的网址<a target="_blank" rel="noopener" href="http://www.abc.com,但是没有希腊字母的网址http//www.a%CE%B2%CE%B3.com%EF%BC%88%E8%AF%BB%E4%BD%9C%E9%98%BF%E5%B0%94%E6%B3%95-%E8%B4%9D%E5%A1%94-%E4%BC%BD%E7%8E%9B.com%EF%BC%89%E3%80%82%E8%BF%99%E6%98%AF%E5%9B%A0%E4%B8%BA%E7%BD%91%E7%BB%9C%E6%A0%87%E5%87%86RFC">http://www.abc.com，但是没有希腊字母的网址http://www.aβγ.com（读作阿尔法-贝塔-伽玛.com）。这是因为网络标准RFC</a> 1738做了硬性规定</p><p>*<em>只有字母和数字[0-9a-zA-Z]、一些特殊符号”$-_.+!<em>’(),”[不包括双引号]、以及某些保留字，才可以不经过编码直接用于URL。</em></em></p><p>URL中有汉字，等特殊字符的时候，就必须编码后使用。而+，空格，&#x2F;，?，%，#，&amp;，&#x3D;，这些字符(不安全)，当把他们直接放在Url中的时候，可能会引起解析程序的歧义，因此也必须经过编码才能使用</p></blockquote><p>除了那些无法显示的字符外(例如中文)，还需要在URL中对那些保留(reserved)字符和不安全(unsafe)字符进行编码。</p><p><code>保留字符</code>就是那些在URL中具有特定意义的字符。<code>不安全字符</code>是指那些在URL中没有特殊含义，但在URL所在的上下文中可能具有特殊意义的字符。例如双引号(“”)</p><table><thead><tr><th align="left">部分保留字符和不安全字符及其URL编码</th><th></th><th></th><th></th></tr></thead><tbody><tr><td align="left">字符</td><td>描述</td><td>用法</td><td>编码</td></tr><tr><td align="left">;</td><td>分号</td><td>保留</td><td>%3B</td></tr><tr><td align="left">&#x2F;</td><td>斜线</td><td>保留</td><td>%2F</td></tr><tr><td align="left">?</td><td>问号</td><td>保留</td><td>%3F</td></tr><tr><td align="left">:</td><td>冒号</td><td>保留</td><td>%3A</td></tr><tr><td align="left">@</td><td>“at”符号</td><td>保留</td><td>%4O</td></tr><tr><td align="left">&#x3D;</td><td>等号</td><td>保留</td><td>%3D</td></tr><tr><td align="left">&amp;</td><td>“和”符号</td><td>保留</td><td>%26</td></tr><tr><td align="left">&lt;</td><td>小于号</td><td>不安全</td><td>%3C</td></tr><tr><td align="left">&gt;</td><td>大于号</td><td>不安全</td><td>%3E</td></tr><tr><td align="left">“</td><td>双引号</td><td>不安全</td><td>%22</td></tr><tr><td align="left">#</td><td>井号</td><td>不安全</td><td>%23</td></tr><tr><td align="left">%</td><td>百分号</td><td>不安全</td><td>%25</td></tr><tr><td align="left">{</td><td>左大括号</td><td>不安全</td><td>%7B</td></tr><tr><td align="left">}</td><td>右大括号</td><td>不安全</td><td>%7D</td></tr><tr><td align="left">|</td><td>竖线</td><td>不安全</td><td>%7C</td></tr><tr><td align="left">\</td><td>反斜线</td><td>不安全</td><td>%5C</td></tr><tr><td align="left">^</td><td>加字号</td><td>不安全</td><td>%5E</td></tr><tr><td align="left">~</td><td>波浪</td><td>不安全</td><td>%7E</td></tr><tr><td align="left">[</td><td>左中括号</td><td>不安全</td><td>%5B</td></tr><tr><td align="left">]</td><td>右中括号</td><td>不安全</td><td>%5D</td></tr><tr><td align="left">&#96;</td><td>反单引号</td><td>不安全</td><td>%60</td></tr><tr><td align="left"></td><td>空格</td><td>不安全</td><td>%20</td></tr></tbody></table><p>综上所述所研究所得:</p><ul><li>URL都是ASCll码,其他字符需要转义</li><li>URL编码其实是字符ASCll码的十六进制然后在前面加上%号,对应ASCII表格</li></ul><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162306856.png" alt="20220616230611"><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202308072137827.jpeg" alt="ASCII"></p><h2 id="关于Unity中帧率过高导致update计算过快的影响"><a href="#关于Unity中帧率过高导致update计算过快的影响" class="headerlink" title="关于Unity中帧率过高导致update计算过快的影响"></a>关于Unity中帧率过高导致update计算过快的影响</h2><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>unity程序发布如果没有设置<code>Dont Vsync+Application.targetFrame=xx</code>,且电脑关闭了垂直同步,电脑会以极高的帧率运行程序,如果设置了<code>Dont Vsync</code> 有可能会出现<code>画面撕裂</code>状况</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202307051206215.png" alt="image-20230705120604480"></p><p> 代码中有如下示例代码:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> currMousePos=Input.MousePosition;</span><br><span class="line">    <span class="comment">//计算移动距离</span></span><br><span class="line">    <span class="keyword">if</span>((currMousePos-lastMousePos).sqrMagnitude&gt;<span class="number">10000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//do</span></span><br><span class="line">    &#125;</span><br><span class="line">    lastMousePos=currMousePos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在编辑下帧率只要60的话,也许<code>10000</code>这个数值是可以,但是如果帧率很高的话,会导致结果偏小也许就100</p><p>原因是帧率搞运行快,检测的两帧移动距离就会偏小</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>要解决上面问题,就要是计算结果与帧率无关,这个其实就是在update中移动物体一样,使用<code>Time.deltaTime</code></p><p><code>帧率越大,Time.deltaTime越小</code></p><p><code>帧率越小,Time.deltaTime越大</code></p><p>改进后代码:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> currMousePos=Input.MousePosition;</span><br><span class="line">    <span class="comment">//计算移动距离 可以在Time.deltaTime*一个固定倍数,防止数值过大</span></span><br><span class="line">    <span class="keyword">var</span> detlaDis=(currMousePos-lastMousePos).sqrMagnitude/(Time.deltaTime);</span><br><span class="line">    <span class="keyword">if</span>(detlaDis&gt;<span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//do</span></span><br><span class="line">    &#125;</span><br><span class="line">    lastMousePos=currMousePos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关于Unity的Playersetting-OtherSetting-Stack-Track"><a href="#关于Unity的Playersetting-OtherSetting-Stack-Track" class="headerlink" title="关于Unity的Playersetting-&gt;OtherSetting-&gt;Stack Track"></a>关于Unity的Playersetting-&gt;OtherSetting-&gt;Stack Track</h2><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202307151853485.png" alt="image-20230715185315689"></p><p>这个是关于Unity中发布之后的日志<code>堆栈信息</code>,打包勾选<code>development build</code>,然后查看<code>console-&gt;open log file</code>如下</p><ul><li><p>None</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202307151905942.png" alt="image-20230715190544740"></p></li><li><p>ScriptOnly</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202307151906734.png" alt="image-20230715190639540"></p></li><li><p>Full</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202307151907609.png" alt="image-20230715190740710"></p></li></ul><h3 id="优化记录"><a href="#优化记录" class="headerlink" title="优化记录"></a>优化记录</h3><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202307151911183.png" alt="image-20230715191152056"></p><h2 id="关于Unity中的内置资源"><a href="#关于Unity中的内置资源" class="headerlink" title="关于Unity中的内置资源"></a>关于Unity中的内置资源</h2><p>内置资源主要分为两个来源：<code>Resources/unity_builtin_extra</code> 和<code>Library/unity default resources</code></p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202401020126553.png?token=AJD3J3KVTHDABV43IRPKYBDFSL3AI" alt="image-20240102012629532"></p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202401020015476.png?token=AJD3J3LW6P6EONPUS2LJ2E3FSLSUY" alt="image-20240102001507173"></p><p>可以通过代码得到资源类型</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> assets = AssetDatabase.LoadAllAssetsAtPath(<span class="string">&quot;Resources/unity_builtin_extra&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> assets2 = AssetDatabase.LoadAllAssetsAtPath(<span class="string">&quot;Library/unity default resources&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li><p>Resources&#x2F;unity_builtin_extra下资源对应的guid始终为0000000000000000f000000000000000。</p></li><li><p>Library&#x2F;unity default resources下资源对应的guid始终为0000000000000000e000000000000000。</p></li></ul><h4 id="Library-unity-default-resources"><a href="#Library-unity-default-resources" class="headerlink" title="Library&#x2F;unity default resources"></a>Library&#x2F;unity default resources</h4><p>着里面资源是固定的，是一些<code>shader和GUISkin(IMGUI资源),Arial字体和一些Unity内部texture(如logo,development标记..)</code>等等，虽以<code>Library</code>开头但是在library文件夹中找不到它，这个文件一定会全部打进包里，unity版本不同可能里面的也资源不同。</p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202401020009365.png?token=AJD3J3PT6XKNEJEGMSFIURDFSLR6W" alt="image-20240102000909809"></p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202401020012306.png?token=AJD3J3INV2JN2VD6EEAA6H3FSLSJW" alt="资源"></p><h5 id="打包AssetBundle"><a href="#打包AssetBundle" class="headerlink" title="打包AssetBundle"></a>打包AssetBundle</h5><p>如果某些assetbundle包中包含了这些资源将不会的打进ab包中，即永远不会造成ab资源冗余</p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202401020037667.png?token=AJD3J3MCEI4GGVRA5VAOKMDFSLVII" alt="7bbaaeda323863e954df35032a0e6d6c"></p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202401020038636.png?token=AJD3J3MW5QGDLJR22OIG3YLFSLVLC" alt="image-20240102003808039"></p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202401020038021.png?token=AJD3J3N7WAPVEAGUT5SOIXTFSLVNW" alt="image-20240102003850870"></p><p>由上图可见，我在Text组件中用了Arial字体属于<code>unity default resources</code>,不会打进ab包。同样我在gameobject_1中用了一个脚本引用了GUISkin也是没有打进ab包的</p><h3 id="Resources-unity-builtin-extra"><a href="#Resources-unity-builtin-extra" class="headerlink" title="Resources&#x2F;unity_builtin_extra"></a>Resources&#x2F;unity_builtin_extra</h3><p>里面包括资源：Shader，Material，Texture(都是UGUI的图,看文章开头图)以及Sprite(UGUI的精灵图),内置资源在发布时是会按需裁剪的,影响他的大小因素(现在所知),来自Project Setting-&gt;Graphics-&gt;Always included shaders的size大小</p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202401020048876.png?token=AJD3J3OEZUB226P4IRA6NZ3FSLWQ2" alt="image-20240102004814241"></p><p>通过解包来看里面的资源(手机版没发现),里面都是shader</p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202401020112830.png?token=AJD3J3LZME7AES4BNSJZE5LFSLZLY" alt="image-20240102011228983"></p><h5 id="打包AssetBundle-1"><a href="#打包AssetBundle-1" class="headerlink" title="打包AssetBundle"></a>打包AssetBundle</h5><p>这里面的资源不会剥离,而是会随着ab包打进,如果有两个uiprefab的ab包，都引用了其中的Sprite资源(例如Background)，那么他会打进两个ab中，<code>会造成冗余,需要注意</code></p><h3 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/386625317">Unity实践—Unity 内置资源独立打包 - 知乎 (zhihu.com)</a></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/669070779">Unity冗余资源全面优化 - 知乎 (zhihu.com)</a></p><p><a target="_blank" rel="noopener" href="https://blog.uwa4d.com/archives/1577.html">Unity 5.x AssetBundle零冗余解决方案 - UWA问答 | 博客 | 游戏及VR应用性能优化记录分享 | 侑虎科技 (uwa4d.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Camera-Main问题&quot;&gt;&lt;a href=&quot;#Camera-Main问题&quot; class=&quot;headerlink&quot; title=&quot;Camera.Main问题&quot;&gt;&lt;/a&gt;Camera.Main问题&lt;/h2&gt;&lt;p&gt;​	&lt;code&gt;camera.main是个静态属性，</summary>
      
    
    
    
    <category term="Unity" scheme="https://zeroultra.github.io/categories/Unity/"/>
    
    <category term="小记" scheme="https://zeroultra.github.io/categories/Unity/%E5%B0%8F%E8%AE%B0/"/>
    
    
    <category term="Unity" scheme="https://zeroultra.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>常见设备分辨率</title>
    <link href="https://zeroultra.github.io/2023/03-02-%E5%B8%B8%E8%A7%81%E8%AE%BE%E5%A4%87%E5%88%86%E8%BE%A8%E7%8E%87/"/>
    <id>https://zeroultra.github.io/2023/03-02-%E5%B8%B8%E8%A7%81%E8%AE%BE%E5%A4%87%E5%88%86%E8%BE%A8%E7%8E%87/</id>
    <published>2023-03-02T06:26:32.000Z</published>
    <updated>2023-03-02T06:26:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见分辨率"><a href="#常见分辨率" class="headerlink" title="常见分辨率"></a>常见分辨率</h1><h2 id="IOS"><a href="#IOS" class="headerlink" title="IOS"></a>IOS</h2><table><thead><tr><th>分辨率</th><th>比例</th><th>设备</th></tr></thead><tbody><tr><td>960 x 640</td><td>3:2</td><td>iPhone 4S</td></tr><tr><td>1136 x 640</td><td>16:9</td><td>iPhone 5, iPhone 5C, iPhone 5S</td></tr><tr><td>1334 x 750</td><td>16:9</td><td>iPhone 6, iPhone 6S, iPhone 7, iPhone 8</td></tr><tr><td>1920 x 1080</td><td>16:9</td><td>iPhone 6 Plus, iPhone 6S Plus, iPhone 7 Plus, iPhone 8 Plus</td></tr><tr><td>2208 x 1242</td><td>16:9</td><td>iPhone X, iPhone XS, iPhone 11 Pro</td></tr><tr><td>2436 x 1125</td><td>19.5:9</td><td>iPhone XR, iPhone 11</td></tr><tr><td>2688 x 1242</td><td>19.5:9</td><td>iPhone XS Max, iPhone 11 Pro Max</td></tr><tr><td>2532 x 1170</td><td>19.5:9</td><td>iPhone 12, iPhone 12 Pro</td></tr><tr><td>2778 x 1284</td><td>19.5:9</td><td>iPhone 12 Pro Max</td></tr><tr><td>2340 x 1080</td><td>19.5:9</td><td>iPhone 12 mini</td></tr><tr><td>2532 x 1170</td><td>19.5:9</td><td>iPhone 13 mini</td></tr><tr><td>2532 x 1170</td><td>19.5:9</td><td>iPhone 13, iPhone 13 Pro</td></tr><tr><td>2778 x 1284</td><td>19.5:9</td><td>iPhone 13 Pro Max</td></tr></tbody></table><table><thead><tr><th>iPad型号</th><th>分辨率</th><th>宽高比</th></tr></thead><tbody><tr><td>iPad (第1代)</td><td>1024 x 768</td><td>4:3</td></tr><tr><td>iPad 2</td><td>1024 x 768</td><td>4:3</td></tr><tr><td>iPad (第3代)</td><td>2048 x 1536</td><td>4:3</td></tr><tr><td>iPad (第4代)</td><td>2048 x 1536</td><td>4:3</td></tr><tr><td>iPad Air</td><td>2048 x 1536</td><td>4:3</td></tr><tr><td>iPad Air 2</td><td>2048 x 1536</td><td>4:3</td></tr><tr><td>iPad (第5代)</td><td>2048 x 1536</td><td>4:3</td></tr><tr><td>iPad (第6代)</td><td>2048 x 1536</td><td>4:3</td></tr><tr><td>iPad Air (第3代)</td><td>2224 x 1668</td><td>4:3</td></tr><tr><td>iPad (第7代)</td><td>2160 x 1620</td><td>4:3</td></tr><tr><td>iPad (第8代)</td><td>2160 x 1620</td><td>4:3</td></tr><tr><td>iPad Air (第4代)</td><td>2360 x 1640</td><td>4:3</td></tr><tr><td>iPad Mini</td><td>1024 x 768</td><td>4:3</td></tr><tr><td>iPad Mini 2</td><td>2048 x 1536</td><td>4:3</td></tr><tr><td>iPad Mini 3</td><td>2048 x 1536</td><td>4:3</td></tr><tr><td>iPad Mini 4</td><td>2048 x 1536</td><td>4:3</td></tr><tr><td>iPad Mini (第5代)</td><td>2048 x 1536</td><td>4:3</td></tr><tr><td>iPad Pro (12.9英寸，第1代)</td><td>2732 x 2048</td><td>4:3</td></tr><tr><td>iPad Pro (9.7英寸)</td><td>2048 x 1536</td><td>4:3</td></tr><tr><td>iPad Pro (12.9英寸，第2代)</td><td>2732 x 2048</td><td>4:3</td></tr><tr><td>iPad Pro (10.5英寸)</td><td>2224 x 1668</td><td>4:3</td></tr><tr><td>iPad Pro (11英寸)</td><td>2388 x 1668</td><td>4:3</td></tr><tr><td>iPad Pro (12.9英寸，第3代)</td><td>2732 x 2048</td><td>4:3</td></tr><tr><td>iPad Pro (11英寸，第2代)</td><td>2388 x 1668</td><td>4:3</td></tr><tr><td>iPad Pro (12.9英寸，第4代)</td><td>2732 x 2048</td><td>4:3</td></tr><tr><td>iPad Pro (11英寸，第3代)</td><td>2388 x 1668</td><td>4:3</td></tr><tr><td>iPad Pro (12.9英寸，第5代)</td><td>2732 x 2048</td><td>4:3</td></tr><tr><td>iPad Pro (11英寸，第4代)</td><td>2388 x 1668</td><td>4:3</td></tr></tbody></table><h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><table><thead><tr><th>分辨率</th><th>比例</th></tr></thead><tbody><tr><td>720 x 1280</td><td>9:16</td></tr><tr><td>1080 x 1920</td><td>9:16</td></tr><tr><td>1440 x 2560</td><td>9:16</td></tr><tr><td>1440 x 3040</td><td>19:9</td></tr><tr><td>1080 x 2220</td><td>18.5:9</td></tr><tr><td>1080 x 2280</td><td>19:9</td></tr><tr><td>1080 x 2340</td><td>19.5:9</td></tr><tr><td>1440 x 3120</td><td>19.5:9</td></tr><tr><td>1440 x 3200</td><td>20:9</td></tr><tr><td>1440 x 1440</td><td>1:1</td></tr><tr><td>1600 x 2560</td><td>5:8</td></tr><tr><td>1600 x 900</td><td>16:9</td></tr><tr><td>1920 x 1080</td><td>16:9</td></tr><tr><td>2160 x 3840</td><td>9:16</td></tr><tr><td>2400 x 1080</td><td>19:9</td></tr><tr><td>2400 x 1080</td><td>20:9</td></tr><tr><td>2400 x 1176</td><td>20.5:9</td></tr><tr><td>2560 x 1440</td><td>16:9</td></tr><tr><td>3040 x 1440</td><td>20:9</td></tr><tr><td>3200 x 1440</td><td>19:9</td></tr><tr><td>3200 x 1800</td><td>16:9</td></tr><tr><td>3840 x 2160</td><td>16:9</td></tr></tbody></table><table><thead><tr><th>安卓平板</th><th>分辨率</th><th>宽高比</th></tr></thead><tbody><tr><td>华为平板M5 8.4英寸</td><td>2560 x 1600</td><td>16:10</td></tr><tr><td>华为平板M5 10.8英寸</td><td>2560 x 1600</td><td>16:10</td></tr><tr><td>华为平板M6 8.4英寸</td><td>2560 x 1600</td><td>16:10</td></tr><tr><td>华为平板M6 10.8英寸</td><td>2560 x 1600</td><td>16:10</td></tr><tr><td>小米平板4 8.0英寸</td><td>1920 x 1200</td><td>16:10</td></tr><tr><td>小米平板4 Plus 10.1英寸</td><td>1920 x 1200</td><td>16:10</td></tr><tr><td>荣耀平板5 8.0英寸</td><td>1920 x 1200</td><td>16:10</td></tr><tr><td>荣耀平板5 10.1英寸</td><td>1920 x 1200</td><td>16:10</td></tr><tr><td>三星平板S6 Lite</td><td>2000 x 1200</td><td>5:3</td></tr><tr><td>三星平板Tab A 8.0</td><td>1280 x 800</td><td>16:10</td></tr><tr><td>三星平板Tab A 10.1</td><td>1920 x 1200</td><td>16:10</td></tr><tr><td>华硕平板ZenPad 3S 10</td><td>2048 x 1536</td><td>4:3</td></tr><tr><td>华硕平板ZenPad S 8.0</td><td>2048 x 1536</td><td>4:3</td></tr></tbody></table><h2 id="PC"><a href="#PC" class="headerlink" title="PC"></a>PC</h2><table><thead><tr><th>分辨率</th><th>比例</th></tr></thead><tbody><tr><td>800 x 600</td><td>4:3</td></tr><tr><td>1024 x 768</td><td>4:3</td></tr><tr><td>1280 x 720</td><td>16:9</td></tr><tr><td>1280 x 800</td><td>16:10</td></tr><tr><td>1280 x 960</td><td>4:3</td></tr><tr><td>1280 x 1024</td><td>5:4</td></tr><tr><td>1360 x 768</td><td>16:9</td></tr><tr><td>1366 x 768</td><td>16:9</td></tr><tr><td>1440 x 900</td><td>16:10</td></tr><tr><td>1600 x 900</td><td>16:9</td></tr><tr><td>1600 x 1200</td><td>4:3</td></tr><tr><td>1680 x 1050</td><td>16:10</td></tr><tr><td>1920 x 1080</td><td>16:9</td></tr><tr><td>1920 x 1200</td><td>16:10</td></tr><tr><td>2560 x 1440</td><td>16:9</td></tr><tr><td>2560 x 1600</td><td>16:10</td></tr><tr><td>3840 x 2160</td><td>16:9</td></tr><tr><td>4096 x 2160</td><td>17:9</td></tr></tbody></table><hr><h1 id="Unity中向Game视图添加分辨率"><a href="#Unity中向Game视图添加分辨率" class="headerlink" title="Unity中向Game视图添加分辨率"></a>Unity中向Game视图添加分辨率</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> GameViewSizeType</span><br><span class="line">  &#123;</span><br><span class="line">      AspectRatio, FixedResolution</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="meta">MenuItem(<span class="string">&quot;Window/Add Resolution&quot;</span>)</span>]</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddGameViewResolution</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">//ipad基本都是4:3</span></span><br><span class="line">      <span class="comment">//android pad 有16:10 4:3 5:3</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//类型 宽 高 名称</span></span><br><span class="line">      List&lt;(GameViewSizeType type, <span class="built_in">int</span> width, <span class="built_in">int</span> heigth, <span class="built_in">string</span> title)&gt; listCustomResolution = <span class="keyword">new</span> List&lt;(GameViewSizeType, <span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">string</span>)&gt;();</span><br><span class="line">             listCustomResolution.Add((GameViewSizeType.FixedResolution, <span class="number">1024</span>, <span class="number">1280</span>, <span class="string">&quot;1024x1280 (5:4==1.25)&quot;</span>));</span><br><span class="line">      listCustomResolution.Add((GameViewSizeType.FixedResolution, <span class="number">1280</span>, <span class="number">1024</span>, <span class="string">&quot;1280x1024&quot;</span>));</span><br><span class="line">      listCustomResolution.Add((GameViewSizeType.FixedResolution, <span class="number">768</span>, <span class="number">1024</span>, <span class="string">&quot;768x1024 (4:3==1.333)&quot;</span>));</span><br><span class="line">      listCustomResolution.Add((GameViewSizeType.FixedResolution, <span class="number">1024</span>, <span class="number">768</span>, <span class="string">&quot;1024x768&quot;</span>));</span><br><span class="line">      listCustomResolution.Add((GameViewSizeType.FixedResolution, <span class="number">1536</span>, <span class="number">2048</span>, <span class="string">&quot;1536x2048 (4:3=1.333)&quot;</span>));</span><br><span class="line">      listCustomResolution.Add((GameViewSizeType.FixedResolution, <span class="number">2048</span>, <span class="number">1536</span>, <span class="string">&quot;2048x1536&quot;</span>));</span><br><span class="line">      listCustomResolution.Add((GameViewSizeType.FixedResolution, <span class="number">1200</span>, <span class="number">2000</span>, <span class="string">&quot;1200x2000 (5:3=1.667)&quot;</span>));</span><br><span class="line">      listCustomResolution.Add((GameViewSizeType.FixedResolution, <span class="number">2000</span>, <span class="number">1200</span>, <span class="string">&quot;2000x1200&quot;</span>));</span><br><span class="line">      listCustomResolution.Add((GameViewSizeType.FixedResolution, <span class="number">1080</span>, <span class="number">2340</span>, <span class="string">&quot;1080x2340 (9.5:9=2.167)&quot;</span>));</span><br><span class="line">      listCustomResolution.Add((GameViewSizeType.FixedResolution, <span class="number">2340</span>, <span class="number">1080</span>, <span class="string">&quot;2340x1080&quot;</span>));</span><br><span class="line">      listCustomResolution.Add((GameViewSizeType.FixedResolution, <span class="number">1600</span>, <span class="number">2560</span>, <span class="string">&quot;1600x2560 (16:10==1.6)&quot;</span>));</span><br><span class="line">      listCustomResolution.Add((GameViewSizeType.FixedResolution, <span class="number">2560</span>, <span class="number">1600</span>, <span class="string">&quot;2560x1600&quot;</span>));</span><br><span class="line">      listCustomResolution.Add((GameViewSizeType.FixedResolution, <span class="number">1080</span>, <span class="number">1920</span>, <span class="string">&quot;1080x1920 (16:9==1.778)&quot;</span>));</span><br><span class="line">      listCustomResolution.Add((GameViewSizeType.FixedResolution, <span class="number">1920</span>, <span class="number">1080</span>, <span class="string">&quot;1920x1080&quot;</span>));</span><br><span class="line">      listCustomResolution.Add((GameViewSizeType.FixedResolution, <span class="number">2160</span>, <span class="number">4096</span>, <span class="string">&quot;2160x4096 (17:9==1.889)&quot;</span>));</span><br><span class="line">      listCustomResolution.Add((GameViewSizeType.FixedResolution, <span class="number">4096</span>, <span class="number">2160</span>, <span class="string">&quot;4096x2160&quot;</span>));</span><br><span class="line">      listCustomResolution.Add((GameViewSizeType.FixedResolution, <span class="number">1080</span>, <span class="number">2400</span>, <span class="string">&quot;1080x2400 (30:13.5=2.222)&quot;</span>));</span><br><span class="line">      listCustomResolution.Add((GameViewSizeType.FixedResolution, <span class="number">2400</span>, <span class="number">1080</span>, <span class="string">&quot;2400x1080&quot;</span>));</span><br><span class="line">      listCustomResolution.Add((GameViewSizeType.FixedResolution, <span class="number">1176</span>, <span class="number">2400</span>, <span class="string">&quot;1176x2400 (20.5:9=2.278)&quot;</span>));</span><br><span class="line">      listCustomResolution.Add((GameViewSizeType.FixedResolution, <span class="number">2400</span>, <span class="number">1176</span>, <span class="string">&quot;2400x1176&quot;</span>));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//反射添加</span></span><br><span class="line">      <span class="keyword">var</span> sizesType = <span class="keyword">typeof</span>(Editor).Assembly.GetType(<span class="string">&quot;UnityEditor.GameViewSizes&quot;</span>);</span><br><span class="line">      <span class="keyword">var</span> singleType = <span class="keyword">typeof</span>(ScriptableSingleton&lt;&gt;).MakeGenericType(sizesType);</span><br><span class="line">      <span class="comment">//找到单例</span></span><br><span class="line">      <span class="keyword">var</span> instance = singleType.GetProperty(<span class="string">&quot;instance&quot;</span>).GetValue(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">var</span> <span class="keyword">group</span> = instance.GetType().GetProperty(<span class="string">&quot;currentGroup&quot;</span>, System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public).GetValue(instance);</span><br><span class="line">      <span class="comment">//找到方法</span></span><br><span class="line">      <span class="keyword">var</span> addCustomSize = <span class="keyword">group</span>.GetType().GetMethod(<span class="string">&quot;AddCustomSize&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//这里不能用for循环 奇怪</span></span><br><span class="line">      <span class="comment">//var removeCustomSize = group.GetType().GetMethod(&quot;RemoveCustomSize&quot;);</span></span><br><span class="line">      <span class="comment">//for (int i = 18; i &lt; 5; i++)</span></span><br><span class="line">      <span class="comment">//&#123;</span></span><br><span class="line">      <span class="comment">//    removeCustomSize.Invoke(group, new object[] &#123; i &#125;);</span></span><br><span class="line">      <span class="comment">//&#125;</span></span><br><span class="line">      <span class="comment">//removeCustomSize.Invoke(group, new object[] &#123; 37 &#125;);</span></span><br><span class="line">      <span class="comment">//removeCustomSize.Invoke(group, new object[] &#123; 38 &#125;);</span></span><br><span class="line">      <span class="comment">//removeCustomSize.Invoke(group, new object[] &#123; 39 &#125;);</span></span><br><span class="line">      <span class="comment">//removeCustomSize.Invoke(group, new object[] &#123; 40 &#125;);</span></span><br><span class="line">      <span class="comment">//removeCustomSize.Invoke(group, new object[] &#123; 41 &#125;);</span></span><br><span class="line">      <span class="comment">//removeCustomSize.Invoke(group, new object[] &#123; 42 &#125;);</span></span><br><span class="line">      <span class="comment">//return;</span></span><br><span class="line"></span><br><span class="line">      Assembly assembly = Assembly.Load(<span class="string">&quot;UnityEditor.dll&quot;</span>);</span><br><span class="line">      Type gameViewSize = assembly.GetType(<span class="string">&quot;UnityEditor.GameViewSize&quot;</span>);</span><br><span class="line">      Type gameViewSizeType = assembly.GetType(<span class="string">&quot;UnityEditor.GameViewSizeType&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> listCustomResolution)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">//创建一个GameViewSize类</span></span><br><span class="line">          ConstructorInfo ctor = gameViewSize.GetConstructor(<span class="keyword">new</span> Type[]</span><br><span class="line">           &#123;</span><br><span class="line">               gameViewSizeType,</span><br><span class="line">               <span class="keyword">typeof</span>(<span class="built_in">int</span>),</span><br><span class="line">               <span class="keyword">typeof</span>(<span class="built_in">int</span>),</span><br><span class="line">               <span class="keyword">typeof</span>(<span class="built_in">string</span>)</span><br><span class="line">           &#125;);</span><br><span class="line">          <span class="comment">//GameViewSizeType.FixedResolution就是1</span></span><br><span class="line">          <span class="keyword">var</span> newSize = ctor.Invoke(<span class="keyword">new</span> <span class="built_in">object</span>[] &#123; (<span class="built_in">int</span>)item.type, item.width, item.heigth, item.title &#125;);</span><br><span class="line">          <span class="comment">//调用方法添加</span></span><br><span class="line">          addCustomSize.Invoke(<span class="keyword">group</span>, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; newSize &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//保存</span></span><br><span class="line">      <span class="keyword">var</span> saveMethod = instance.GetType().GetMethod(<span class="string">&quot;SaveToHDD&quot;</span>);</span><br><span class="line">      saveMethod.Invoke(instance, <span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常见分辨率&quot;&gt;&lt;a href=&quot;#常见分辨率&quot; class=&quot;headerlink&quot; title=&quot;常见分辨率&quot;&gt;&lt;/a&gt;常见分辨率&lt;/h1&gt;&lt;h2 id=&quot;IOS&quot;&gt;&lt;a href=&quot;#IOS&quot; class=&quot;headerlink&quot; title=&quot;IOS&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="其他" scheme="https://zeroultra.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="硬件" scheme="https://zeroultra.github.io/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java基础</title>
    <link href="https://zeroultra.github.io/2022/12-24-Java%E5%9F%BA%E7%A1%80/"/>
    <id>https://zeroultra.github.io/2022/12-24-Java%E5%9F%BA%E7%A1%80/</id>
    <published>2022-12-24T06:56:21.000Z</published>
    <updated>2022-12-24T06:56:21.000Z</updated>
    
    
    <summary type="html">描述</summary>
    
    
    
    <category term="Java" scheme="https://zeroultra.github.io/categories/Java/"/>
    
    
    <category term="Android" scheme="https://zeroultra.github.io/tags/Android/"/>
    
    <category term="Java" scheme="https://zeroultra.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C基础</title>
    <link href="https://zeroultra.github.io/2022/09-24-Objective-C%E5%9F%BA%E7%A1%80/"/>
    <id>https://zeroultra.github.io/2022/09-24-Objective-C%E5%9F%BA%E7%A1%80/</id>
    <published>2022-09-24T06:33:36.000Z</published>
    <updated>2022-09-24T06:33:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>来源于视频<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1NJ411T78u">https://www.bilibili.com/video/BV1NJ411T78u</a></p><h2 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h2><ol><li><p><strong>OC是扩充C的面向对象编程语言,本质上还是C语言</strong></p><p>所以OC中是可以写C语言的,也是完全可以兼容C语言的(也就是可以在OC中写C语言)</p></li></ol><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209241442310.png" alt="image-20220924144253965"></p><ol start="2"><li><p>OC文件名后缀是<code>.m</code>,     m代表message 代表<code>OC中的消息机制</code>,OC大多以<code>NS开头</code>,是因为NextStep开发.</p></li><li><p>#Import指令</p><ul><li>是c语言 #include的增强版 无论inport多少次 只会包含一次</li><li>作用是导入库</li></ul></li><li><p>Foundation框架</p><p>基础 基本,提供了一些基础功能 一些数据类型</p></li><li><p><code>@autoreleasetpool</code> 自动释放池 相当于c# using</p></li><li><p>一些占位符(c语言)</p><table><thead><tr><th>占位符</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>%d</td><td>int</td><td></td></tr><tr><td>%f</td><td>float 浮点类型</td><td><code>NSLog(@&quot;num=%f&quot;,100f)</code></td></tr><tr><td>%lf</td><td>double类型</td><td></td></tr><tr><td>%hd</td><td>short int</td><td></td></tr><tr><td>%ld</td><td>long</td><td></td></tr><tr><td>%lld</td><td>long long</td><td></td></tr><tr><td>%u</td><td>unsigned</td><td></td></tr><tr><td>%c</td><td>char类型</td><td></td></tr><tr><td>%s</td><td>c中 字符串</td><td><code>printf(&quot;hell%s&quot;,&quot;o&quot;)</code></td></tr><tr><td>%@</td><td>OC中字符串</td><td><code>NSLog(@&quot;hello %@&quot;,@&quot;world&quot;)</code></td></tr><tr><td>%p</td><td>指针</td><td></td></tr></tbody></table></li><li><p>字符串</p><p><strong>C中</strong></p><pre><code>* char str[10]=&quot;abc&quot;  后面会用 `\0` 补齐* char *str=&quot;abc&quot;* char str[]=&#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;&#125;</code></pre><p><strong>OC中</strong></p><ul><li>OC字符串<strong>必须加一个<code>@</code>符号</strong>  @”hello”  NSString *str&#x3D;@”abc”</li><li>使用<code>NSString</code>类型 存储的是一个指针变量,存贮的是字符的指针</li></ul></li><li><p>@符号</p><ol><li>将C字符串转换为OC字符串</li><li>OC中绝大部分关键字都是@开头</li></ol></li><li><p>函数定义与调用</p><ol><li>先定义然后再调用</li></ol></li><li><p>数据类型(加粗是OC特有)</p><table><thead><tr><th>关键字</th><th>占用空间</th><th>范围</th></tr></thead><tbody><tr><td>char</td><td>1 字节</td><td>-128 到 127 或 0 到 255</td></tr><tr><td>unsigned char</td><td>1 字节</td><td>0 到 255</td></tr><tr><td>signed char</td><td>1 字节</td><td>-128 到 127</td></tr><tr><td>int</td><td>2 或 4 字节</td><td>-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647</td></tr><tr><td>unsigned int</td><td>2 或 4 字节</td><td>0 到 65,535 或 0 到 4,294,967,295</td></tr><tr><td>short</td><td>2 字节</td><td>-32,768 到 32,767</td></tr><tr><td>unsigned short</td><td>2 字节</td><td>0 到 65,535</td></tr><tr><td>long</td><td>4 字节</td><td>-2,147,483,648 到 2,147,483,647</td></tr><tr><td>unsigned long</td><td>4 字节</td><td>0 到 4,294,967,295</td></tr><tr><td><strong>BOOL类型</strong></td><td><strong>1字节</strong></td><td><strong>BOOL&#x3D;YES &#x2F;NO (都是大写)</strong> 实际是 typedef signed char BOOL</td></tr><tr><td><strong>Boolean</strong></td><td><strong>1字节</strong></td><td><strong>Boolean&#x3D;true&#x2F;false 实际是 typedef unsigned char</strong></td></tr><tr><td><strong>id类型</strong></td><td></td><td></td></tr><tr><td><strong>nil</strong></td><td></td><td><strong>&#x3D;&#x3D;NULL</strong> oc用nil c用null</td></tr><tr><td><strong>SEL</strong></td><td></td><td><strong>方法选择器</strong></td></tr></tbody></table></li><li><p>类</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">//声明类</span><br><span class="line">@interface ClassName:NSObject  </span><br><span class="line">&#123;</span><br><span class="line">NSString *_name; //默认外部不可以反问</span><br><span class="line">    </span><br><span class="line">@publicint _age; //可以外部访问</span><br><span class="line">&#125;</span><br><span class="line">//方法声明和实现必须一个整体 不然调用会报错</span><br><span class="line">- (void) Run; //方法声明 无返回值</span><br><span class="line">- (void) Eat:(NSString *) foodName; //带参数方法 无返回值</span><br><span class="line">- (int) Sum:(int) num1:(int) num2; //带参数 有返回值</span><br><span class="line">-(void) CallOther; //调用其他方法</span><br><span class="line">@end</span><br><span class="line">    </span><br><span class="line">//实现类</span><br><span class="line">@implementation ClassName</span><br><span class="line">    - (void) Run //方法实现</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%@跑&quot;,_name); //谁跑 直接访问字段</span><br><span class="line">&#125;</span><br><span class="line">- (void) Eat:(NSString *) foodName</span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@&quot;正在吃%@&quot;,foodName);</span><br><span class="line">    &#125;</span><br><span class="line">- (int) Sum:(int) num1:(int) num2</span><br><span class="line">    &#123;</span><br><span class="line">        int sum=num1+num2;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">    - (void) CallOther</span><br><span class="line">    &#123;</span><br><span class="line">        [self Run];//调用本类中其他方法</span><br><span class="line">    &#125;</span><br><span class="line">@end</span><br><span class="line">    </span><br><span class="line">int main(int v,const char * args[])</span><br><span class="line">&#123;</span><br><span class="line">    //实例化</span><br><span class="line">ClassName *cn=[ClassName new];</span><br><span class="line">    //设置字段</span><br><span class="line">    cn-&gt;_age=10;//或者 (*cn)._age=10;</span><br><span class="line">    //调用方法</span><br><span class="line">    [cn Run];</span><br><span class="line">    [cn Eat:@&quot;西湖醋鱼&quot;];</span><br><span class="line">    int sum= [cn Sum:10:20];</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;来源于视频&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://www.bilibili.com/video/BV1NJ411T78u&quot;&gt;https://www.bilibili.com/video/BV1NJ411T78u&lt;/a&gt;</summary>
      
    
    
    
    <category term="Objective-C" scheme="https://zeroultra.github.io/categories/Objective-C/"/>
    
    
    <category term="Objective-C" scheme="https://zeroultra.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>热更新系列(二)——HybridCLR(huatuo)</title>
    <link href="https://zeroultra.github.io/2022/09-22-%E7%83%AD%E6%9B%B4%E6%96%B002/"/>
    <id>https://zeroultra.github.io/2022/09-22-%E7%83%AD%E6%9B%B4%E6%96%B002/</id>
    <published>2022-09-22T11:20:47.000Z</published>
    <updated>2022-09-22T11:20:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于HybridCLR"><a href="#关于HybridCLR" class="headerlink" title="关于HybridCLR"></a>关于HybridCLR</h2><p>[官网](<a target="_blank" rel="noopener" href="https://hybridclr.doc.code-philosophy.com/">HybridCLR | HybridCLR (code-philosophy.com)</a>)</p><p>HybridCLR改进了unity的Il2cpp部分,使得其能”解释”执行一些代码,每个unity都可以在安装文件下找到<code>\Data\il2cpp\libil2cpp</code>, HybridCLR就是改进了这一部分.</p><p>具体查看:<a target="_blank" rel="noopener" href="https://hybridclr.doc.code-philosophy.com/docs/basic/install#hybridclrinstaller%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">安装HybridCLR | HybridCLR (code-philosophy.com)</a></p><blockquote><p>原始il2cpp是AOT运行时，不支持动态注册dll元数据。我们轻微改造了metadata管理模块，插入了一些hook代码，支持动态加载dll元数据</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="依赖模块"><a href="#依赖模块" class="headerlink" title="依赖模块"></a>依赖模块</h3><p><a target="_blank" rel="noopener" href="https://hybridclr.doc.code-philosophy.com/docs/basic/install">安装HybridCLR </a></p><ul><li>Unity Hub 安装相应的IL2cpp模块</li><li>Windows<ul><li>Win下需要安装<code>visual studio 2019</code>或更高版本。安装时至少要包含 <code>使用Unity的游戏开发</code> 和 <code>使用c++的游戏开发</code> 组件。</li><li>安装git</li></ul></li><li>Mac<ul><li>要求MacOS版本 &gt;&#x3D; 12，xcode版本 &gt;&#x3D; 13，例如<code>xcode 13.4.1， macos 12.4</code>。</li><li>安装 git</li><li>安装cmake</li></ul></li></ul><h3 id="目录说明"><a href="#目录说明" class="headerlink" title="目录说明"></a>目录说明</h3><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202307171107442.png" alt="image-20230717110653078"></p><ul><li><p>AssembliesPostIl2CppStrip</p><p><strong>打包过程生成的裁剪后的AOT dll</strong>. 用于补充元数据,分为不同平台,不同平台不可混用,至于为什么是剪裁后的AOTdll,这是为了减小生成的dll大小也是为了减小内存(下同)</p></li><li><p>HotUpdateDlls</p><p>生成的热更程序集</p></li><li><p>hybridclr_repo</p><p>Hybridclr仓库代码.扩充了il2cpp的代码，使它由纯<a href="https://gitee.com/link?target=https://en.wikipedia.org/wiki/Ahead-of-time_compilation">AOT</a> runtime变成‘AOT+Interpreter’ 混合runtime，进而原生支持动态加载assembly，使得基于il2cpp backend打包的游戏不仅能在Android平台，也能在IOS、Consoles等限制了JIT的平台上高效地以<strong>AOT+interpreter</strong>混合模式执行，从底层彻底支持了热更新。为解释器部分的核心代码，包含元数据加载、代码transform(编译)、代码解释执行</p></li><li><p>il2cpp_plus_repo</p><p>il2cpp_plus仓库代码,原始的<code>libil2cpp</code>是AOT运行,Hybirdclr改造了metadata管理模块,插入一些hook代码,支持动态加载dll元数据</p></li><li><p>LocalIl2CppData-WindowsEditor</p><p>这里是把Unity自带的<code>MonoBleedingEdge(2019以上)+Il2cpp+改造后的libil2cpp</code></p><p><img src="https://hybridclr.doc.code-philosophy.com/assets/images/merge_hybridclr_dir-04680fdb60dccd43bfd2593b4affd10e.jpg" alt="merge_hybridclr_dir"></p><p>​注:每个平台Editor自带il2cpp不同(windows.linux,macos…),所有要区分</p><p>​<a target="_blank" rel="noopener" href="https://hybridclr.doc.code-philosophy.com/docs/basic/install#hybridclrinstaller%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">hybridclrinstaller工作原理</a></p></li><li><p>StrippedAOTDllsTempProj</p><p>生成剪裁后的AOTdll临时工程(意思就是要生成剪裁后的AOTdll得有个工程)</p></li></ul><h3 id="Unity-HybridSetting"><a href="#Unity-HybridSetting" class="headerlink" title="Unity HybridSetting"></a>Unity HybridSetting</h3><p><a target="_blank" rel="noopener" href="https://hybridclr.doc.code-philosophy.com/docs/basic/com.code-philosophy.hybridclr#hybridclr%E8%8F%9C%E5%8D%95%E4%BB%8B%E7%BB%8D">hybridclr菜单介绍</a></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202307171156412.png" alt="image-20230717115637369"></p><h3 id="关于AOTGenericReferences"><a href="#关于AOTGenericReferences" class="headerlink" title="关于AOTGenericReferences"></a>关于AOTGenericReferences</h3><p>​<code>HybridCLR/generate/AOTGenericReference</code> 命令生成的<code>AOTGenericReferences.cs</code>文件中包含了应该补充元数据的assembly列表.分为三部分</p><ul><li>1是需要补充的元数据assembly</li><li>2是<strong>AOT中用到的</strong>泛型类</li><li>3是<strong>AOT中用到的</strong>泛型方法</li></ul><h2 id="遇到的一些问题和注意事项"><a href="#遇到的一些问题和注意事项" class="headerlink" title="遇到的一些问题和注意事项"></a>遇到的一些问题和注意事项</h2><h4 id="IL2CPP泛型共享代码"><a href="#IL2CPP泛型共享代码" class="headerlink" title="IL2CPP泛型共享代码"></a>IL2CPP泛型共享代码</h4><blockquote><p>il2cpp为了避免泛型代码膨胀，节约内存，在保证代码逻辑正确性的情况下对于一些能够共享代码，只生成一份代码。为此引入一个概念叫<strong>泛型代码共享</strong> <a target="_blank" rel="noopener" href="https://blog.unity.com/technology/il2cpp-internals-generic-sharing-implementation">Generic Sharing</a>。 简单来说，你只要<strong>在AOT中实例化过某个泛型类或泛型函数的共享实例</strong>，你就可以在热更新代码中使用它了。</p><p>以List<T> 举例：</p><ul><li>可以使用AOT中使用过的任何List的实例化类型。例如你在AOT里用过List<vector3>,则热更新里也可以用</li><li>可以使用任意List<HotUpdateEnum>。 只需要你在AOT里实例化某一个List&lt;相同underlying type的枚举类型&gt;。</li><li>可以使用任意引用类型的泛型参数List<HotUpdateClass>。 只需要你在AOT里实例化过 List<object>(或任意一个引用泛型参数如List<string>)</li></ul></blockquote><p>注意最后一条,只要实例化一个了任意引用类型,那么在热更中可以不用补充元数据</p><p><a target="_blank" rel="noopener" href="https://hybridclr.doc.code-philosophy.com/docs/basic/aotgeneric#%E5%9F%BA%E4%BA%8E%E8%A1%A5%E5%85%85%E5%85%83%E6%95%B0%E6%8D%AE%E7%9A%84%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%8A%80%E6%9C%AFhybridclr%E7%9A%84%E4%B8%93%E5%88%A9%E6%8A%80%E6%9C%AF">基于补充元数据的泛型函数实例化技术hybridclr的专利技术</a></p><h4 id="热更入口函数的坑"><a href="#热更入口函数的坑" class="headerlink" title="热更入口函数的坑"></a>热更入口函数的坑</h4><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202307191755070.png" alt="image-20230719175528223"></p><p>如上图所示,如果直接在入口函数调用了泛型操作,那么会报错,报错原因就是没找到元数据</p><p>那么为什么会出现这个问题呢,因为已经补充元数据了</p><p>这是因为hybridclr是以<code>methodbody</code>解释执行的,也就是整ge解释属于这个方法里面内容,例如<code>start方法</code>里面如果包含了泛型,先整个解释这个start方法,发现没有补充元数据所以就报错了,直接log函数都不打印</p><p><code>解决办法</code>就是用个方法包裹一层,先补充元数据,后面就没啥问题了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;关于HybridCLR&quot;&gt;&lt;a href=&quot;#关于HybridCLR&quot; class=&quot;headerlink&quot; title=&quot;关于HybridCLR&quot;&gt;&lt;/a&gt;关于HybridCLR&lt;/h2&gt;&lt;p&gt;[官网](&lt;a target=&quot;_blank&quot; rel=&quot;noope</summary>
      
    
    
    
    <category term="Unity" scheme="https://zeroultra.github.io/categories/Unity/"/>
    
    <category term="热更新" scheme="https://zeroultra.github.io/categories/Unity/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    
    <category term="Unity" scheme="https://zeroultra.github.io/tags/Unity/"/>
    
    <category term="热更新" scheme="https://zeroultra.github.io/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>热更新系列(一)——.Net工作机制</title>
    <link href="https://zeroultra.github.io/2022/09-22-%E7%83%AD%E6%9B%B4%E6%96%B001/"/>
    <id>https://zeroultra.github.io/2022/09-22-%E7%83%AD%E6%9B%B4%E6%96%B001/</id>
    <published>2022-09-22T06:34:48.000Z</published>
    <updated>2022-09-22T06:34:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Net-概念"><a href="#Net-概念" class="headerlink" title="Net 概念"></a>Net 概念</h2><h3 id="什么是-NET-NET-framework-NET-core-NET-Standard"><a href="#什么是-NET-NET-framework-NET-core-NET-Standard" class="headerlink" title="什么是.NET .NET framework .NET core .NET Standard"></a>什么是.NET .NET framework .NET core .NET Standard</h3><ol><li><p><code>.NET framework</code>是针对<code>windows</code>平台下的应用.现在的版本是.NET Framework 4.8，很有可能这是.NET Framework的最后一个版本了。在未来并没有计划有新的.NET Framework版本</p></li><li><p><code>.NET Core</code>是开源跨平台开发,NET Core 3.0支持了WPF和Windows Forms。.NET Core 3.0 还支持UWP，WPF和Windows Forms三者的开发。</p></li><li><p><code>.Net Standard</code> 是一个规范，它定义了Net Framewoek和Net Core必须实现的Api,它的出现为各种平台上开发的.Net人员解决了代码共享问题，但是仅用于开发类库，意思就是说如果你的类库是Net Standard规范的，那么此类库既可以是Net Framewoek也可以是Net Core类库.</p></li><li><p><code>.NET</code>是.NET Framework和.NET Core核心的结合，旨在统一.NET平台，微软将其描述为“.NET的未来”</p></li></ol><h3 id="Net工作过程原理"><a href="#Net工作过程原理" class="headerlink" title="Net工作过程原理"></a>Net工作过程原理</h3><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209221457728.png" alt="image-20220922145709673"></p><h4 id="CLI-Common-Language-Infrastructure-公共语言基础"><a href="#CLI-Common-Language-Infrastructure-公共语言基础" class="headerlink" title="CLI(Common Language Infrastructure) 公共语言基础"></a>CLI(Common Language Infrastructure) 公共语言基础</h4><p><strong>是为了实现.Net跨语言而定下的基础,<strong>任何语言只要实现这一套标准就可以运行在.Net之上.比如</strong>Mono</strong></p><p>CLI已经成为了国际计算机标准规范,<a target="_blank" rel="noopener" href="https://www.ecma-international.org/publications-and-standards/standards/ecma-335/">ECMA-335 - Ecma International (ecma-international.org)</a></p><p>CLI包括CLS和CTS:</p><h5 id="CTS-Common-Type-System-公共类型系统"><a href="#CTS-Common-Type-System-公共类型系统" class="headerlink" title="CTS(Common Type System) 公共类型系统"></a>CTS(Common Type System) 公共类型系统</h5><p>解决不同语言数据类型不同的问题，如C#中的整形是int,而VB.net中的整形是Integer，通过CTS我们把它们两个编译成通用的类型Int32。</p><p>   所有的.NET语言共享这一类型系统，在它们之间实现对接，简单说：就是把各种语言中的不同数据类型，转换成统一的通用的数据类型。</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209221436628.png" alt="image-20220922143648598"></p><h5 id="CLS-Common-Language-Specification-公共语言规范"><a href="#CLS-Common-Language-Specification-公共语言规范" class="headerlink" title="CLS(Common Language Specification) 公共语言规范"></a>CLS(Common Language Specification) 公共语言规范</h5><p>​    是一种最低的语言标准，定义了实现.Net语言的规则 属性 行为</p><p>​    凡是遵守这个标准的语言在.NET框架下都可以实现互相调用。简单说：就是把各种语言转换成统一的语法规范</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209221433607.png" alt="image-20220922143346569"></p><h4 id="CLR-Common-Language-Runtime-公共语言运行时"><a href="#CLR-Common-Language-Runtime-公共语言运行时" class="headerlink" title="CLR(Common Language Runtime) 公共语言运行时"></a>CLR(Common Language Runtime) 公共语言运行时</h4><p>可以理解为.Net虚拟机 Mono跨平台就是扩展了原来的CLR,现在.Net能跨平台也是增加了对其他平台的执行.</p><p>提供了必要的运行时服务,比如自动化内存管理,异常处理,垃圾回收等等,是.NET运行的核心</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209221448384.png" alt="image-20220922144808340"></p><h4 id="CIL-Common-Intermediate-Language-公共中间语言"><a href="#CIL-Common-Intermediate-Language-公共中间语言" class="headerlink" title="CIL(Common Intermediate Language) 公共中间语言"></a>CIL(Common Intermediate Language) 公共中间语言</h4><p>也称为<code>IL</code> <code>MSIL</code>,基于堆栈，又支持面向对象,运行在虚拟机之上</p><p>CLR就是来解释执行CIL的</p><p>CLR的编译过程：</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209221109092.png" alt="202202151744878"></p><h4 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/szlblog/p/11803623.html">Net Framework,Net Core 和 Net Standard 区别 - 乐途 - 博客园 (cnblogs.com)</a></p><p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/standard/net-standard">.NET Standard | Microsoft Docs</a></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/kebi007/article/details/109616747">NET 5.0 正式版发布了！_dotNet全栈开发-CSDN博客</a></p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xmyjcs/p/10381655.html">C# .NET .NET Framework .NET CORE 等的关系简介 - 陈松（Andy） - 博客园 (cnblogs.com)</a></p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/1996V/p/9037603.html">通俗易懂，什么是.NET?什么是.NET Framework？什么是.NET Core? - 小曾看世界 - 博客园 (cnblogs.com)</a></p><h2 id="Mono和IL2CPP"><a href="#Mono和IL2CPP" class="headerlink" title="Mono和IL2CPP"></a>Mono和IL2CPP</h2><h3 id="Mono"><a href="#Mono" class="headerlink" title="Mono"></a>Mono</h3><p>当年Net的CLR只是针对于Window平台,使得与使用Net的不能实现跨平台,Mono扩展了.Net的CLR,在很多平台实现了一遍,所以可以使用Mono就可以跨平台了</p><p>这也是当时Unity为什么选中Mono的原因</p><p>特征</p><ol><li>实现Mono vm比较麻烦 有多少个平台 就要在对应平台上实现一次 有时还不能完全能实现</li><li>Mono明显的版本跟不上C#版本,这也是Unity 之前的问题 一直是Net2.0,现在能用.Net standard2.1,但是微软已经是.Net6了(原因就是实现困难)</li><li>Mono使用Jit编译 所以构建很快</li><li>APP Store发布规定：全新App必须在15年2月1日支持64位CPU,Unity引擎4.6.2之前的版本采用Mono的AOT机制提前将C#代码编译为机器识别的二进制代码，Unity官方为了支持IOS平台下64位的APP游戏，4.6.2之后的版本采用IL2CPP机制编译和处理IOS平台下的游戏,现在大多数都要求64位了,Unity的Mono是无法生成64位应用</li></ol><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209221516463.png" alt="image-20220922151650413"></p><h3 id="IL2CPP"><a href="#IL2CPP" class="headerlink" title="IL2CPP"></a>IL2CPP</h3><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209221520180.png" alt="image-20220922152005123"></p><p>从上图可以看到,IL2CPP将生成的IL有重新编译生成了C++代码,然后由各个平台的C++编译器编译,IL2CPP VM只是实现了垃圾回收,内存管理<br> 特征</p><ol><li>相比Mono, 代码生成有很大的提高</li><li>可以调试生成的C++代码</li><li>程序的运行效率比Mono高，运行速度快</li><li>多平台移植非常方便</li><li>相比Mono构建应用慢</li><li>只支持AOT(Ahead of Time)编译</li></ol><h4 id="题外话"><a href="#题外话" class="headerlink" title="题外话:"></a>题外话:</h4><p>Q:为什么unity的mono不支持64位打包</p><p>A:unity使用的是mono下的一个分支,不是完全的mono   Unity uses a <a target="_blank" rel="noopener" href="https://github.com/Unity-Technologies/mono">fork</a> of the open source <a target="_blank" rel="noopener" href="https://www.mono-project.com/">Mono project</a>   <a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2021.3/Manual/Mono.html">Mono overview - Unity 手册</a></p><p>chatgpt a: </p><blockquote><p>Unity中使用的Mono是一个跨平台的实现了.NET Framework的运行时环境。在Windows平台上，Unity默认使用的是32位版本的Mono，因为它可以在所有版本的Windows上运行。</p><p>虽然有64位版本的Mono，但Unity并没有直接集成这个版本。这是因为Unity使用的Mono版本是定制的，而且在其它平台上，如macOS和Linux，也只支持32位版本的Mono。为了确保跨平台的兼容性，Unity团队决定只支持32位版本的Mono。</p><p>虽然在Windows上使用64位版本的Mono可能会提高性能，但是这样会使得Windows之外的平台上的性能变差，因为那里只有32位版本可用。因此，Unity团队为了平衡跨平台的兼容性和性能，选择了使用32位版本的Mono。</p></blockquote><blockquote><p>Unity和Godot都使用Mono作为它们的脚本运行时环境，但它们实现Mono的方式略有不同。</p><p>在Unity中，Mono是通过Unity自己的Mono实现，即Unity的Mono是一个轻量级的Mono实现。 Unity的Mono实现仅包含Mono的一个子集，包括Mono C#编译器、Mono运行时环境和C#标准库的一个子集。因此，Unity的Mono仅支持使用该子集的C#语言功能。</p><p>另一方面，Godot使用官方的Mono实现，该实现包括完整的Mono运行时环境和C#标准库，因此它支持完整的C#语言功能。此外，Godot的Mono支持C# 8.0和C# 9.0的一些新特性，而Unity的Mono仅支持C# 7.3的特性。</p><p>总之，虽然Unity和Godot都使用Mono作为脚本运行时环境，但它们实现Mono的方式略有不同，因此它们对C#语言的支持也略有不同</p></blockquote><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/352463394">【Unity游戏开发】Mono和IL2CPP的区别 - 知乎 (zhihu.com)</a></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/19972689">Unity将来时：IL2CPP是什么？ - 知乎 (zhihu.com)</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><code>Assembly-CSharp.dll和Assembly-CSharp-firstpass.dll</code></p><p>firstpass表示先编译，Editor表示放在Editor文件夹下的脚本。</p><p>根据官方的解释，它们的编译顺序如下： </p><ol><li><p>Assembly-CSharp-filepass.csproj：所有在Standard Assets、Pro Standard Assets或者Plugins文件夹中的脚本</p></li><li><p>Assembly-CSharp-Editor-filepass.csproj：所有在Standard Assets&#x2F;Editor、Pro Standard Assets&#x2F;Editor或者Plugins&#x2F;Editor文件夹中的脚本产生工程文件</p></li><li><p>Assembly-CSharp.csproj：所有在Assets&#x2F;Editor外面的，并且不在(1),(2)中的脚本文件(一般这些脚本就是我们自己写的非编辑器扩展脚本)会产生工程文件</p></li><li><p>Assembly-CSharp-Editor-vs.csproj：所有在Assets&#x2F;Editor中的脚本产生一个工程文件。</p></li><li><p><strong>JIT(Just in Time) 动态(即时)编译，边运行边编译,把代码编译成IL 运行时候逐条翻译成原生码CPU执行</strong></p></li><li><p><strong>AOT(Ahead Of Time)运行前编译, 编译成IL之后,然后翻译成原生代码</strong></p></li></ol><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209221110375.png" alt="202202151744735"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209221110463.png" alt="202202151744285"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209221110583.png" alt="202202151744709"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209221855906.png" alt="202202151744276"></p><h3 id="ILRuntime"><a href="#ILRuntime" class="headerlink" title="ILRuntime"></a>ILRuntime</h3><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209221111535.png" alt="ilruntime111"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209221112241.png" alt="202202151744255"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Net-概念&quot;&gt;&lt;a href=&quot;#Net-概念&quot; class=&quot;headerlink&quot; title=&quot;Net 概念&quot;&gt;&lt;/a&gt;Net 概念&lt;/h2&gt;&lt;h3 id=&quot;什么是-NET-NET-framework-NET-core-NET-Standard&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="Unity" scheme="https://zeroultra.github.io/categories/Unity/"/>
    
    <category term="热更新" scheme="https://zeroultra.github.io/categories/Unity/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    
    <category term="Unity" scheme="https://zeroultra.github.io/tags/Unity/"/>
    
    <category term="热更新" scheme="https://zeroultra.github.io/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>Unity &amp; IOS</title>
    <link href="https://zeroultra.github.io/2022/09-14-Unity2IOS/"/>
    <id>https://zeroultra.github.io/2022/09-14-Unity2IOS/</id>
    <published>2022-09-14T02:36:42.000Z</published>
    <updated>2022-09-14T02:36:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h3><p>苹果电脑安装Xcode,苹果手机或者ipad</p><h3 id="Unity"><a href="#Unity" class="headerlink" title="Unity"></a>Unity</h3><p>安装IOS模块</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>证书:development证书或者distribute证书和对应描述文件(.mobileprovision)</p><h2 id="打包苹果流程"><a href="#打包苹果流程" class="headerlink" title="打包苹果流程"></a>打包苹果流程</h2><h3 id="注意-不要有中文路径"><a href="#注意-不要有中文路径" class="headerlink" title="注意:不要有中文路径!!!"></a>注意:不要有中文路径!!!</h3><p>我使用的是windows电脑发布工程,然后使用Mac电脑发布,为了方便,我在window磁盘添加了一个共享文件夹,使用Mac访问共享文件夹,Xcode直接打开工程,这样就不用传来传去了. 当然也可以直接使用MacUnity发布</p><ul><li>Win中Unity中发布到共享文件夹</li><li>Mac中XCode直接打开共享文件夹中工程</li></ul><h3 id="Unity中发布工程"><a href="#Unity中发布工程" class="headerlink" title="Unity中发布工程"></a>Unity中发布工程</h3><p>设置Icon,最好用一个1024*1024的图,直接设置为<code>DefaultIcon</code>就行了</p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209171524658.png" alt="image-20220917152425621"></p><p>设置Bundle Identifier,<code>一定要和证书保持一致</code>(也就是和你苹果后台app包名一致)</p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209171527672.png" alt="image-20220917152741643"></p><p>然后直接Build就可以了,打出的是一个Xcode工程,<strong>要求发布的文件夹是一个空文件,所以重复打包同一个文件夹,最好删除原来的或者把里面的文件都删了</strong></p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209171548400.png" alt="image-20220917154844374"></p><h3 id="XCode打包"><a href="#XCode打包" class="headerlink" title="XCode打包"></a>XCode打包</h3><p><code>一定要注意磁盘空间够用,不然有很多问题,确保有10G以上</code></p><p>我使用的windows系统build xcode工程到一个共享文件夹,然后mac通过局域网直接访问windows 里面的工程</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209171546838.png" alt="image-20220917154641798"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209171548281.png" alt="image-20220917154807198"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209171549529.png" alt="image-20220917154926468"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209171552466.png" alt="image-20220917155247395"></p><p>可以使用自动签名登录一下开发者账号,也可以使用证书配置文件</p><p>点击<code>Provisioning Profile</code>,选择对应配置文件就可以</p><p>然后点击<strong>Product</strong>,如果想直接跑在手机上,点击run,如果需要发布ipa或者上传App StoreConnect就点击<code>Archive</code></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209171557015.png" alt="image-20220917155726924"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209171610935.png" alt="image-20220917161010874"></p><ul><li><p>App Store Connetct ：导出的ipa 包可以发布到App Store或者在越狱的iOS设备。</p></li><li><p>Ad Hoc ：安装测试用的,有udid限制。该ipa包不能提交到AppStore.</p></li><li><p>Enterprise ：导出的ipa 包是用于企业应用账号的，个人账号是无法选择的。而且没有任何udid设备数量限制。</p></li><li><p>Development ：导出的ipa包是dev证书编译的，其实这个和第二Ad Hoc很类似，唯一区别这个用dev证书编译的，而Ad Hoc用的是dis证书编译的。</p></li></ul><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209171610065.png" alt="image-20220917161050016"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209171616563.png" alt="image-20220917161601509"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209171616387.png" alt="image-20220917161647336"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209171617638.png" alt="image-20220917161715583"></p><p>最后导出到目标文件夹就可以了</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209171618989.png" alt="image-20220917161818948"></p><p>然后就可以安装了</p><h4 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h4><ul><li>第一方式是直接手机连接上Mac,XCode-&gt;Wondow-&gt;Diveces and Simulators</li></ul><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209171621873.png" alt="image-20220917162105757"></p><ul><li>第二种通过<code>蒲公英平台</code>上传下载,不会的自行搜索</li></ul><h3 id="修改代码重新打包"><a href="#修改代码重新打包" class="headerlink" title="修改代码重新打包"></a>修改代码重新打包</h3><p>unity重新build如果又重新把项目拷贝到mac,那么之前的设置都没了很麻烦, 大部分我们只要把新生成的copy,然后覆盖<code>Classes</code> <code>Data</code> <code>Library</code> 文件夹</p><p><code>Classes</code> 是程序文件(il2cpp,生成的cpp)</p><p><code>Data</code> 跟其他差不多</p><p><code>Library</code> 是一些插件包 一般也不会修改这个</p><h2 id="Unity与IOS交互"><a href="#Unity与IOS交互" class="headerlink" title="Unity与IOS交互"></a>Unity与IOS交互</h2><table><thead><tr><th>扩展名</th><th>说明</th></tr></thead><tbody><tr><td>.h</td><td>头文件，它包含类名，类继承的父类，还有方法和变量的声明。它定义的类的成员变量以及方法等等是公开的，外部是可以访问的。</td></tr><tr><td>.m</td><td><strong>是纯Object-C 文件</strong>(.m只能调用纯Object-C的类，不能调用混合的). 实现文件，可以包含Objective-C和C代码。同时，它是对.h文件中方法的实现外部不能访问,</td></tr><tr><td>.mm</td><td><strong>是Object-C和C++混合</strong>(.mm可以调用Object-C的，也可以调用C++的). 实现文件，和.m文件类似，唯一的不同点就是，除了可以包含Objective-C和C代码以外，<strong>还可以包含C++代码</strong>。仅在你的Objective-C代码中确实需要使用C++类或者特性的时候才用这种扩展名。</td></tr></tbody></table><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/herenzhiming/articles/7920386.html">Objective-c中.m、.h、.mm文件 - 何人之名 - 博客园 (cnblogs.com)</a></p><p>C#可以调用C和C++代码，而C和C++可以调用Objective-C代码，这里我们将.m后缀改为.mm，这样，就可以在里面编写C和C++代码.</p><p>Unity做插件就是使用<code>.mm文件</code>,调用的都是c和c++代码</p><p><strong>什么是<code>extern &quot;C&quot;</code></strong></p><p>extern “C” 是C++ 指令,是告诉编译器 ,这里面的代码用C规则来编译</p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_36817189/article/details/110423243">extern “C“的作用及理解_米碎师兄的博客</a></p><h3 id="Unity调用IOS"><a href="#Unity调用IOS" class="headerlink" title="Unity调用IOS"></a>Unity调用IOS</h3><p>Unity 中是直接调用IOS声明的方法,不用找到类</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//固定写法</span></span><br><span class="line">[<span class="meta">DllImport(<span class="string">&quot;__Internal&quot;</span>)</span>]</span><br><span class="line"><span class="comment">//在mm或者.h中声明的方法名字 必须保持一致</span></span><br><span class="line"><span class="comment">//c# extern关键字 表示这个方法由外部实现,简单说这个方法是外部某个文件某个dll实现的 自己不需要实现</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">UnityCallIOS</span>()</span>; </span><br></pre></td></tr></table></figure><p>OC代码基本都是面向对象的,即需要new一个对象才能调用,但是C不用,<strong>Unity直接调用C代码</strong>,然后再对应代码 newOC对象.</p><p>调用代码中写的方法,需要使用符合C代码写法.</p><h3 id="IOS调用Unity"><a href="#IOS调用Unity" class="headerlink" title="IOS调用Unity"></a>IOS调用Unity</h3><p> <code>UnitySendMessage(const char *obj, const char *method, const char *msg)</code></p><p>第一个参数是物体名字 第二个参数是物体上面的方法(private也可以) 第三个参数</p><h3 id="示例-使用Scheme-url-打开其他app"><a href="#示例-使用Scheme-url-打开其他app" class="headerlink" title="示例(使用Scheme url 打开其他app)"></a>示例(使用Scheme url 打开其他app)</h3><ol><li>在xcode中声明一个.h文件和.mm文件</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;UnityAppController.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span> <span class="comment">//引入库文</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="comment">//使用C语言编译</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局固定字段声明</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * UnityGoName=<span class="string">&quot;NativeManager&quot;</span>; <span class="comment">//unity中接收信息物体</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * UnityMethodName=<span class="string">&quot;NativeToUnity&quot;</span>; <span class="comment">//物体上面的方法名 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法声明</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">ShowToast</span><span class="params">(NSString *message,<span class="type">float</span> duration)</span>; <span class="comment">//显示toast</span></span><br><span class="line">    BOOL <span class="title function_">OpenScheme</span><span class="params">(NSString *scheme)</span>;     <span class="comment">//打开某个app 带有返回值</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">UnityCallIOS</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* key,<span class="type">const</span> <span class="type">char</span>* args)</span>; <span class="comment">//unity调用ios</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">IOS2Unity</span><span class="params">(NSString *msg)</span>;<span class="comment">//ios发消息给unity</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;MyIOSBridge.h&quot;</span> <span class="comment">//引入头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UnityCallIOS</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* cmd,<span class="type">const</span> <span class="type">char</span>* args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//得到指令</span></span><br><span class="line">    NSString *strcmd=[NSString stringWithUTF8String:cmd];</span><br><span class="line">    <span class="comment">//把参数按照 | 切分</span></span><br><span class="line">    NSArray *strArgs=[[NSString stringWithUTF8String:args]componentsSeparatedByString:@<span class="string">&quot;|&quot;</span>];</span><br><span class="line">    <span class="comment">//NSLog(@&quot;指令-&gt;%@&quot;,strcmd);</span></span><br><span class="line">    <span class="comment">//如果指令是Toast </span></span><br><span class="line">    <span class="keyword">if</span>([strcmd isEqualToString:@<span class="string">&quot;Toast&quot;</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//参数1: 消息</span></span><br><span class="line">        <span class="comment">//参数2: 持续时间</span></span><br><span class="line">        NSString *msg=strArgs[<span class="number">0</span>];</span><br><span class="line">        <span class="type">float</span> duration=[strArgs[<span class="number">1</span>] floatValue];</span><br><span class="line">        ShowToast(msg, duration);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果指令是OpenScheme </span></span><br><span class="line">    <span class="keyword">if</span>([strcmd isEqualToString:@<span class="string">&quot;OpenScheme&quot;</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//参数1:scheme url</span></span><br><span class="line">        <span class="comment">//参数2:app 名字</span></span><br><span class="line">        NSString *msg=strArgs[<span class="number">0</span>];</span><br><span class="line">        NSString *appName=strArgs[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//NSLog(@&quot;scheme指令-&gt;%@ 程序=%@&quot;,msg,appName);</span></span><br><span class="line">        BOOL result= OpenScheme(msg);</span><br><span class="line">        <span class="keyword">if</span>(result==NO)</span><br><span class="line">        &#123;</span><br><span class="line">            ShowToast([NSString stringWithFormat:@<span class="string">&quot;没有安装该App:%@&quot;</span>,appName], <span class="number">2.0f</span>);</span><br><span class="line">            <span class="comment">//发送一个消息到unity</span></span><br><span class="line">            IOS2Unity([NSString stringWithFormat:@<span class="string">&quot;noapp|%@&quot;</span>,appName]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送消息到unity</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IOS2Unity</span><span class="params">(NSString *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//会有一帧的延迟</span></span><br><span class="line">    <span class="comment">//IPhonePlayer表示是IPhonePlayer平台</span></span><br><span class="line">    msg=[NSString stringWithFormat:@<span class="string">&quot;IPhonePlayer|%@&quot;</span>,msg];</span><br><span class="line">    UnitySendMessage(UnityGoName, UnityMethodName, msg.UTF8String);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Toast</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">ShowToast</span><span class="params">(NSString *message, <span class="type">float</span> toastLengthInSeconds)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// NSString *message = [NSString stringWithUTF8String:toastText];</span></span><br><span class="line">    UIAlertController *alert = [UIAlertController alertControllerWithTitle:nil</span><br><span class="line">                                                                   message:message</span><br><span class="line">                                                            preferredStyle:UIAlertControllerStyleAlert];</span><br><span class="line">    UIViewController *rootViewController = UnityGetGLViewController();</span><br><span class="line">    [rootViewController presentViewController:alert animated:YES completion:nil];</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, toastLengthInSeconds * NSEC_PER_SEC), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [alert dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打开某个app 使用的是scheme url</span></span><br><span class="line">BOOL <span class="title function_">OpenScheme</span><span class="params">(NSString *scheme)</span></span><br><span class="line">&#123;</span><br><span class="line">    NSURL *url = [NSURL URLWithString:scheme];</span><br><span class="line">    <span class="keyword">if</span>([[UIApplication sharedApplication] canOpenURL:url])&#123;</span><br><span class="line">        [[UIApplication sharedApplication] openURL:url];</span><br><span class="line">            <span class="keyword">return</span> YES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li><p>将两个文件导入Unity-&gt;Plugins-&gt;IOS目录</p></li><li><p>在Unity脚本</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> ____DESC:      Unity IOS 交互</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Native_IOS</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//固定写法</span></span><br><span class="line">    [<span class="meta">DllImport(<span class="string">&quot;__Internal&quot;</span>)</span>]</span><br><span class="line">    <span class="comment">//在mm或者.h中声明的方法名字 必须保持一致</span></span><br><span class="line">    <span class="comment">//c# extern 表示这个方法由外部实现,简单说这个方法是外部某个文件某个dll实现的 自己不需要实现</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 调用IOS  args用 &quot;|&quot;分割</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">UnityCallIOS</span>(<span class="params"><span class="built_in">string</span> key,<span class="built_in">string</span> args</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UnityToIOS</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> v = <span class="built_in">string</span>.Join(<span class="string">&#x27;|&#x27;</span>, args);</span><br><span class="line">        UnityCallIOS(key, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> ____DESC:      与原生平台交互管理器</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NativeManager</span> : <span class="title">MonoSingleton</span>&lt;<span class="title">NativeManager</span>&gt;, <span class="title">IManager</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> System.Action&lt;RuntimePlatform, <span class="built_in">string</span>[]&gt; OnReceiveNativeMsg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Native_IOS native_IOS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> IsInit &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RuntimePlatform currRuntimePlatform;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Init</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.gameObject.name = <span class="keyword">nameof</span>(NativeManager);</span><br><span class="line">        currRuntimePlatform = Application.platform;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (currRuntimePlatform == RuntimePlatform.IPhonePlayer)</span><br><span class="line">            native_IOS = <span class="keyword">new</span> Native_IOS();</span><br><span class="line">        SetDontDestoryOnload();</span><br><span class="line">        IsInit = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 接收到其他平台发来的消息,可以是私有方法</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;msg&quot;&gt;</span>msg包含一个|<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">NativeToUnity</span>(<span class="params"><span class="built_in">string</span> msg</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//用|切分 第0个是平台</span></span><br><span class="line">        <span class="keyword">var</span> msgs = msg.Split(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (System.Enum.TryParse&lt;RuntimePlatform&gt;(msgs[<span class="number">0</span>], ignoreCase: <span class="literal">true</span>, <span class="keyword">out</span> RuntimePlatform runtimePlatform))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//其他参数 </span></span><br><span class="line">            List&lt;<span class="built_in">string</span>&gt; args = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; msgs.Length; i++)</span><br><span class="line">                args.Add(msgs[i]);</span><br><span class="line"></span><br><span class="line">            OnReceiveNativeMsg?.Invoke(runtimePlatform, args.ToArray());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            MyLog.LogError(<span class="string">$&quot;平台错误:<span class="subst">&#123;msgs[<span class="number">0</span>]&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Unity调用原生平台</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;runtimePlatform&quot;&gt;</span>平台<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>key<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;args&quot;&gt;</span>参数<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UnityCallNative</span>(<span class="params">RuntimePlatform runtimePlatform, <span class="built_in">string</span> key, <span class="keyword">params</span> <span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (runtimePlatform)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> RuntimePlatform.IPhonePlayer:</span><br><span class="line">                <span class="keyword">if</span> (currRuntimePlatform == RuntimePlatform.IPhonePlayer)</span><br><span class="line">                &#123;  </span><br><span class="line">                    native_IOS.UnityToIOS(key,args);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Button btnQQ, btnWeibo, btnLofter, btnBilibili, btnNone;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//QQ</span></span><br><span class="line">    <span class="built_in">string</span> schemeQQGroup = <span class="string">&quot;mqqapi://card/show_pslcard?src_type=internal&amp;version=1&amp;card_type=group&amp;uin=1020819114&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> schemeQQGroup2 = <span class="string">&quot;tim://card/show_pslcard?src_type=internal&amp;version=1&amp;uin=1020819114&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Lofter</span></span><br><span class="line">    <span class="built_in">string</span> schemeLofter = <span class="string">&quot;lofter://qiyunyimeng.lofter.com/&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> httpLofter = <span class="string">&quot;https://qiyunyimeng.lofter.com/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//B站</span></span><br><span class="line">    <span class="built_in">string</span> schemeBilibili = <span class="string">&quot;bilibili://space/1346329729&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> httpBilibili = <span class="string">&quot;https://m.bilibili.com/space/1346329729&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//抖音</span></span><br><span class="line">    <span class="built_in">string</span> schemeDouyin = <span class="string">&quot;https://v.douyin.com/2XR7GQ2/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//微博</span></span><br><span class="line">    <span class="built_in">string</span> schemeWeibo = <span class="string">&quot;sinaweibo://userinfo?uid=5904919311&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> schemeWeibo2 = <span class="string">&quot;weibointernational://userinfo?uid=5904919311&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> httpWeibo = <span class="string">&quot;https://weibo.com/u/5904919311&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        NativeManager.Ins.Init();</span><br><span class="line">        NativeManager.Ins.OnReceiveNativeMsg += Ins_OnReceiveNativeMsg;</span><br><span class="line">        btnQQ.onClick.AddListener(() =&gt; NativeManager.Ins.UnityCallNative(RuntimePlatform.IPhonePlayer, <span class="string">&quot;OpenScheme&quot;</span>, schemeQQGroup,<span class="string">&quot;QQ&quot;</span>));</span><br><span class="line">        btnWeibo.onClick.AddListener(() =&gt; NativeManager.Ins.UnityCallNative(RuntimePlatform.IPhonePlayer, <span class="string">&quot;OpenScheme&quot;</span>, schemeWeibo2,<span class="string">&quot;weibo&quot;</span>));</span><br><span class="line">        btnLofter.onClick.AddListener(() =&gt; NativeManager.Ins.UnityCallNative(RuntimePlatform.IPhonePlayer, <span class="string">&quot;OpenScheme&quot;</span>, schemeLofter,<span class="string">&quot;lofter&quot;</span>));</span><br><span class="line">        btnBilibili.onClick.AddListener(() =&gt; NativeManager.Ins.UnityCallNative(RuntimePlatform.IPhonePlayer, <span class="string">&quot;OpenScheme&quot;</span>, schemeBilibili, <span class="string">&quot;bilibili&quot;</span>));</span><br><span class="line">        btnNone.onClick.AddListener(() =&gt; NativeManager.Ins.UnityCallNative(RuntimePlatform.IPhonePlayer, <span class="string">&quot;OpenScheme&quot;</span>, <span class="string">&quot;tt://sdfsdfdss&quot;</span>,<span class="string">&quot;tt&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接收到消息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Ins_OnReceiveNativeMsg</span>(<span class="params">RuntimePlatform platform, <span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;接收到消息:&quot;</span> + platform.ToString() + <span class="string">&quot; &quot;</span> + args[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (platform == RuntimePlatform.IPhonePlayer)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提示没有安装该app</span></span><br><span class="line">            <span class="keyword">if</span> (args[<span class="number">0</span>] == <span class="string">&quot;noapp&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//如果是qq</span></span><br><span class="line">                <span class="keyword">if</span> (args[<span class="number">1</span>] == <span class="string">&quot;QQ&quot;</span>)</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果没有微博 就直接打开微博uri</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (args[<span class="number">1</span>] == <span class="string">&quot;weibo&quot;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Application.OpenURL(httpWeibo);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (args[<span class="number">1</span>] == <span class="string">&quot;lofter&quot;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Application.OpenURL(httpWeibo);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (args[<span class="number">1</span>] == <span class="string">&quot;bilibili&quot;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Application.OpenURL(httpBilibili);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (args[<span class="number">1</span>] == <span class="string">&quot;tt&quot;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Application.OpenURL(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p>IOS使用scheme的时候需要添加白名单,不然打不开.</p><p>添加scheme的时候不用加<code>://</code></p><p>第一种添加方式</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209261938423.png" alt="image-20220926193759959"></p><p>第二种添加方式</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209261938080.png" alt="image-20220926193846672"></p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/yangxuan0261/article/details/113766453">unity-与ios交互_蝶泳奈何桥.的博客-CSDN博客_unity与ios交互</a></li><li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f397d51e4447">iOS Unity 交互（系列二）iOS调用Unity函数 iOS给Unity传值 - 简书 (jianshu.com)</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/huanguuuu1234567/article/details/78027207">定制 UnityAppController_云之逸的博客-CSDN博客</a></li><li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ba716bebab22?tdsourcetag=s_pcqq_aiomsg">Unity iOS打包之覆写UnityAppController.mm - 简书 (jianshu.com)</a></li></ul></li></ol><h2 id="问题合集"><a href="#问题合集" class="headerlink" title="问题合集"></a>问题合集</h2><h3 id="证书不受信任"><a href="#证书不受信任" class="headerlink" title="证书不受信任"></a>证书不受信任</h3><p>如果是别人给的证书那么就是以<code>.p12</code>结尾,双击就可以导入,然后再钥匙串中就可以看到</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209171602987.png" alt="image-20220917160230943"></p><p>如果证书显示不受信任</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209171604518.png" alt="image-20220917160415447"></p><p>那么需要重新下载一个  证书</p><p>地址:<a target="_blank" rel="noopener" href="https://www.apple.com/certificateauthority/">Apple PKI - Apple</a>    下载之后双击按照就可以</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209171607147.png" alt="image-20220917160718076"></p><h3 id="Distribution-APP过程出现问题"><a href="#Distribution-APP过程出现问题" class="headerlink" title="Distribution APP过程出现问题"></a>Distribution APP过程出现问题</h3><p>出现<code>The data couldn’t be read because it isn’t in the correct format</code>或者<code>zip faild</code>什么的,都先检查是否存贮空间不够了</p><h3 id="打出的IPA文件名是ProductName"><a href="#打出的IPA文件名是ProductName" class="headerlink" title="打出的IPA文件名是ProductName"></a>打出的IPA文件名是ProductName</h3><p>ProductName 就是BundleName 游戏名字是Bundle Diaplay Name</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209171633157.png" alt="image-20220917163355081"></p><p>在Unity中设置了<strong>Productname</strong> 如果是英文名 好像不会出现这个错误,如果是中文,那么就有可能出现这个名字</p><ul><li>可以在Xcode工程中改</li><li>也可以在Unity导出的时候改 <code>Info.plist</code>文件</li></ul><p>这个时候我们可以在打包出IOS的时候自动设置一下,在unity 新建一个Editor脚本,加上代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">PostProcessBuild</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnPostProcessBuild</span>(<span class="params">BuildTarget buildTarget, <span class="built_in">string</span> pathToBuiltProject</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (buildTarget == BuildTarget.iOS)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> pbxProjectPath = PBXProject.GetPBXProjectPath(pathToBuiltProject);</span><br><span class="line">            <span class="comment">//xcode对象读取的就是xxxx.xcodeproj下面的project.pbxproj</span></span><br><span class="line">            <span class="comment">//PBXProject pbxProject = new PBXProject();</span></span><br><span class="line">            <span class="comment">//pbxProject.ReadFromFile(pbxProjectPath);</span></span><br><span class="line">            <span class="comment">//string targetGUID = pbxProject.GetUnityMainTargetGuid();</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//var configNames = pbxProject.BuildConfigNames();</span></span><br><span class="line">            <span class="comment">//foreach (var configName in configNames)</span></span><br><span class="line">            <span class="comment">//&#123;</span></span><br><span class="line">            <span class="comment">//    var config = pbxProject.BuildConfigByName(targetGUID, configName);</span></span><br><span class="line">            <span class="comment">//    pbxProject.SetBuildProperty(config, &quot;PRODUCT_NAME_APP&quot;, &quot;qqym222&quot;);</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">            <span class="comment">//pbxProject.WriteToFile(pbxProjectPath);</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> identifiers = PlayerSettings.GetApplicationIdentifier(BuildTargetGroup.iOS).Split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            <span class="keyword">var</span> bundleName = identifiers.Length &gt; <span class="number">1</span> ? identifiers[identifiers.Length - <span class="number">1</span>] : identifiers[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *修改ProductName 打包发现BundleName如果是中文显示的就是&quot;ProductName&quot; 而不是app名字</span></span><br><span class="line"><span class="comment">             *设置称为包名最后一个名字 com.aaaa.bbb 那么就是bbb</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//直接替换所有</span></span><br><span class="line">            <span class="built_in">string</span> pbxProjectContent = File.ReadAllText(pbxProjectPath);</span><br><span class="line">            pbxProjectContent = pbxProjectContent.Replace(<span class="string">&quot;PRODUCT_NAME_APP = ProductName&quot;</span>, <span class="string">$&quot;PRODUCT_NAME_APP = <span class="subst">&#123;bundleName&#125;</span>&quot;</span>);</span><br><span class="line">            File.WriteAllText(pbxProjectPath, pbxProjectContent);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//读取修改Info.plist 是以键值对存在的</span></span><br><span class="line">            <span class="comment">//string plistPath = pathToBuiltProject + &quot;/&quot; + &quot;Info.plist&quot;;</span></span><br><span class="line">            <span class="comment">//PlistDocument plist = new PlistDocument();</span></span><br><span class="line">            <span class="comment">//plist.ReadFromFile(plistPath);</span></span><br><span class="line">            <span class="comment">//plist.root.SetString(&quot;CFBundleName&quot;, bundleName);</span></span><br><span class="line">            <span class="comment">//plist.WriteToFile(plistPath);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://xmanyou.com/unity-using-script-modify-xcode-project/">#Unity# 在编辑器扩展中用PostProcessBuildAttribute来修改XCode工程的Product Name (xmanyou.com)</a></p><h3 id="使用www-UnityWebRequest-无法读取SteamingAssets中的文件"><a href="#使用www-UnityWebRequest-无法读取SteamingAssets中的文件" class="headerlink" title="使用www(UnityWebRequest)无法读取SteamingAssets中的文件"></a>使用www(UnityWebRequest)无法读取SteamingAssets中的文件</h3><p><a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2020.3/Manual/StreamingAssets.html">流媒体资源 - Unity 手册</a></p><blockquote><p><code>Application.streamingAssetsPath</code> 返回的位置因平台而异：</p><ul><li>大多数平台（Unity Editor、Windows、Linux 播放器、PS4、Xbox One、Switch）使用 <code>Application.dataPath + &quot;/StreamingAssets&quot;</code>。</li><li>macOS 播放器使用 <code>Application.dataPath + &quot;/Resources/Data/StreamingAssets&quot;</code>。</li><li>iOS 使用 <code>Application.dataPath + &quot;/Raw&quot;</code>。</li><li>Android 使用经过压缩的 APK&#x2F;JAR 文件中的文件：<code>&quot;jar:file://&quot; + Application.dataPath + &quot;!/assets&quot;</code>。</li></ul><p>要在无法直接访问流媒体资源文件的平台（如 Android 和 WebGL）上读取流媒体资源，请使用 <a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2020.3/ScriptReference/Networking.UnityWebRequest.html">UnityWebRequest</a>。有关示例，请参阅 <a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2020.3/ScriptReference/Application-streamingAssetsPath.html">Application.streamingAssetsPath</a>。</p><p>在许多平台上，流媒体资源文件夹位置是只读的；您不能在运行时在这些位置修改或写入新文件。请使用 <a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2020.3/ScriptReference/Application-persistentDataPath.html">Application.persistentDataPath</a> 来获取可写的文件夹位置。</p></blockquote><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209171710730.jpeg"></p><p><strong>即使有些平台可以用IO在SteamingAssets进行写入操作,但是最好不要这么做</strong></p><p>IOS与Android不同,IOS需要在前面加一个 <code>file://</code>   <code>Android是经过压缩的 所以不能直接IO读取 要使用www 加上&quot;jar:file://&quot;协议</code></p><p><strong><code>用WWW类加载本地，要注意各个平台路径需要加的访问名称，例如Android平台的路径前要加&quot;jar:file://&quot;，其他平台使用&quot;file://&quot;</code></strong></p><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/59558c02a4f0">Unity安卓、iOS、PC、Mac读写目录 - 简书 (jianshu.com)</a></p><h3 id="The-App-Store-Icon-in-the-asset-catalog-in-‘qyym-app’-can’t-be-transparent-nor-contain-an-alpha-channel"><a href="#The-App-Store-Icon-in-the-asset-catalog-in-‘qyym-app’-can’t-be-transparent-nor-contain-an-alpha-channel" class="headerlink" title="The App Store Icon in the asset catalog in ‘qyym. app’ can’t be transparent nor contain an alpha channel"></a>The App Store Icon in the asset catalog in ‘qyym. app’ can’t be transparent nor contain an alpha channel</h3><p>这个报错原因是图标有透明或者有透明通道</p><ul><li><p>方法一:</p><p>直接把unity icon 图标搞成jpg然后再打包</p></li><li><p>方法二:</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202210111701250.png" alt="image-20221011170141146"></p><p>把每个图片用windows自带画图编辑保存(画图保存自然会丢失a通道)</p></li></ul><h3 id="The-bundle-at-‘my-app-Frameworks-UnityFramework-framework’-contains-disallowed-file-‘Frameworks’"><a href="#The-bundle-at-‘my-app-Frameworks-UnityFramework-framework’-contains-disallowed-file-‘Frameworks’" class="headerlink" title="The bundle at ‘my.app&#x2F;Frameworks&#x2F;UnityFramework.framework’ contains disallowed file ‘Frameworks’."></a>The bundle at ‘my.app&#x2F;Frameworks&#x2F;UnityFramework.framework’ contains disallowed file ‘Frameworks’.</h3><p><del>就是不能嵌套包含,这个问题不知出在哪,我自己打包的时候没啥问题,用火星人工具打包出现了问题</del></p><p>新的解决方案:将ks广告设置为动态库</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202310221213469.png" alt="屏幕截图 2023-10-22 121246"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202310221214471.png" alt="屏幕截图 2023-10-22 121415"></p><p>最后点击Add Files重新添加相应的Framework</p><p><del>解决方案</del></p><ol><li>XCode在上传testflight前会先<strong>Archive</strong>，首先先在Achieve成功后的项目中右键<strong>Show in Finder</strong></li></ol><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202210111705295.png" alt="image-20221011170555053"></p><ol start="2"><li>在.xcarchive文件点右键<strong>显示包内容</strong></li></ol><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202210111706795.png" alt="image-20221011170618609"></p><ol start="3"><li>在Products&#x2F;Applications&#x2F;xx.app文件再点右键<strong>显示包内容</strong></li></ol><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202210111706436.png" alt="image-20221011170632329"></p><ol start="4"><li>删除Frameworks&#x2F;UnityFramework.framework&#x2F;Frameworks文件夹</li></ol><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202210111706957.png" alt="image-20221011170643670"></p><ol start="5"><li>再重新上传testflight就可以成功上传了！</li></ol><p>以上这些步骤可以用shell命令来处理，步骤如下：</p><p><strong>在Build Phases下新增Run Script，并添加以下代码：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span>            </span><br><span class="line"><span class="string">&quot;<span class="variable">$&#123;CONFIGURATION_BUILD_DIR&#125;</span>/<span class="variable">$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;</span>/Frameworks/UnityFramework.framework/&quot;</span> </span><br><span class="line"><span class="keyword">if</span> [[ -d <span class="string">&quot;Frameworks&quot;</span> ]]; <span class="keyword">then</span> </span><br></pre></td></tr></table></figure><p>转自：<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://www.weixiuzhan.cn/news/show-29533.html">https://www.weixiuzhan.cn/news/show-29533.html</a></p><h3 id="Command-Ld-failed-with-a-nonzero-exit-code"><a href="#Command-Ld-failed-with-a-nonzero-exit-code" class="headerlink" title="Command Ld failed with a nonzero exit code"></a>Command Ld failed with a nonzero exit code</h3><p>这个问题多种多样,我这里记录一下</p><p>1:是我用mac连接window共享文件夹问题(很奇怪之前没这个问题)</p><h3 id="DerivedData-Unity-iPhone-fazbdskwtnuvvqcdjsitsmtzxowo-Build-Products-ReleaseForRunning-iphoneos-UnityFramework-framework-UnityFramework’-does-not-contain-bitcode-You-must-rebuild-it-with-bitcode-enabled-Xcode-setting-ENABLE-BITCODE-obtain-an-updated-library-from-the-vendor-or-disable-bitcode-for-this-target"><a href="#DerivedData-Unity-iPhone-fazbdskwtnuvvqcdjsitsmtzxowo-Build-Products-ReleaseForRunning-iphoneos-UnityFramework-framework-UnityFramework’-does-not-contain-bitcode-You-must-rebuild-it-with-bitcode-enabled-Xcode-setting-ENABLE-BITCODE-obtain-an-updated-library-from-the-vendor-or-disable-bitcode-for-this-target" class="headerlink" title="DerivedData&#x2F;Unity-iPhone-fazbdskwtnuvvqcdjsitsmtzxowo&#x2F;Build&#x2F;Products&#x2F;ReleaseForRunning-iphoneos&#x2F;UnityFramework.framework&#x2F;UnityFramework’ does not contain bitcode. You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target."></a>DerivedData&#x2F;Unity-iPhone-fazbdskwtnuvvqcdjsitsmtzxowo&#x2F;Build&#x2F;Products&#x2F;ReleaseForRunning-iphoneos&#x2F;UnityFramework.framework&#x2F;UnityFramework’ does not contain bitcode. You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target.</h3><p>在xcode中 build setting-&gt;bitcode 设置为NO</p><h3 id="添加动态库设置"><a href="#添加动态库设置" class="headerlink" title="添加动态库设置"></a>添加动态库设置</h3><p>例如添加AVPRO</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202310221208801.png" alt="1"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202310221208309.png" alt="3"><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202310221208246.png" alt="2"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202310221208598.png" alt="4"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h2&gt;&lt;h3 id=&quot;设备&quot;&gt;&lt;a href=&quot;#设备&quot; class=&quot;headerlink&quot; title=&quot;设备&quot;&gt;&lt;/a&gt;设备&lt;/h</summary>
      
    
    
    
    <category term="Unity" scheme="https://zeroultra.github.io/categories/Unity/"/>
    
    <category term="IOS" scheme="https://zeroultra.github.io/categories/Unity/IOS/"/>
    
    
    <category term="Unity" scheme="https://zeroultra.github.io/tags/Unity/"/>
    
    <category term="IOS" scheme="https://zeroultra.github.io/tags/IOS/"/>
    
  </entry>
  
  <entry>
    <title>Unity &amp; Android</title>
    <link href="https://zeroultra.github.io/2022/08-25-Unity2Android/"/>
    <id>https://zeroultra.github.io/2022/08-25-Unity2Android/</id>
    <published>2022-08-25T03:11:29.000Z</published>
    <updated>2022-08-25T03:11:29.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="Unity调用Android"><a href="#Unity调用Android" class="headerlink" title="Unity调用Android"></a>Unity调用Android</h2><p>Unity中可以直接调用Android代码.例如:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c#代码 </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">toastText</span>(<span class="params"><span class="built_in">object</span> str</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">    AndroidJavaClass UnityPlayer = <span class="keyword">new</span> AndroidJavaClass(<span class="string">&quot;com.unity3d.player.UnityPlayer&quot;</span>);</span><br><span class="line">    AndroidJavaObject currentActivity= UnityPlayer.GetStatic&lt;AndroidJavaObject&gt;(<span class="string">&quot;currentActivity&quot;</span>);</span><br><span class="line">    AndroidJavaClass Toast = <span class="keyword">new</span> AndroidJavaClass(<span class="string">&quot;android.widget.Toast&quot;</span>);</span><br><span class="line">    AndroidJavaObject context =currentActivity.Call&lt;AndroidJavaObject&gt;(<span class="string">&quot;getApplicationContext&quot;</span>);</span><br><span class="line">    currentActivity.Call(<span class="string">&quot;runOnUiThread&quot;</span>, <span class="keyword">new</span> AndroidJavaRunnable(() =&gt; &#123;</span><br><span class="line">        AndroidJavaObject javaString = <span class="keyword">new</span> AndroidJavaObject(<span class="string">&quot;java.lang.String&quot;</span>, str.ToString());</span><br><span class="line">        Toast.CallStatic&lt;AndroidJavaObject(<span class="string">&quot;makeText&quot;</span>,context,javaString,Toast.GetStatic&lt;<span class="built_in">int</span>(<span class="string">&quot;LENGTH_SHORT&quot;</span>)).Call(<span class="string">&quot;show&quot;</span>);&#125;</span><br><span class="line">     ));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这么做方便,但是对于一般人而言,不太会写,而且容易拼写错误</p><p>所有还是使用AS导出jar包或者aar包,亦或者直接把写好的java代码放在<code>unity/plugins/android</code>目录下面</p><p>新建AS工程然后导入unity下路的classes.jar包, 2019版本及以上版本中classes.jar包中可能没有<code>UnityPlayerActivity</code>,需要单独重新导入</p><ul><li>classes.jar路径:xx&#x2F;Editor\Data\PlaybackEngines\AndroidPlayer\Variations\mono\Release\Classes</li><li>UnityPlayerActivity:xx&#x2F;Editor\Data\PlaybackEngines\AndroidPlayer\Source\com\unity3d\player</li></ul><ol><li><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202212241413109.png" alt="image-20221224141313616"></p></li><li><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202212241416106.png" alt="image-20221224141551392"></p></li><li><p>新建一个Activity继承UnityPlayerActivity,然后在里面写一些逻辑代码</p></li><li><p>如果只是工具类 不想继承UnityPlayerActivity,那么自己规定好包名使用静态方法调用即可</p></li><li><p>如新建了Activity继承UnityPlayerActivity,需要在Unity中创建AndroidManifest.xml,指向启动的activity</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202212241421607.png"></p><blockquote><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wu_wenhuan/article/details/44941545/">https://blog.csdn.net/wu_wenhuan/article/details/44941545/</a><br>Android.intent.action.MAIN决定应用程序最先启动的<br>ctivity android.intent.category.LAUNCHER决定应用程序是否显示在程序列表里<br>通过实验后，发现有问题？<br>MAIN 与 LAUNCHER 并不是单纯的各管各的事情；<br>我测试的结果是，如果一个应用没有LAUNCHER则该apk仍能安装到设备上，但是在桌面中图标中看不到。如果给那个Activity 设定了LAUNCHER，且同时设定了Main,则这个Activity就可出现在程序图标中；如果没有Main，则不知启动哪个Activity，故也不会有图标出现。可见，Main指的是，点击图标后启动哪个Activity。当然，Main可以给多个Activity设定，但只设定Main不设定LAUNCHER，仍然无法进入activity。<br>可见，Main和LAUNCHER同时设定才有意义，如果多个activity同时设定，则会出现两个图标，分别先进入不同的activity.</p></blockquote></li><li><p>最后把写好的java代码放到Unity&#x2F;Plugins&#x2F;Android 目录下</p></li><li><p>编写C#代码</p><p><code>AndroidJavaClass</code> : <code>是java.lang.Class 类 </code>主要用于获取静态字段或调用静态方法 <code>C#中静态类.方法 或类.静态方法</code><br><code>AndroidJavaObject</code>:<code>是java.lang.Object 实例对象</code> 调用对象方法: Call 方法，需要new</p><p>直接找到包名下对应的类,是一个类 只能调用一些static 方法<br><strong>AndroidJavaClass androidJC &#x3D; new AndroidJavaClass(com.xxx.xx.xxxClass)</strong></p><p>获取一个对象也可以直接用<br><strong>AndroidJavaObject androidJO &#x3D; new AndroidJavaObject(com.xxx.xx.xxxClass)</strong></p><p>表示new一个该包名下的类,这个也可以直接找到对象 然后调用对象上面的普通方法</p><p>我们常用的<br><code>AndroidJavaClass androidJC = new AndroidJavaClass(com.unity3d.player.UnityPlayer); AndroidJavaObject jo=androidJC.GetStatic&lt;AndroidObject&gt;(&quot;currentActivity&quot;);</code><br>其实就是在或者获取 UnityPlayerActivity 单例<br>com.unity3d.player.UnityPlayer 是classes.jar 中的一个类</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202212241431374.png" alt="在这里插入图片描述"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202212241431394.png" alt="在这里插入图片描述"></p><p>调用android方法最好是在ui线程中 即: runOnUiThread</p></li></ol><p>我的csdn文章有具体操作:<a target="_blank" rel="noopener" href="https://blog.csdn.net/K20132014/article/details/109159008">(Unity与Android通信交互_Zero_LJ的博客-CSDN博客_unity android 交互</a></p><h2 id="Android调用Unity"><a href="#Android调用Unity" class="headerlink" title="Android调用Unity"></a>Android调用Unity</h2><p>Android中调用Unity代码,就是给Unity发消息,Unity针对不同的消息处理逻辑</p><p>在Java代码中使用<code>UnityPlayer.UnitySendMessage(string str1,string str2,string arg)</code>方法</p><p>该方法有三个参数:</p><ul><li>参数1是Unity场景GameObject名称</li><li>参数2是该GameObject上面的方法</li><li>第三个是该方法的参数 可以为null</li></ul><h2 id="使用AndroidJavaProxy进行交互"><a href="#使用AndroidJavaProxy进行交互" class="headerlink" title="使用AndroidJavaProxy进行交互"></a>使用AndroidJavaProxy进行交互</h2><p><code>UnityPlayer.UnitySendMessage(string str1,string str2,string arg)</code>性能及其不好,采用AndroidJavaProxy</p><p>AndroidJavaProxy需要在java和C#建立桥接</p><p><strong>java代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明包名</span></span><br><span class="line"><span class="keyword">package</span> com.zeroultra.connecter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NativeAndroidProxy</span> &#123;</span><br><span class="line">    <span class="comment">//定义桥接方法名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SendToUnity</span><span class="params">(String cmd,String msg)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>C#代码</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Android代理</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;code&gt;</span>声明方法只要和Java中的interface保持一致即可,可以是私有方法<span class="doctag">&lt;/code&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NativeAndroidProxy</span> : <span class="title">AndroidJavaProxy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 当接收消息</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; OnReceiveMsg;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 声明代理 传入具体名(com.zeroultra.connecter.NativeAndroidProxy)</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NativeAndroidProxy</span>(<span class="params"><span class="built_in">string</span> proxyName</span>) : <span class="title">base</span>(<span class="params">proxyName</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span>  发送消息到unity 可以私有方法 和java代码保持一致</span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SendToUnity</span>(<span class="params"><span class="built_in">string</span> cmd, <span class="built_in">string</span> msg</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        OnReceiveMsg?.Invoke(cmd, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后C#层声明代理传入Java层</p><p><strong>java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zeroultra.connecter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="comment">//引入包名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAndroid</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SendToUnity</span><span class="params">(NativeAndroidProxy proxy)</span></span><br><span class="line">    &#123;</span><br><span class="line">        bridge.SendToUnity(<span class="string">&quot;android&quot;</span>,<span class="string">&quot;hello窝窝窝&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span>:<span class="title">Monobehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//声明代理</span></span><br><span class="line">        NativeAndroidProxy proxy=<span class="keyword">new</span> NativeAndroidProxy();</span><br><span class="line">        <span class="comment">//监听事件</span></span><br><span class="line">        proxy.OnReceiveMsg+=(cmd,msg)=&gt;&#123;&#125;;</span><br><span class="line">        <span class="comment">//声明对象</span></span><br><span class="line">        <span class="keyword">using</span> (AndroidJavaObject jo = <span class="keyword">new</span> AndroidJavaObject(<span class="string">&quot;com.zeroultra.connecter.TestAndroid&quot;</span>))</span><br><span class="line">  &#123;</span><br><span class="line">            <span class="comment">//调用方法</span></span><br><span class="line">      jo.Call(<span class="string">&quot;SendToUnity&quot;</span>,proxy);</span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="Unity2021-2以上版本Android不能放res文件夹"><a href="#Unity2021-2以上版本Android不能放res文件夹" class="headerlink" title="Unity2021.2以上版本Android不能放res文件夹"></a>Unity2021.2以上版本Android不能放res文件夹</h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202208251121729.png" alt="12"></p><p><a target="_blank" rel="noopener" href="https://docs.unity3d.com/2021.2/Documentation/Manual/UpgradeGuide20212.html">Unity - Manual: Upgrading to Unity 2021.2 (unity3d.com)</a></p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol><li><p>用AndroidStudio打包成arr,然后导入 参考:<a target="_blank" rel="noopener" href="https://blog.csdn.net/egostudio/article/details/125655477">AndroidStudio打包AAR供Unity使用流程</a></p></li><li><p>直接把文件命名成xxxx.androidlib,然后添加两个文件,一个<code>AndroidManifest.xml</code>和<code>project.properties</code><a target="_blank" rel="noopener" href="https://blog.csdn.net/yixuan2009/article/details/125418054">Unity2021.2版本打包报错</a></p></li></ol><p><code>AndroidManifest.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">package</span>=<span class="string">&quot;custom.android.res&quot;</span>  &lt;<span class="attr">--这里随便命名--</span>&gt;</span></span><br><span class="line">          android:versionCode=&quot;1&quot;</span><br><span class="line">          android:versionName=&quot;1.0&quot;&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>project.properties</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This file is automatically generated by Android Tools.</span></span><br><span class="line"><span class="comment"># Do not modify this file -- YOUR CHANGES WILL BE ERASED!</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This file must be checked in Version Control Systems.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># To customize properties used by the Ant build system edit</span></span><br><span class="line"><span class="comment"># &quot;ant.properties&quot;, and override values to adapt the script to your</span></span><br><span class="line"><span class="comment"># project structure.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):</span></span><br><span class="line"><span class="comment">#proguard.config=$&#123;sdk.dir&#125;/tools/proguard/proguard-android.txt:proguard-project.txt</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Project target.</span></span><br><span class="line"><span class="comment">#target=android-30</span></span><br><span class="line"><span class="attr">android.library</span>=<span class="string">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后把res文件和这两个放在一起就可以了</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202208251133061.png" alt="image-20220825113300010"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;Unity调用Android&quot;&gt;&lt;a href=&quot;#Unity调用Android&quot; class=&quot;headerlink&quot; title=&quot;Unity调用Android&quot;&gt;&lt;/a&gt;Unity调用Android&lt;/h2&gt;&lt;p&gt;Unity中可以直接调用Andro</summary>
      
    
    
    
    <category term="Unity" scheme="https://zeroultra.github.io/categories/Unity/"/>
    
    <category term="Android" scheme="https://zeroultra.github.io/categories/Unity/Android/"/>
    
    
    <category term="Unity" scheme="https://zeroultra.github.io/tags/Unity/"/>
    
    <category term="Android" scheme="https://zeroultra.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>UnityEditor合集</title>
    <link href="https://zeroultra.github.io/2022/08-09-UnityEditor%E5%90%88%E9%9B%86/"/>
    <id>https://zeroultra.github.io/2022/08-09-UnityEditor%E5%90%88%E9%9B%86/</id>
    <published>2022-08-09T09:45:53.000Z</published>
    <updated>2022-08-09T09:45:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MenuItem"><a href="#MenuItem" class="headerlink" title="MenuItem"></a>MenuItem</h2><p><strong>MenuItem(string itemName, bool isValidateFunction, int priority)</strong>               </p><ul><li>“itemName：菜单名称路径</li><li>“isValidateFunction：默认为false，如果为true则是一个验证函数,方法返回值必须是bool类型 表示是否可以执行这个命令 </li><li>“priority：菜单项显示排序 如果相差间隔大于&#x3D;11 就会有一个下划线</li><li>“快捷键 %（ctrl）、# (shift)、&amp; (alt) _w(按下w, 单一字母)</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33337811/article/details/72852342">Unity Editor 基础篇（十一）：MenuItem属性_庸人自扰Eam的博客-CSDN博客_unity menuitem</a></p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhaoqingqing/p/14837474.html">Unity Editor自定义菜单排序(MenuItem Order) - 赵青青 - 博客园 (cnblogs.com)</a></p><h2 id="Unity-SerializedProperty和Target-区别"><a href="#Unity-SerializedProperty和Target-区别" class="headerlink" title="Unity SerializedProperty和Target 区别"></a>Unity SerializedProperty和Target 区别</h2><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>SerializedProperty</td><td>1.可以多选 <br />2.自动Undo<br />3.预制体重写<br />4.可以修改私有对象</td><td>比较麻烦</td></tr><tr><td>Target</td><td>简单好用,跟调用对象一样</td><td>不能修改私有变量 不能多选 不能undo 修改对象后，要使用EditorUtility.SetDirty(target) 将target标记为脏状态，否则修改状态不会被记</td></tr></tbody></table><p>示例代码:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">CustomEditor(typeof(InspectorExample))</span>]</span><br><span class="line">[<span class="meta">CanEditMultipleObjects</span>]        <span class="comment">//用于处理多选</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InspectorExampleEditor</span> : <span class="title">Editor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> SerializedProperty hpProp;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        hpProp = serializedObject.FindProperty(<span class="string">&quot;Hp&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnInspectorGUI</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1. 使用SerializedProperty 优点：自动处理多选、Undo、预制件重写</span></span><br><span class="line">        serializedObject.Update();</span><br><span class="line">        EditorGUILayout.IntSlider(hpProp, <span class="number">0</span>, <span class="number">100</span>, hpContent);</span><br><span class="line">        <span class="comment">//当没有多选不同值时就显示ProgressBar</span></span><br><span class="line">        <span class="keyword">if</span> (!hpProp.hasMultipleDifferentValues)     </span><br><span class="line">            ProgressBar(hpProp.intValue / <span class="number">100f</span>, <span class="string">&quot;HP&quot;</span>);</span><br><span class="line">        EditorGUILayout.IntSlider(mpProp, <span class="number">0</span>, <span class="number">100</span>, mpContent);</span><br><span class="line">        <span class="keyword">if</span> (!mpProp.hasMultipleDifferentValues)</span><br><span class="line">            ProgressBar(mpProp.intValue / <span class="number">100f</span>, <span class="string">&quot;MP&quot;</span>);</span><br><span class="line">        <span class="comment">//可以直接通过PropertyField绘制默认Field或自定义PropertyAttribte</span></span><br><span class="line">        EditorGUILayout.PropertyField(swordProp, swordContent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//应用SerializedProperty改变</span></span><br><span class="line">        serializedObject.ApplyModifiedProperties();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 直接修改对象身上的值  </span></span><br><span class="line">        EditorGUI.BeginChangeCheck();</span><br><span class="line">        InspectorExample iEx = (InspectorExample) target;</span><br><span class="line">        iEx.Attack = EditorGUILayout.IntSlider(attackContent, iEx.Attack, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="built_in">bool</span> allowSceneObject = !EditorUtility.IsPersistent(target);</span><br><span class="line">        iEx.Shield =</span><br><span class="line">            (GameObject) EditorGUILayout.ObjectField(<span class="string">&quot;Shield&quot;</span>, iEx.Shield, <span class="keyword">typeof</span>(GameObject), allowSceneObject);</span><br><span class="line">        <span class="keyword">if</span> (EditorGUI.EndChangeCheck())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//需要标记target为脏</span></span><br><span class="line">            EditorUtility.SetDirty(target);</span><br><span class="line">            <span class="comment">// EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene());</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="窗口扩展"><a href="#窗口扩展" class="headerlink" title="窗口扩展"></a>窗口扩展</h2><h3 id="Tools工具扩展"><a href="#Tools工具扩展" class="headerlink" title="Tools工具扩展"></a>Tools工具扩展</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEditor.EditorTools;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> ____DESC:      Tools(经常操作的工具)工具扩展 https://docs.unity.cn/cn/2020.3/ScriptReference/EditorTools.EditorTool.html</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EditorToolsExtender</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//[EditorTool(&quot;AA&quot;)]</span></span><br><span class="line">    <span class="comment">//class A : EditorTool</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    private void OnEnable()</span></span><br><span class="line">    <span class="comment">//    &#123;</span></span><br><span class="line">    <span class="comment">//        Debug.Log(&quot;aaa&quot;);</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//    public override void OnToolGUI(EditorWindow window)</span></span><br><span class="line">    <span class="comment">//    &#123;</span></span><br><span class="line">    <span class="comment">//        base.OnToolGUI(window);</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HierarchyWindow"><a href="#HierarchyWindow" class="headerlink" title="HierarchyWindow"></a>HierarchyWindow</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> ____DESC:      Hierarchy窗口 扩展器</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">[<span class="meta">InitializeOnLoad</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HierarchyWindowExtender</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//静态构造</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">HierarchyWindowExtender</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        EditorApplication.hierarchyWindowItemOnGUI += OnHierarchyGUI;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnHierarchyGUI</span>(<span class="params"><span class="built_in">int</span> instanceID, Rect selectionRect</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> size = <span class="number">18</span>;</span><br><span class="line">        Rect rect = <span class="keyword">new</span> Rect(selectionRect.x + selectionRect.width - size * <span class="number">1.2f</span>, selectionRect.y, size+<span class="number">10</span>, size);</span><br><span class="line">        <span class="keyword">if</span> ((EditorUtility.InstanceIDToObject(instanceID) <span class="keyword">is</span> GameObject))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//if ((EditorUtility.InstanceIDToObject(instanceID) as GameObject).TryGetComponent&lt;TriggerEvent&gt;(out TriggerEvent go))</span></span><br><span class="line">            <span class="comment">//&#123;</span></span><br><span class="line">            <span class="comment">//    if (go.isTriggerToDialogDubbing)</span></span><br><span class="line">            <span class="comment">//        GUI.Label(rect, dialogTexture);</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">            <span class="comment">//显示SpriteRenderer的sortingOrder</span></span><br><span class="line">            <span class="keyword">if</span> ((EditorUtility.InstanceIDToObject(instanceID) <span class="keyword">as</span> GameObject).TryGetComponent&lt;UnityEngine.SpriteRenderer&gt;(<span class="keyword">out</span> UnityEngine.SpriteRenderer sp))</span><br><span class="line">            &#123;</span><br><span class="line">                GUI.color = Color.green;</span><br><span class="line">                GUI.Label(rect, sp.sortingOrder.ToString());</span><br><span class="line">                GUI.color = Color.white;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//else if ((EditorUtility.InstanceIDToObject(instanceID) as GameObject).TryGetComponent&lt;MeshRenderer&gt;(out MeshRenderer mr))</span></span><br><span class="line">            <span class="comment">//&#123;</span></span><br><span class="line">            <span class="comment">//    GUI.color = Color.green;</span></span><br><span class="line">            <span class="comment">//    GUI.Label(rect, mr.sortingOrder.ToString());</span></span><br><span class="line">            <span class="comment">//    GUI.color = Color.white;</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="InspectorWindwow"><a href="#InspectorWindwow" class="headerlink" title="InspectorWindwow"></a>InspectorWindwow</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> ____DESC:      Inspector 窗口扩展</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InspectorWindwowExtender</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//[InitializeOnLoadMethod]</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ButtonTodo</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// Editor.finishedDefaultHeaderGUI += Editor_finishedDefaultHeaderGUI;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Editor_finishedDefaultHeaderGUI</span>(<span class="params">Editor obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//GameObject go = obj.target as GameObject;</span></span><br><span class="line">        <span class="comment">//if (go)</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">        <span class="comment">//    if (go.TryGetComponent&lt;SkeletonAnimation&gt;(out var spine))</span></span><br><span class="line">        <span class="comment">//    &#123;</span></span><br><span class="line">        <span class="comment">//        if (GUILayout.Button(&quot;更换Spine材质为2d 光类型&quot;))</span></span><br><span class="line">        <span class="comment">//        &#123;</span></span><br><span class="line">        <span class="comment">//            var mr = spine.GetComponent&lt;MeshRenderer&gt;();</span></span><br><span class="line">        <span class="comment">//            mr.sharedMaterial.shader = Shader.Find(&quot;Universal Render Pipeline/2D/Spine/Sprite&quot;);</span></span><br><span class="line">        <span class="comment">//            mr.shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.Off;</span></span><br><span class="line">        <span class="comment">//            mr.lightProbeUsage = UnityEngine.Rendering.LightProbeUsage.Off;</span></span><br><span class="line">        <span class="comment">//            mr.reflectionProbeUsage = UnityEngine.Rendering.ReflectionProbeUsage.Off;</span></span><br><span class="line">        <span class="comment">//            spine.addNormals = true;</span></span><br><span class="line">        <span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//    &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ProjectWindow"><a href="#ProjectWindow" class="headerlink" title="ProjectWindow"></a>ProjectWindow</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> ____DESC:      文件描述</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">[<span class="meta">InitializeOnLoad</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProjectWindowExtender</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">ProjectWindowExtender</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">//EditorApplication.projectWindowItemOnGUI += OnGUI;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnGUI</span>(<span class="params"><span class="built_in">string</span> guid, Rect selectionRect</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//if (Event.current.type != EventType.ContextClick) return;</span></span><br><span class="line">        <span class="comment">//Event.current.Use();</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>/ return;</span></span><br><span class="line">        <span class="comment">//var genericMenu = new GenericMenu();</span></span><br><span class="line">        <span class="comment">//genericMenu.AddItem(new GUIContent(&quot;MenuItem1&quot;), false, null);</span></span><br><span class="line">        <span class="comment">//genericMenu.AddItem(new GUIContent(&quot;MenuItem2&quot;), false, null);</span></span><br><span class="line">        <span class="comment">//genericMenu.ShowAsContext();</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="SceneWindow"><a href="#SceneWindow" class="headerlink" title="SceneWindow"></a>SceneWindow</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> ____DESC:      Scene窗口扩展</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SceneWindowExtender</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">InitializeOnLoadMethod</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Init</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//SceneView.duringSceneGui -= SceneView_duringSceneGui;</span></span><br><span class="line">        <span class="comment">// SceneView.duringSceneGui += SceneView_duringSceneGui;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SceneView_duringSceneGui</span>(<span class="params">SceneView obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*eg:</span></span><br><span class="line"><span class="comment">        *Handles场景视图中的自定义 3D GUI 控件和绘制操作</span></span><br><span class="line"><span class="comment">        *Handles.BeginGUI();</span></span><br><span class="line"><span class="comment">        *GUILayout.Button(&quot;aa&quot;,GUILayout.Width(50));</span></span><br><span class="line"><span class="comment">        *Handles.EndGUI();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他记录"><a href="#其他记录" class="headerlink" title="其他记录"></a>其他记录</h2><p><code>ProjectWindowUtil</code></p><p><code>EndNameEditAction</code>当完成文件命名 需要创建类继承它</p><p><code>SettingsService</code> 打开命令路径<br> <code>SettingsService.OpenProjectSettings(&quot;Project/Player&quot;);</code>&#x2F;&#x2F;打开PlayerSetging窗口界面<br> <code>EditorBuildSettings</code>获取编辑器场景设置<br> <code>EditorUtility</code>编辑器工具 打开文件 显示对话框<br> <code>EditorApplication.ExecuteMenuItem</code> 编辑器执行某个菜单命令 </p><p><code>IHasCustomMenu</code> 继承了这个接口 给编辑器”…”添加菜单</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MenuItem&quot;&gt;&lt;a href=&quot;#MenuItem&quot; class=&quot;headerlink&quot; title=&quot;MenuItem&quot;&gt;&lt;/a&gt;MenuItem&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;MenuItem(string itemName, bool isValid</summary>
      
    
    
    
    <category term="Unity" scheme="https://zeroultra.github.io/categories/Unity/"/>
    
    <category term="Editor" scheme="https://zeroultra.github.io/categories/Unity/Editor/"/>
    
    
    <category term="Unity" scheme="https://zeroultra.github.io/tags/Unity/"/>
    
    <category term="Editor" scheme="https://zeroultra.github.io/tags/Editor/"/>
    
  </entry>
  
  <entry>
    <title>AppScheme技术</title>
    <link href="https://zeroultra.github.io/2022/07-28-AppScheme%E6%8A%80%E6%9C%AF/"/>
    <id>https://zeroultra.github.io/2022/07-28-AppScheme%E6%8A%80%E6%9C%AF/</id>
    <published>2022-07-28T11:30:00.000Z</published>
    <updated>2022-07-28T11:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是Scheme"><a href="#什么是Scheme" class="headerlink" title="什么是Scheme"></a>什么是Scheme</h1><p>scheme是一种页面内跳转协议，是一种非常好的实现机制，通过定义自己的scheme协议，可以非常方便跳转app中的各个页面</p><ul><li>1.通过小程序，利用Scheme协议打开原生app</li><li>2.H5页面点击锚点，根据锚点具体跳转路径APP端跳转具体的页面</li><li>3.APP端收到服务器端下发的PUSH通知栏消息，根据消息的点击跳转路径跳转相关页面</li><li>4.APP根据URL跳转到另外一个APP指定页面</li><li>5.通过短信息中的url打开原生app</li></ul><h1 id="Unity"><a href="#Unity" class="headerlink" title="Unity"></a>Unity</h1><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>使用<code>Application.OpenURL();</code>填入对应参数即可</p><h4 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h4><p>别的app 打开unity 会响应<code>Application.deepLinkActivated</code>  </p><p><a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2020.3/ScriptReference/Application-deepLinkActivated.html">Application-deepLinkActivated - Unity 脚本 API</a></p><h1 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h1><p>可以看看之前的文章</p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/K20132014/article/details/78391638">Android导出aar插件供Unity使用以及通过android scheme启动unityApp_Zero_LJ的博客-CSDN博客</a></p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cancantrbl/p/15325341.html">利用URLScheme实现Unity跳转到其他app - cancantrbl - 博客园 (cnblogs.com)</a></p><h1 id="IOS"><a href="#IOS" class="headerlink" title="IOS"></a>IOS</h1><p>暂时不知</p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cancantrbl/p/15325341.html">利用URLScheme实现Unity跳转到其他app - cancantrbl - 博客园 (cnblogs.com)</a></p><h1 id="各大AppScheme收集"><a href="#各大AppScheme收集" class="headerlink" title="各大AppScheme收集"></a>各大AppScheme收集</h1><p>更新 <a target="_blank" rel="noopener" href="https://gist.github.com/JamesHopbourn/046bc341e7debfd0c86e3b388d983c53">含参数的 URL Scheme 收集.md (github.com)</a></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hzhnzmyz/article/details/119149058">https://blog.csdn.net/hzhnzmyz/article/details/119149058</a></p><p><a target="_blank" rel="noopener" href="https://xydida.com/2020/10/1/notes/APP-URL-Scheme/">一些常用APP的URL Scheme | Hui Wang’s Blog (xydida.com)</a></p><p>IOS <a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv12371050">iOS快捷指令URL Scheme 之 系统操作V1.0(更新于2021年7月28日) - 哔哩哔哩 (bilibili.com)</a></p><h4 id="QQ"><a href="#QQ" class="headerlink" title="QQ"></a>QQ</h4><table><thead><tr><th>名称</th><th>scheme</th></tr></thead><tbody><tr><td>打开qq</td><td>mqq:&#x2F;&#x2F;</td></tr><tr><td>打开QQ群</td><td>mqqapi:&#x2F;&#x2F;card&#x2F;show_pslcard?src_type&#x3D;internal&amp;version&#x3D;1&amp;card_type&#x3D;group&amp;uin&#x3D;QQ群号</td></tr><tr><td>打开联系人</td><td>mqqapi:&#x2F;&#x2F;card&#x2F;show_pslcard?src_type&#x3D;internal&amp;version&#x3D;1&amp;uin&#x3D;QQ号码</td></tr><tr><td>QQ邮箱</td><td>qqmail:&#x2F;&#x2F;</td></tr><tr><td>加好友</td><td>mqqapi:&#x2F;&#x2F;card&#x2F;show_pslcard?src_type&#x3D;internal&amp;version&#x3D;1&amp;uin&#x3D;{QQ号}</td></tr><tr><td>TIM</td><td>tim:&#x2F;&#x2F;    (其他好像和qq也是一样的)</td></tr><tr><td>tim 扫一扫</td><td>tim:&#x2F;&#x2F;qrcode&#x2F;scan_qrcode?version&#x3D;1&amp;src_type&#x3D;app</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h4 id="微信"><a href="#微信" class="headerlink" title="微信"></a>微信</h4><table><thead><tr><th>打开微信</th><th>weixin:&#x2F;&#x2F;</th></tr></thead><tbody><tr><td>扫一扫</td><td>weixin:&#x2F;&#x2F;scanqrcode  好像没用 听说是微信把很多scheme 都封了</td></tr><tr><td>企业微信</td><td>wxwork:&#x2F;&#x2F;</td></tr><tr><td></td><td></td></tr></tbody></table><h4 id="BiliBili"><a href="#BiliBili" class="headerlink" title="BiliBili"></a>BiliBili</h4><table><thead><tr><th>打开</th><th>bilibili:&#x2F;&#x2F;</th><th></th></tr></thead><tbody><tr><td>打开主页</td><td>bilibili:&#x2F;&#x2F;home</td><td></td></tr><tr><td>搜索视频</td><td>bilibili:&#x2F;&#x2F;search?keyword&#x3D;视频名称  可以以直接填写av bv号</td><td></td></tr><tr><td>视频播放页面</td><td>bilibili:&#x2F;&#x2F;video&#x2F;av  or  bv</td><td></td></tr><tr><td>扫一扫</td><td>bilibili:&#x2F;&#x2F;qrcode</td><td></td></tr><tr><td>个人中心</td><td>bilibili:&#x2F;&#x2F;user_center</td><td></td></tr><tr><td>UID用户页面</td><td>bilibili:&#x2F;&#x2F;space&#x2F;uid</td><td></td></tr><tr><td>打开直播间</td><td>bilibili:&#x2F;&#x2F;live&#x2F;id</td><td></td></tr><tr><td>我的收藏</td><td>bilibili:&#x2F;&#x2F;main&#x2F;favorite</td><td></td></tr><tr><td>番剧</td><td>bilibili:&#x2F;&#x2F;bangumi&#x2F;season&#x2F;seansonid</td><td></td></tr></tbody></table><h4 id="支付宝"><a href="#支付宝" class="headerlink" title="支付宝"></a>支付宝</h4><table><thead><tr><th>付款码</th><th>alipay:&#x2F;&#x2F;platformapi&#x2F;startapp?appId&#x3D;20000056</th><th></th></tr></thead><tbody><tr><td>扫一扫</td><td>alipay:&#x2F;&#x2F;platformapi&#x2F;startapp?appId&#x3D;10000007</td><td></td></tr><tr><td>乘车码</td><td>alipay:&#x2F;&#x2F;platformapi&#x2F;startapp?appId&#x3D;200011235</td><td></td></tr><tr><td>红包</td><td>alipays:&#x2F;&#x2F;platformapi&#x2F;startapp?appId&#x3D;88886666</td><td></td></tr><tr><td>收款</td><td>alipays:&#x2F;&#x2F;platformapi&#x2F;startapp?appId&#x3D;20000123</td><td></td></tr><tr><td>转账</td><td>alipays:&#x2F;&#x2F;platformapi&#x2F;startapp?appId&#x3D;20000221</td><td></td></tr><tr><td>手机充值</td><td>alipays:&#x2F;&#x2F;platformapi&#x2F;startapp?appId&#x3D;10000003</td><td></td></tr><tr><td>生活缴费</td><td>alipays:&#x2F;&#x2F;platformapi&#x2F;startapp?appId&#x3D;20000193</td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h4 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h4><table><thead><tr><th>电话</th><th>tel:&#x2F;&#x2F;手机号</th></tr></thead><tbody><tr><td>短信</td><td>sms:&#x2F;&#x2F;手机号</td></tr><tr><td>备忘录</td><td>mobilenotes:&#x2F;&#x2F;</td></tr><tr><td>设置</td><td>prefs:root&#x3D;SETTING</td></tr><tr><td>E-Mail</td><td>MESSAGE:&#x2F;&#x2F;</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h4 id="微博"><a href="#微博" class="headerlink" title="微博"></a>微博</h4><table><thead><tr><th>微博搜索</th><th>sinaweibo:&#x2F;&#x2F;searchall?q&#x3D;[prompt]</th></tr></thead><tbody><tr><td>扫一扫</td><td>sinaweibo:&#x2F;&#x2F;qrcode</td></tr><tr><td>发微博</td><td>sinaweibo:&#x2F;&#x2F;share?content&#x3D;[prompt:微博内容]</td></tr><tr><td>指定用户个人资料页</td><td>sinaweibo:&#x2F;&#x2F;userinfo?uid&#x3D;uid  (怎么找uid 微博找到用户主页 然后分析 后面数字就是uid)</td></tr><tr><td>新浪微博国际版</td><td>weibointernational:&#x2F;&#x2F;  后面的host好像都是通用的</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h4 id="Lofter"><a href="#Lofter" class="headerlink" title="Lofter"></a>Lofter</h4><table><thead><tr><th>打开Lofter</th><th>lofter:&#x2F;&#x2F;</th></tr></thead><tbody><tr><td>打开设置</td><td>lofter:&#x2F;&#x2F;set&#x2F;main</td></tr><tr><td>打开设置偏好设置</td><td>lofter:&#x2F;&#x2F;set&#x2F;main&#x2F;preference   通过解包APK查看</td></tr><tr><td>打开某个人的主页面</td><td>lofter:&#x2F;&#x2F;[id].lofter.com</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是Scheme&quot;&gt;&lt;a href=&quot;#什么是Scheme&quot; class=&quot;headerlink&quot; title=&quot;什么是Scheme&quot;&gt;&lt;/a&gt;什么是Scheme&lt;/h1&gt;&lt;p&gt;scheme是一种页面内跳转协议，是一种非常好的实现机制，通过定义自己的scheme</summary>
      
    
    
    
    <category term="其他" scheme="https://zeroultra.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="Scheme" scheme="https://zeroultra.github.io/tags/Scheme/"/>
    
  </entry>
  
  <entry>
    <title>Unity Asset一生</title>
    <link href="https://zeroultra.github.io/2022/04-12-2022-4-12-Unity-Asset%E7%9A%84%E4%B8%80%E7%94%9F/"/>
    <id>https://zeroultra.github.io/2022/04-12-2022-4-12-Unity-Asset%E7%9A%84%E4%B8%80%E7%94%9F/</id>
    <published>2022-04-12T02:07:21.000Z</published>
    <updated>2022-04-12T02:07:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>选自Unity官方直播 高川</p><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Wv41167i2?share_source=copy_web">Unity Asset的一生</a></p><p>[知乎](<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/411946807">[Unity]Asset简介 - 知乎 (zhihu.com)</a>)</p><hr><h3 id="Scene"><a href="#Scene" class="headerlink" title="Scene"></a>Scene</h3><p>场景相同的物体,最好是用Prefab,这样场景的描述文件要小得多,prefab指向的都是同一个内存,占用小</p><hr><h3 id="Meta"><a href="#Meta" class="headerlink" title="Meta"></a>Meta</h3><hr><h3 id="AssetBundle"><a href="#AssetBundle" class="headerlink" title="AssetBundle"></a>AssetBundle</h3><ol><li>结构 总的来说，一个AB包括2个部分：<code>包头</code>和<code>数据段</code></li></ol><blockquote><p><strong>包头</strong>：包含有关AssetBundle 的信息，比如标识符、压缩类型和内容清单（manifest：manifest是一个用对象名字做key的查找表），每个条目都提供一个字节索引，该索引指示在AssetBundle的数据段中可以找到给定对象的位置。<br>在大多数平台，这个查找表是用平衡搜索树实现的。（除了Windows和OSX派生的平台（包括IOS平台）是用红黑树实现）。因此，构建这个清单的时间消耗会随着ab内的资源数量的增加而线性增加。</p><p><strong>数据段</strong>：通过序列化AB内的资源的原生数据。<br>- 如果用<strong>LZMA</strong>压缩，将压缩<strong>所有</strong>序列化资产的完整字节数组；<br>- 如果是<strong>LZ4</strong>压缩，每个资源都是<strong>分开压缩</strong>的；<br>- 如果没有压缩，就都保存原生字节流。</p></blockquote><ol start="2"><li><p><code>Scene</code>，它是一个单独的AssetBundle，因为它和其他的Asset的处理方式是不一样的，所以Asset和Scene是不能打到一起的，要分开打。</p></li><li><p><code>加载一个AssetBundle的时候</code>，它的头会立刻加载进内存，这个也是我们在Profiler里面经常看到的<code>SerializedFile</code>。剩下的内容，也就是Bundle里面的Asset，它是<code>按需加载</code>的。也就是说如果我们不去加载这个Asset，它是不会从包体里被加载到内存中的。但是有一个例外，就是默认的<a href="https://link.zhihu.com/?target=https://docs.unity.cn/2021.1/Documentation/Manual/AssetBundles-Cache.html">LZMA</a>的压缩，这种压缩格式用一个数据流代表整个AssetBundle，因此要读取里面任意一个Asset的时候需要解压整个数据流。</p></li><li><p><code>打包参数 DisableWriteTypeTree</code></p><p>用来做兼容,如果unity版本不同用它可以达到兼容效果,使文件变得更小，加载起来也更快一点</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162216521.png" alt="没有设置DisableWriteTypeTree"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162216522.png"></p></li></ol><p>可以看到关闭之后一个简单的cube的AB包小了很多</p><p>在Profiler中,AB的头也会缩小</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162216523.png" alt="没有设置DisableWriteTypeTree"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162216524.png"></p><p><code>方案:在打Release包的时候打包参数添加DisableWriteTypeTree,能缩小包体和内存大小</code></p><p><code>编辑器的时候不能添加该参数,否则会报错</code></p><ol start="5"><li><code>打包策略</code></li></ol><ul><li>大小尽量在1-10m之类,大小加载的都是头文件,造成头重脚轻的情况,太大对下载可能有问题</li></ul><ol start="6"><li><code>AssetBundle的识别</code></li></ol><p>当我们前后两次打出AssetBundle的时候，如何判断哪些AssetBundle是有差异的，哪些AssetBundle是没有发生变化的呢？</p><p><code>很多人会通过计算两次打出来AssetBundle的md5来判断是否发生变化，实际上这种方式是不推荐的</code>。因为在Unity打包的过程中，有一些因素是不稳定的，可能导致你两次打包之后的AssetBundle，虽然你里面的东西没有变，但是打出来的Binary不是严格一致的，从而md5也是不一样的。所以不建议算打出来之后的AssetBundle。那怎么算呢？我们可以算Library里的文件的md5，或者是原文件以及对应的meta文件的md5，用这些算出来的hash做为AssetBundle的变化依据是可以的</p><h3 id="Asset的卸载"><a href="#Asset的卸载" class="headerlink" title="Asset的卸载"></a>Asset的卸载</h3><h4 id="1-UnloadUnusedAssets"><a href="#1-UnloadUnusedAssets" class="headerlink" title="1.UnloadUnusedAssets"></a>1.UnloadUnusedAssets</h4><p>它可以卸载掉那些没用的Asset，把它从内存中清除掉。它也是个Operation，它和加载一样，也是归PreloadManager处理的，它必须独成的，不能并行。因为Unity在一次Load Operation开始的阶段就已经确定了哪些Asset要被Load，所以在Load的过程中又发生了Unload这样的操作，那就会导致有些确定了使用且已经被Load的Asset被卸载掉了，就会导致最后的出错。</p><p>所以Unity现在的设计是一个<code>同步的过程，所以这个过程会造成卡顿</code>。<code>Unity在切换Scene的时候会自动调用一次UnloadUnusedAssets</code>，如果是通过Scene来管理的话就没太大的必要关心造成的卡顿了。如果不是，那就需要自己找些合适的时机去调用一下。</p><h4 id="2-AssetBundle-Unload"><a href="#2-AssetBundle-Unload" class="headerlink" title="2.AssetBundle.Unload"></a>2.AssetBundle.Unload</h4><p>它又分true和false，但是无论哪一个都和上面的不一样，它不是一个Operation，也就是不归PreloadManager管。它会遍历当前加载过的东西，然后去把它删掉。</p><p>如果是true那就是把AssetBundle和它加载出来的Asset全都一起干掉。这个在不合适的时机就有可能发生Runtime的错误。如果是false，那么只是把AssetBundle给丢掉，Asset是不会被扔掉的。那么当你第二次去加载同一个AssetBundle的时候，在内存中就会有两份Asset，因为当AssetBundle被卸载的时候，它和对应的Asset的关系就被切割掉了。所以AssetBundle不知道之前的Asset是不是还在内存中，是不是从自己这加载出来的。所以使用AssetBundle.Unload就很考验游戏的规划。</p><p>Unity为什么不做成Reference？因为Unity内部对于这些Asset实际上是没有Reference的，很多时候是通过遍历去查找，实际上不存在大家想象的ReferenceCount，它和C#其实是不太一样的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;选自Unity官方直播 高川&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://www.bilibili.com/video/BV1Wv41167i2?share_source=copy_web&quot;&gt;Unity As</summary>
      
    
    
    
    <category term="Unity" scheme="https://zeroultra.github.io/categories/Unity/"/>
    
    <category term="Engine" scheme="https://zeroultra.github.io/categories/Unity/Engine/"/>
    
    
    <category term="Unity" scheme="https://zeroultra.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity C# News</title>
    <link href="https://zeroultra.github.io/2022/02-25-2022-2-25-UnityCSharpNews/"/>
    <id>https://zeroultra.github.io/2022/02-25-2022-2-25-UnityCSharpNews/</id>
    <published>2022-02-25T05:12:37.000Z</published>
    <updated>2022-02-25T05:12:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C#"></a>C#</h1><table><thead><tr><th>C#版本</th><th>.NET版本</th><th>发布日期</th><th>特性</th></tr></thead><tbody><tr><td>C# 1.0</td><td>.NET Framework 1.0</td><td>2002-02-13</td><td>委托、事件</td></tr><tr><td>C# 1.1</td><td>.NET Framework 1.1</td><td>2003-04-24</td><td>APM（异步编程模型）</td></tr><tr><td>C# 2.0</td><td>.NET Framework 2.0</td><td>2005-11-07</td><td>泛型、匿名方法、迭代器、可空类型</td></tr><tr><td>C# 3.0</td><td>.NET Framework 3.0</td><td>2007-11-06</td><td>隐式类型</td></tr><tr><td></td><td>.NET Framework 3.5</td><td>2007-11-19</td><td>对象集合初始化、自动实现属性、匿名类型、扩展方法、查询表达式、Lambda表达式、 表达式树、分部类和方法、Linq</td></tr><tr><td>C# 4.0</td><td>.NET Framework 4.0</td><td>2010-04-12</td><td>动态绑定、命名和可选参数、泛型的协变和逆变、互操作性</td></tr><tr><td>C# 5.0</td><td>.NET Framework 4.5</td><td>2012-08-15</td><td>异步和等待(async和await)、调用方信息(Caller Information)</td></tr><tr><td>C# 6.0</td><td>.NET Framework 4.6</td><td>2015-07-20</td><td>静态导入、<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-version-history#c-version-60">C# 6 中的新增功能</a></td></tr><tr><td></td><td>.NET Core 1.0</td><td>2016-06-27</td><td></td></tr><tr><td>C# 7.0</td><td>.NET Framework 4.6.2</td><td>2016-08-02</td><td>元组、<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-version-history#c-version-70">C# 7.0 中的新增功能</a></td></tr><tr><td>C# 7.1</td><td>.NET Framework 4.7</td><td>2017-04-05</td><td></td></tr><tr><td></td><td>.NET Core 2.0</td><td>2016-08-14</td><td><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/core/whats-new/dotnet-core-2-0">.NET Core 2.0 的新增功能</a></td></tr><tr><td>C# 7.2</td><td>.NET Framework 4.7.1</td><td>2017-10-17</td><td></td></tr><tr><td>C# 7.3</td><td>.NET Framework 4.7.2</td><td>2018-04-30</td><td></td></tr><tr><td></td><td>.NET Core 2.1</td><td>2018-05-30</td><td><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/core/whats-new/dotnet-core-2-1">.NET Core 2.1 的新增功能</a></td></tr><tr><td></td><td>.NET Core 2.2</td><td>2018-12-04</td><td><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/core/whats-new/dotnet-core-2-2">.NET Core 2.2 的新增功能</a></td></tr><tr><td>C# 8.0</td><td>.NET Framework 4.8</td><td>2019-04-18</td><td><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-8">C# 8.0 中的新增功能</a></td></tr><tr><td></td><td>.NET Core 3.0</td><td>2019-09-23</td><td><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/core/whats-new/dotnet-core-3-0">.NET Core 3.0 的新增功能</a></td></tr><tr><td></td><td>.NET Core 3.1</td><td>2019-12-03</td><td><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/core/whats-new/dotnet-core-3-1">.NET Core 3.1 的新增功能</a></td></tr><tr><td>C# 9.0</td><td>.NET 5</td><td>2020-09-04</td><td><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-9">C# 9.0 中的新增功能</a></td></tr><tr><td></td><td>.NET 5</td><td>2020-10-13</td><td><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/core/dotnet-five">What’s new in .NET 5</a></td></tr><tr><td>C# 10.0</td><td>.NET 6</td><td>2021-11-09</td><td><a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/dotnet/welcome-to-csharp-10">欢迎使用 C# 10</a> <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-10">C# 10.0 中的新增功能</a></td></tr><tr><td>C# 11</td><td>.NET 7</td><td></td><td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-11">C# 11 中的新增功能 - C# 指南 - C# </a></td></tr><tr><td>C# 12</td><td>.NET 8</td><td></td><td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-12">C# 12 中的新增功能 - C# 指南 - C#</a></td></tr></tbody></table><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/MingsonZheng/p/11273700.html">C#版本与.NET版本对应关系以及各版本的特性 </a></p><h1 id="Unity"><a href="#Unity" class="headerlink" title="Unity"></a>Unity</h1><p><a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2022.1/Manual/CSharpCompiler.html">C# 编译器 - Unity 手册</a></p><h3 id="各个版本支持情况"><a href="#各个版本支持情况" class="headerlink" title="各个版本支持情况"></a>各个版本支持情况</h3><h3 id="Unity2020-3LTS"><a href="#Unity2020-3LTS" class="headerlink" title="Unity2020.3LTS"></a>Unity2020.3LTS</h3><p>支持C# 8.0</p><table><thead><tr><th><strong>.NET Standard</strong></th><th>受支持</th><th>受支持</th></tr></thead><tbody><tr><td><strong>.NET Framework</strong></td><td>受限</td><td>受支持</td></tr><tr><td><strong>.NET Core</strong></td><td>不受支持</td><td>不受支持</td></tr></tbody></table><p>不受支持的功能</p><ul><li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-8#default-interface-methods">默认接口方法</a></li><li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/ranges-indexes">索引和范围</a></li><li>异步流</li><li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/implementing-disposeasync">异步释放</a></li></ul><hr><h3 id="Unity2021-3LTS"><a href="#Unity2021-3LTS" class="headerlink" title="Unity2021.3LTS"></a>Unity2021.3LTS</h3><p>支持C#9.0</p><table><thead><tr><th><strong>.NET Standard (any version)</strong></th><th>受支持</th><th>受支持</th></tr></thead><tbody><tr><td><strong>.NET Framework (any version)</strong></td><td>Limited support</td><td>受支持</td></tr><tr><td><strong>.NET Core (any version)</strong></td><td>不受支持</td><td>不受支持</td></tr></tbody></table><p>不受支持的功能</p><ul><li>Suppress emitting localsinit flag</li><li>Covariant return types</li><li>Module Initializers</li><li>Extensible calling conventions for unmanaged function pointers</li><li>Init only setters</li></ul><hr><h3 id="Unity2022-3LTS"><a href="#Unity2022-3LTS" class="headerlink" title="Unity2022.3LTS"></a>Unity2022.3LTS</h3><table><thead><tr><th align="left">Managed plug-in compilation target</th><th align="left">API Compatibility Level:</th><th align="left"></th></tr></thead><tbody><tr><td align="left"></td><td align="left"><strong>.NET Standard 2.1</strong></td><td align="left"><strong>.NET 4.x</strong></td></tr><tr><td align="left"><strong>.NET Standard (any version)</strong></td><td align="left">受支持</td><td align="left">受支持</td></tr><tr><td align="left"><strong>.NET Framework (any version)</strong></td><td align="left">Limited support</td><td align="left">受支持</td></tr><tr><td align="left"><strong>.NET Core (any version)</strong></td><td align="left">不受支持</td><td align="left">不受支持</td></tr></tbody></table><p>C# 9.0</p><ul><li>Suppress emitting localsinit flag</li><li>Covariant return types</li><li>Module Initializers</li><li>Extensible calling conventions for unmanaged function pointers</li><li>Init only setters</li></ul><hr><h3 id="改进了Foreach"><a href="#改进了Foreach" class="headerlink" title="改进了Foreach"></a>改进了Foreach</h3><p>参考:</p><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/30334270/answer/49858731">作为Unity3D的脚本而言，c#中for是否真的比foreach效率更高？ - 知乎 (zhihu.com)</a></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/22708768">“Unity与Foreach”这章，终于要翻过去了 - 知乎 (zhihu.com)</a></p><p>主要是<strong>5.5.0b4</strong>之前Mono的Bug,导致在foreach中有装箱过程</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202204291838127.png" alt="preview"></p><p>改进之后</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202204291838671.png" alt="img"></p><h3 id="2022年6月Unity宣布将使用-Net-Core-CLR"><a href="#2022年6月Unity宣布将使用-Net-Core-CLR" class="headerlink" title="2022年6月Unity宣布将使用.Net(Core)CLR"></a>2022年6月Unity宣布将使用.Net(Core)CLR</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/T3e3kj6RCS8fnqutdTj5IA?vid=1688851236501785&deviceid=b106309a-5557-46f0-be27-251c9194eab9&version=4.0.20.6020&platform=win">.NET和Unity的未来，让用户编写高性能代码，并带来长期的稳定性与兼容性 (qq.com)</a></p><h3 id="Unity宣布2023LTS更名为Unity6-并收取安装费"><a href="#Unity宣布2023LTS更名为Unity6-并收取安装费" class="headerlink" title="Unity宣布2023LTS更名为Unity6,并收取安装费"></a>Unity宣布2023LTS更名为Unity6,并收取安装费</h3><p><a target="_blank" rel="noopener" href="https://developer.unity.cn/projects/650025a7edbc2ad788ccc1ea">Unity 收费模式和配套服务更新 - 技术专栏 - Unity官方开发者社区</a></p><p>2023年9月12日推出的安装收费政策引起行业地震</p><blockquote><p><strong>自 2024 年 1 月 1 日起，我们将根据游戏的安装量引入新的 Unity Runtime 费用</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202402281935551.png" alt="d068fb28-05c1-4b9b-b9db-0d4dffa472c6___2023_09_14_15.33.22"></p><p>此后几天Unity紧急修改了协议</p><p><a target="_blank" rel="noopener" href="https://developer.unity.cn/projects/650025a7edbc2ad788ccc1ea">Unity 收费模式和配套服务更新 - 技术专栏 - Unity官方开发者社区</a></p><p><a target="_blank" rel="noopener" href="https://developer.unity.cn/projects/6502cb70edbc2ae4d76aa346">Unity 收费模式和配套服务更新-补充声明 - 技术专栏 - Unity官方开发者社区</a></p><blockquote><p><strong>Unity Personal</strong> 订阅计划仍将保持免费，并且使用 Unity Personal 构建的游戏也不需要支付 Runtime 费用。我们还将把 Unity Personal 订阅计划的收入限制从 10 万美元提高到 20 万美元，并且将取消使用 Made with Unity 启动画面的要求。</p><p>过去 12 个月收入低于 100 万美元的游戏都无需缴纳此项费用。</p><p>对于使用 <strong>Unity Pro</strong> 和 <strong>Unity Enterprise</strong> 的创作者，我们也将根据你们的反馈更改这项政策。</p><p><strong>Runtime 费用政策仅从 2024 年及以后发布的下一个 Unity 长期支持（LTS）版本开始适用。</strong>您当前发布的游戏和正在进行的项目将不包括在内，除非您选择将它们升级到这个新的 Unity 版本。</p><p><strong>我们将确保您可以继续使用适用于您当前 Unity 编辑器版本的条款</strong>，不论您将继续使用这个版本多久。</p><p>对于需要支付 Runtime 费用的游戏，我们将为您提供两个选项：<strong>2.5% 的收入分成</strong>，或者根据每月参与游戏的新用户数量所计算的金额。这两个数字都是根据您已有的数据<strong>自行报告</strong>的。这样您就可以始终选择两者中金额更低的选项支付费用。</p></blockquote><h3 id="2024年1月2日-Unity中国版-团结引擎正式开发下载"><a href="#2024年1月2日-Unity中国版-团结引擎正式开发下载" class="headerlink" title="2024年1月2日,Unity中国版(团结引擎正式开发下载)"></a>2024年1月2日,Unity中国版(团结引擎正式开发下载)</h3><p><a target="_blank" rel="noopener" href="https://developer.unity.cn/projects/65938cdfedbc2afd89198efb">团结引擎创世版正式开放下载 - 技术专栏 - Unity官方开发者社区</a></p><p>团结引擎主要特点是可以方便开发微信小游戏和车载APP</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C&quot;&gt;&lt;a href=&quot;#C&quot; class=&quot;headerlink&quot; title=&quot;C#&quot;&gt;&lt;/a&gt;C#&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;C#版本&lt;/th&gt;
&lt;th&gt;.NET版本&lt;/th&gt;
&lt;th&gt;发布日期&lt;/th&gt;
&lt;th&gt;特性&lt;/th</summary>
      
    
    
    
    <category term="C#" scheme="https://zeroultra.github.io/categories/C/"/>
    
    
    <category term="Unity" scheme="https://zeroultra.github.io/tags/Unity/"/>
    
    <category term="C#" scheme="https://zeroultra.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Audio In Unity</title>
    <link href="https://zeroultra.github.io/2022/01-12-2022-1-12-Audio-In-Unity/"/>
    <id>https://zeroultra.github.io/2022/01-12-2022-1-12-Audio-In-Unity/</id>
    <published>2022-01-12T13:23:11.000Z</published>
    <updated>2022-01-12T13:23:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Audio-In-Unity"><a href="#Audio-In-Unity" class="headerlink" title="Audio In Unity"></a>Audio In Unity</h1><h3 id="Unity中支持的音频格式"><a href="#Unity中支持的音频格式" class="headerlink" title="Unity中支持的音频格式"></a>Unity中支持的音频格式</h3><table><thead><tr><th>MPEG layer 3</th><th>.mp3</th></tr></thead><tbody><tr><td>Ogg Vorbis</td><td>.ogg</td></tr><tr><td>Microsoft Wave</td><td>.wav</td></tr><tr><td>音频交换文件格式</td><td>.aiff &#x2F; .aif</td></tr><tr><td>Ultimate Soundtracker 模块</td><td>.mod</td></tr><tr><td>Impulse Tracker 模块</td><td>.it</td></tr><tr><td>Scream Tracker 模块</td><td>.s3m</td></tr><tr><td>FastTracker 2 模块</td><td>.xm</td></tr></tbody></table><ul><li>WAV：微软公司开发的一种声音文件格式，简单的编&#x2F;解码、普遍的认同&#x2F;支持以及无损耗存储，目前Windows上最流行的声音文件格式，资源大，不推荐</li><li>MP3：是MPEG标准中的音频部分，大小只有WAV文件的1&#x2F;10，是一种有损压缩数字音频格式，失真小，适合音质要求高的文件，例如BGM</li><li>OGG：是一种新的音频压缩格式，类似MP3的音乐格式，它是完全免费、开放和没有专利限制的。压缩比高，适合人声、音效等</li></ul><h3 id="Unity-Audio设置"><a href="#Unity-Audio设置" class="headerlink" title="Unity Audio设置"></a>Unity Audio设置</h3><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202204291837816.png" alt="image-20220113152429032"></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/357031530">Unity音频优化实践 - 知乎 (zhihu.com)</a></p><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv8598101/">ProjectSetting-音频 - 哔哩哔哩 (bilibili.com)</a></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_30432179/article/details/98021374">音频系统（一）_weixin_30432179的博客-CSDN博客</a></p><h3 id="导入设置"><a href="#导入设置" class="headerlink" title="导入设置"></a>导入设置</h3><h4 id="LoadType"><a href="#LoadType" class="headerlink" title="LoadType"></a>LoadType</h4><table><thead><tr><th>Load Type</th><th>类型</th><th>特点</th></tr></thead><tbody><tr><td>Decompress On Load</td><td>加载时解压缩</td><td>解压完整的数据进内存,<strong>需要的内存最多</strong>，适合小音频，不要对大型文件使用，会消耗最高的内存。在加载时解压缩 Vorbis 编码的声音所使用的内存量是保持压缩状态时内存使用量的 10 倍（ADPCM 编码约为 3.5 倍）</td></tr><tr><td>Compressed In Memory</td><td>压缩在内存中</td><td>压缩后的音频剪辑存储在RAM中，播放时将解压缩，CPU消耗比较大（尤其是对于Ogg &#x2F; Vorbis压缩文件），适合对较大的文件。<strong>较大的声音（保持解压的状态）</strong></td></tr><tr><td>Streaming</td><td>即时解码</td><td>播放音频的时候流式加载，好处是文件不占用内存，坏处是加载的时候对IO、CPU都会有开销。即使没有加载任何音频数据，每个音频片段也会有大约200KB的过载</td></tr></tbody></table><p><a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/current/Manual/class-AudioClip.html">音频剪辑 - Unity 手册</a></p><p><strong>Preload Audio Data:预加载音频数据</strong></p><blockquote><p>如果启用，音频剪辑将在场景加载时预先加载。如果未设置该标志，音频数据将加载到第一个 <a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/current/Manual/class-AudioSource.html">AudioSource</a>.Play()&#x2F;<a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/current/Manual/class-AudioSource.html">AudioSource</a>.PlayOneShot()，或者它可以通过加载AudioSource.LoadAudioData()，并通过再次卸载的AudioSource .UnloadAudioData()。</p><p>预加载音效数据，这个是在进入场景的时候进行预加载的，会占用内存，我们项目一般对大于10秒的文件都不进行预加载，除非有特殊情况。知道这个文件在这个场景内肯定会用到，需要提前进行预加载。其他文件都勾选预加载。</p></blockquote><h4 id="Compression-Format"><a href="#Compression-Format" class="headerlink" title="Compression Format"></a>Compression Format</h4><table><thead><tr><th><strong>Compression Format</strong></th><th>在运行时将用于声音的特定格式。请注意，可用选项取决于当前选定的构建目标。</th><th></th></tr></thead><tbody><tr><td></td><td><strong>PCM(Pulse-Code Modulation)</strong></td><td>此选项提供高质量，代价是文件内存变大，适合内存小的声音效果。</td></tr><tr><td></td><td><strong>ADPCM</strong></td><td>此格式适用于大量噪音和需要大量播放的声音（例如脚步声、撞击声、武器声音）。较之于 PCM，压缩能力提高 3.5 倍，但 CPU 使用率远低于 MP3&#x2F;Vorbis 格式，因此成为上述声音类别的最佳压缩方案。</td></tr><tr><td></td><td><strong>Vorbis&#x2F;MP3</strong></td><td>压缩使文件减小，但与 PCM 音频相比，质量降低。可通过 Quality 滑动条来配置压缩量。此格式最适合中等长度的音效和音乐。</td></tr></tbody></table><h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202204291837604.png" alt="20180815204948831"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202204291837797.jpeg" alt="20180815205002197"></p><p>总结:</p><ol><li><p>音频导出都是44100HZ,进入Unity可以使用22050HZ,质量(Quality )一般不调节,会模糊,具体可以让音频师听.</p></li><li><p><del>导出可以直接使用<code>OGG</code>格式,MP3格式在对于Loop循环播放的时候会有中断现象</del></p></li><li><p>原始使用wav格式,导入到unity会直接压缩</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202204291837827.png" alt="image-20220113142102271"></p></li><li><p>压缩格式选择</p><p>除非高要求使用<code>PCM</code>,否则都是用<code>Vorbis</code>(手机上对这个支持好)</p><p>之前2021版本之前说 MP3比vorbis格式好</p><p><a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2020.3/Manual/iphone-GettingStarted.html">iOS 开发入门 - Unity 手册</a></p><blockquote><h3 id="音频压缩"><a href="#音频压缩" class="headerlink" title="音频压缩"></a>音频压缩</h3><p>Unity 支持导入各种源格式的声音文件。但是，在导入这些文件时（音轨文件除外），它们始终会重新编码为构建目标格式。默认情况下，此格式为 Vorbis，但如果需要，可以根据平台改用其他格式（ADPCM、MP3 等）。与 Vorbis 播放相比，MP3 播放在 iPhone 上的性能稍好一些。</p></blockquote><p>后面在2022之后又说Vorbis更好些</p><p><a target="_blank" rel="noopener" href="https://docs.unity3d.com/2022.3/Documentation/Manual/ios-requirements-and-compatibility.html">Unity - Manual: iOS requirements and compatibility (unity3d.com)</a></p><blockquote><h2 id="Audio-compression"><a href="#Audio-compression" class="headerlink" title="Audio compression"></a>Audio compression</h2><p>Unity supports importing a variety of source format sound files. However, when importing the sound files (except tracker files), they’re always re-encoded to the build target format. By default, these files are in <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Vorbis">Vorbis</a> format, but you can override them to other formats (such as ADPCM, MP3) for each platform, if required. Vorbis playback provides better compression and quality for iOS compared to MP3 playback.</p></blockquote></li><li><p>加载格式选择</p><ul><li>小音频 0-2s 使用 <code>Decompress On Load</code></li><li>中等音频 &gt;2-10s 使用 <code>Compressed In Memory</code></li><li>大音频 使用 <code>Steaming</code></li></ul></li><li><p>一旦声音不使用,直接<code>删除AudioSource</code>组件是最好的方式</p></li><li><p>一般文件都启用<code>Preload Audio Data</code>预加载 大文件不用(<code>如果设置成Steaming Unity自动默认不勾选</code>) 由于播放延迟和性能消耗，不建议在播放的瞬间加载。应该控制加载在播放之前的某些方便的时间使用AudioClip对象的LoadAudioData()方法加载。也可以用AudioClip对象的UnloadAudioData()方法手动控制声音文件的内存释放。如果<code>Preload Audio Data</code>不勾选 默认在使用<code>Play</code>方法后加载</p></li></ol><h3 id="遇到的问题以及解决方案"><a href="#遇到的问题以及解决方案" class="headerlink" title="遇到的问题以及解决方案"></a>遇到的问题以及解决方案</h3><ol><li>循环声音有中断现象 把MP3声音改成OGG格式</li><li><del>播放声音有延迟 <code>Edit → Project Settings → Audio</code> → 设置DSP Buffer size为<strong>Best latency</strong>（设置 dsp 缓冲区大小以优化延迟或性能，设置一个不合适的值会导致安卓设备的电流音)[unity 音效延迟</del>](<a target="_blank" rel="noopener" href="https://blog.csdn.net/dfgjava/article/details/47105503">https://blog.csdn.net/dfgjava/article/details/47105503</a>) 不要使用这个 经验证部分手机会出现音频无法播放或者音速变慢或音调奇怪现象</li></ol><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a target="_blank" rel="noopener" href="https://blog.uwa4d.com/archives/UWA_Pipeline17.html">3分钟就能掌握的视频&#x2F;音频优化技巧！ - UWA Blog (uwa4d.com)</a></p><p><a target="_blank" rel="noopener" href="https://learn.u3d.cn/tutorial/mobile-game-optimization#61164434984fa8002175f3bc">移动游戏优化指南 - Unity中文课堂 (u3d.cn)</a></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/299799873">【内存优化】Unity音频资源优化 - 知乎 (zhihu.com)</a></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/353294079?ivk_sa=1024320u">Unity音效文件Audio Clip 导入设置 - 知乎 (zhihu.com)</a></p><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0a065da7e106">浅谈Unity中Android、iOS音频延迟 - 简书 (jianshu.com)</a></p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/RainPaint/p/13156683.html">音频(一)_音频认知(3.音频采样) - RainPainter雨画 - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Audio-In-Unity&quot;&gt;&lt;a href=&quot;#Audio-In-Unity&quot; class=&quot;headerlink&quot; title=&quot;Audio In Unity&quot;&gt;&lt;/a&gt;Audio In Unity&lt;/h1&gt;&lt;h3 id=&quot;Unity中支持的音频格式&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="Unity" scheme="https://zeroultra.github.io/categories/Unity/"/>
    
    <category term="Assets" scheme="https://zeroultra.github.io/categories/Unity/Assets/"/>
    
    
    <category term="Unity" scheme="https://zeroultra.github.io/tags/Unity/"/>
    
    <category term="Audio" scheme="https://zeroultra.github.io/tags/Audio/"/>
    
  </entry>
  
  <entry>
    <title>Unity上架GooglePlay 未完待续...</title>
    <link href="https://zeroultra.github.io/2022/01-11-2022-1-11-Unity%E4%B8%8A%E6%9E%B6GooglePlay/"/>
    <id>https://zeroultra.github.io/2022/01-11-2022-1-11-Unity%E4%B8%8A%E6%9E%B6GooglePlay/</id>
    <published>2022-01-11T06:12:29.000Z</published>
    <updated>2022-01-11T06:12:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前期设置"><a href="#前期设置" class="headerlink" title="前期设置"></a>前期设置</h1><ol><li><h4 id="科学上网-谷歌账户-成为Google开发者"><a href="#科学上网-谷歌账户-成为Google开发者" class="headerlink" title="科学上网 谷歌账户 成为Google开发者"></a>科学上网 谷歌账户 成为Google开发者</h4><p><a target="_blank" rel="noopener" href="https://play.google.com/intl/zh-CN/console/about/">Google Play 管理中心 | Google Play 管理中心</a></p></li><li><h4 id="JDK-安装"><a href="#JDK-安装" class="headerlink" title="JDK 安装"></a>JDK 安装</h4></li><li><h4 id="SDK-按照-务必添加"><a href="#SDK-按照-务必添加" class="headerlink" title="SDK 按照 务必添加"></a>SDK 按照 务必添加</h4><ul><li>Android Support Repository</li><li>Google Play Services</li><li>Google Repository</li></ul><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zgjllf1011/article/details/79282429">unity接入googleplay</a></p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Ronaldo-HD/p/9287621.html">Android 环境搭建与Android SDK目录介绍 - Charles-MQ - 博客园 (cnblogs.com)</a></p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kangjianwei101/p/5621238.html">Android SDK Manager和AVD Manager使用 - 康建伟 - 博客园 (cnblogs.com)</a></p></li><li><h4 id="Unity中设置"><a href="#Unity中设置" class="headerlink" title="Unity中设置"></a>Unity中设置</h4><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202204291836189.png" alt="image-20220111161520587"></p><p>只有<code>IL2CPP</code>才有64位</p><p>关于<code>ARMv7 ARM64</code></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202204291836553.png" alt="image-20220112183114981"></p><p>​<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e7b104c6b5f1">arm64、armv7、armv7s是指什么？ - 简书 (jianshu.com)</a></p><p>​<a target="_blank" rel="noopener" href="https://developer.android.google.cn/distribute/best-practices/develop/64-bit?hl=zh-cn#native-code">支持 64 位架构  | Google Play  | Android Developers</a></p></li><li><h4 id="设置keystone"><a href="#设置keystone" class="headerlink" title="设置keystone"></a>设置keystone</h4><p>用Unity自带工具就可以,切记打包出来的APK和<code>keystore</code>签名确保一致</p><p><code>keytool -list  -v -keystore aa/bb/md.keystore</code>  </p><p>CMD控制台查看签名信息</p><p>打包后apk,解压,找到<code>META-INF\CERT.RSA</code> 文件,输入命令:</p><p><code>keytool -printcert -file xxx\META-INF\CERT.RSA</code></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/willba/article/details/79476904">Android 对apk进行重签名和查看签名(window 和mac)及生成签名</a></p></li><li><h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zgjllf1011/article/details/79282429">unity接入googleplay</a></p><p><a target="_blank" rel="noopener" href="https://shuaici.blog.csdn.net/article/details/113779439">aab 大小限制</a></p><p><a target="_blank" rel="noopener" href="https://android-developers.googleblog.com/2020/11/new-android-app-bundle-and-target-api.html">Android 开发人员博客：2021 年新的 Android 应用捆绑包和目标 API 级别要求 (googleblog.com)</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前期设置&quot;&gt;&lt;a href=&quot;#前期设置&quot; class=&quot;headerlink&quot; title=&quot;前期设置&quot;&gt;&lt;/a&gt;前期设置&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;h4 id=&quot;科学上网-谷歌账户-成为Google开发者&quot;&gt;&lt;a href=&quot;#科学上网-谷歌账户-成为Goo</summary>
      
    
    
    
    <category term="Unity" scheme="https://zeroultra.github.io/categories/Unity/"/>
    
    <category term="GooglePlay" scheme="https://zeroultra.github.io/categories/Unity/GooglePlay/"/>
    
    
    <category term="Untiy" scheme="https://zeroultra.github.io/tags/Untiy/"/>
    
    <category term="GooglePlay" scheme="https://zeroultra.github.io/tags/GooglePlay/"/>
    
  </entry>
  
  <entry>
    <title>C#知识总结</title>
    <link href="https://zeroultra.github.io/2021/10-28-2021-0-28-CShape/"/>
    <id>https://zeroultra.github.io/2021/10-28-2021-0-28-CShape/</id>
    <published>2021-10-28T06:34:48.000Z</published>
    <updated>2021-10-28T06:34:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ul><li><p>泛型类 </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明泛型类 T 表示一个占位 也可以声明多个</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TTest</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    TTest&lt;<span class="built_in">int</span>&gt; testint = <span class="keyword">new</span> TTest&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">    testint.<span class="keyword">value</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    TTest&lt;<span class="built_in">string</span>&gt; teststr = <span class="keyword">new</span> TTest&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">    teststr.<span class="keyword">value</span> = <span class="string">&quot;aa&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>泛型方法</p>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>&lt;<span class="title">T</span>&gt;(<span class="params">T t</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>泛型接口</p></li><li><p>泛型约束</p><p><code>where</code></p><p>有6种</p><ol><li><code>where T :  struct</code>类型参数必须是值类型。可以指定除 Nullable 以外的任何值类型。</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TTest</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span>: <span class="title">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    TTest&lt;<span class="built_in">int</span>&gt; testint = <span class="keyword">new</span> TTest&lt;<span class="built_in">int</span>&gt;();  <span class="comment">//ok</span></span><br><span class="line">    testint.<span class="keyword">value</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    TTest&lt;<span class="built_in">object</span>&gt; teststr = <span class="keyword">new</span> TTest&lt;<span class="built_in">object</span>&gt;();  <span class="comment">//不通过</span></span><br><span class="line">    teststr.<span class="keyword">value</span> = <span class="string">&quot;aa&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p><code>where T :Class</code>类型参数必须是引用类型，包括任何类、接口、委托或数组类型 </p><p>……</p></li><li><p><code>where T: new()</code>类型参数必须具有无参数的公共构造函数。当与其他约束一起使用时，new() 约束必须最后指定。</p></li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TTest</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span>: <span class="title">new</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">T1</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">//默认有一个无参的构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">T2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//声明了别的构造函数 默认的无参构造函数就没了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">T2</span>(<span class="params"><span class="built_in">int</span> a</span>)</span></span><br><span class="line">    &#123; </span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    TTest&lt;T1&gt; test1 = <span class="keyword">new</span> TTest&lt;T1&gt;();</span><br><span class="line"></span><br><span class="line">    TTest&lt;T2&gt; test2 = <span class="keyword">new</span> TTest&lt;T2&gt;(); <span class="comment">//错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><code>where T: 基类名 </code>类型参数必须是指定的基类或派生自指定的基类。</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TTest</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span>: <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">T1</span>:<span class="title">MonoBehaviour</span></span><br><span class="line">&#123; </span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">T2</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    TTest&lt;T1&gt; test1 = <span class="keyword">new</span> TTest&lt;T1&gt;();</span><br><span class="line"></span><br><span class="line">    TTest&lt;T2&gt; test2 = <span class="keyword">new</span> TTest&lt;T2&gt;(); <span class="comment">//错误 不是派生子MonoBehaviour</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><p><code>where T  接口名</code> 类型参数必须是指定的接口或实现指定的接口。可以指定多个接口约束。约束接口也可以是泛型的。</p></li><li><p><code>where T U</code>  为 T 提供的类型参数必须是为 U 提供的参数或派生自为 U 提供的参数。这称为裸类型约束.</p></li></ol>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TTest</span>&lt;<span class="title">T</span>,<span class="title">U</span>&gt; <span class="keyword">where</span> <span class="title">T</span>: <span class="title">U</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> T <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">T1</span>:<span class="title">MonoBehaviour</span></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">T2</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">TTest&lt;T1,MonoBehaviour&gt; test1 = <span class="keyword">new</span> TTest&lt;T1,MonoBehaviour&gt;();</span><br><span class="line"></span><br><span class="line">TTest&lt;T2,MonoBehaviour&gt; test2 = <span class="keyword">new</span> TTest&lt;T2, MonoBehaviour&gt;(); <span class="comment">//错误 不是派生子MonoBehaviour</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><table><thead><tr><th>BindingFlags</th><th>枚举类型</th></tr></thead><tbody><tr><td>BindingFlags.IgnoreCase</td><td>表示忽略 name 的大小写，不应考虑成员名的大小写</td></tr><tr><td>BindingFlags.DeclaredOnly</td><td>只应考虑在所提供类型的层次结构级别上声明的成员。不考虑继承成员。</td></tr><tr><td>BindingFlags.Instance</td><td>只搜索实例成员</td></tr><tr><td>BindingFlags.Static</td><td>只搜索静态成员</td></tr><tr><td>BindingFlags.Public</td><td>只搜索公共成员</td></tr><tr><td>BindingFlags.NonPublic</td><td>只搜索非公共成员</td></tr><tr><td>BindingFlags.FlattenHierarchy</td><td>应返回层次结构上的公共静态成员和受保护的静态成员。不返回继承类中的私有静态成员。静态成员包括字段、方法、事件和属性。不返回嵌套类型。</td></tr><tr><td>BindingFlags.InvokeMethod</td><td>表示调用方法，而不调用构造函数或类型初始值设定项。对 SetField 或 SetProperty 无效。</td></tr><tr><td>BindingFlags.CreateInstance</td><td>表示调用构造函数。忽略 name。对其他调用标志无效。</td></tr><tr><td>BindingFlags.GetField</td><td>表示获取字段值</td></tr><tr><td>BindingFlags.SetField</td><td>表示设置字段值。</td></tr><tr><td>BindingFlags.GetProperty</td><td>表示获取属性。</td></tr><tr><td>BindingFlags.SetProperty</td><td>表示设置属性。</td></tr></tbody></table><p>BindingFlags.Public|BindingFlags.Instance 默认查找public、instance内容<br>BindingFlags.NonPublic|BindingFlags.Instance 查找nonpublic、instance内容<br><code>BindingFlags.Instance和BindingFlags.Static二者必须有一项或者都有</code>。如果你的类是instance，就选instance，反之选static。如果两者都不选，是找不到任何方法的</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> TestType;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyTest myTest = <span class="keyword">new</span> MyTest(); <span class="comment">//实例对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取类信息</span></span><br><span class="line">        Type type1 = <span class="keyword">typeof</span>(MyTest);</span><br><span class="line">        Type type2 = (<span class="keyword">new</span> MyTest()).GetType();</span><br><span class="line">        Type type3 = Type.GetType(<span class="string">&quot;TestType.MyTest&quot;</span>); <span class="comment">//命名空间+类名</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">region</span> 获取类型的属性</span></span><br><span class="line">        Debug.Log(type1.Name);</span><br><span class="line">        Debug.Log(type1.IsAbstract);<span class="comment">//指示该类型是否是抽象类型</span></span><br><span class="line">        Debug.Log(type1.IsClass);   <span class="comment">//是否是类 </span></span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">region</span> 获取类中信息</span></span><br><span class="line">        <span class="comment">/* GetConstructor(), GetConstructors():返回ConstructorInfo类型, 用于取得该类的构造函数的信息</span></span><br><span class="line"><span class="comment">            GetEvent(), GetEvents():返回EventInfo类型,用于取得该类的事件的信息</span></span><br><span class="line"><span class="comment">            GetField(), GetFields():返回FieldInfo类型,用于取得该类的字段(成员变量)的信息</span></span><br><span class="line"><span class="comment">            GetInterface(), GetInterfaces():返回InterfaceInfo类型,用于取得该类实现的接口的信息</span></span><br><span class="line"><span class="comment">            GetMember(), GetMembers():返回MemberInfo类型,用于取得该类的所有成员的信息</span></span><br><span class="line"><span class="comment">            GetMethod(), GetMethods():返回MethodInfo类型,用于取得该类的方法的信息</span></span><br><span class="line"><span class="comment">            type1.GetEnumName :返回枚举</span></span><br><span class="line"><span class="comment">            GetProperty(), GetProperties():返回PropertyInfo类型,用于取得该类的属性的信息可以调用这些成员,其方式是调用Type的InvokeMember()方法,或者调用MethodInfo, PropertyInfo和其他类的Invoke()方法。*/</span></span><br><span class="line"></span><br><span class="line">        MemberInfo[] members = type1.GetMembers(); <span class="comment">//获取所有成员</span></span><br><span class="line">        type1.GetConstructors();  <span class="comment">//获取所有构造函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取无参数构造函数</span></span><br><span class="line">        ConstructorInfo constructorInfo = type1.GetConstructor(<span class="keyword">new</span> Type[<span class="number">0</span>]); <span class="comment">//要传入一个tpye数组 如果没有参数就是0</span></span><br><span class="line">        <span class="comment">//调用构造函数 实例化一个对象</span></span><br><span class="line">        <span class="keyword">var</span> obj = constructorInfo.Invoke(<span class="literal">null</span>); <span class="comment">//没有参数写null</span></span><br><span class="line">        MyTest myt = obj <span class="keyword">as</span> MyTest;</span><br><span class="line">        Debug.Log(<span class="string">$&quot;---<span class="subst">&#123;myt.publicnum2&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取有参数的构造函数</span></span><br><span class="line">        ConstructorInfo constructorInfo2 = type1.GetConstructor(<span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(<span class="built_in">string</span>), <span class="keyword">typeof</span>(<span class="built_in">int</span>) &#125;); <span class="comment">//要传入一个tpye数组 参数为对应构造函数的参数</span></span><br><span class="line">        <span class="keyword">var</span> obj2 = constructorInfo2.Invoke(<span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="string">&quot;aaa&quot;</span>, <span class="number">2</span> &#125;) <span class="keyword">as</span> MyTest; <span class="comment">//传入对应实参</span></span><br><span class="line">        Debug.Log(<span class="string">$&quot;---<span class="subst">&#123;obj2.publicnum2&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取成员变量</span></span><br><span class="line">        type1.GetFields();</span><br><span class="line">        <span class="keyword">var</span> num = type1.GetField(<span class="string">&quot;num2&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> num1 = type1.GetField(<span class="string">&quot;num1&quot;</span>, BindingFlags.Instance | BindingFlags.NonPublic); <span class="comment">//反射私有成员变量</span></span><br><span class="line">        Debug.Log(num1.GetValue(myTest)); <span class="comment">//必须要设置获取对象 </span></span><br><span class="line">        num1.SetValue(myTest, <span class="number">22</span>);  <span class="comment">//设置值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取成员方法</span></span><br><span class="line">        type1.GetMethods();</span><br><span class="line">        MethodInfo methodInfo = type1.GetMethod(<span class="string">&quot;DoDebug&quot;</span>, <span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(<span class="built_in">int</span>) &#125;);</span><br><span class="line">        methodInfo.Invoke(myTest, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="number">123</span> &#125;);</span><br><span class="line">        <span class="comment">//如果是静态方法,第一个方法传入null  methodInfo.Invoke(null, new object[] &#123; 123 &#125;);</span></span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">region</span> Activator</span></span><br><span class="line">        <span class="comment">//Activator帮助我们快捷创建对象 快捷创建一个 无参数构造函数</span></span><br><span class="line">        MyTest myTest1 = Activator.CreateInstance(<span class="keyword">typeof</span>(MyTest)) <span class="keyword">as</span> MyTest;</span><br><span class="line">        <span class="comment">//有参数 直接后面传入对应参数</span></span><br><span class="line">         myTest1 = Activator.CreateInstance(<span class="keyword">typeof</span>(MyTest),<span class="string">&quot;str&quot;</span>,<span class="number">10</span>) <span class="keyword">as</span> MyTest;</span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">         <span class="meta">#<span class="keyword">region</span> Assembly</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">TestType</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyTest</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">string</span> constStr = <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> staticNum = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> publicnum2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> publicstr = <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> num1 = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> PropertyNum3 &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyTest</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyTest</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">$&quot;<span class="subst">&#123;<span class="keyword">nameof</span>(MyTest)&#125;</span> 构造函数打印参数: <span class="subst">&#123;i&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyTest</span>(<span class="params"><span class="built_in">string</span> str, <span class="built_in">int</span> i</span>) : <span class="title">this</span>(<span class="params">i</span>) <span class="comment">//this:调用该构造函数时候 先调用上一个构造函数</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">$&quot;<span class="subst">&#123;<span class="keyword">nameof</span>(MyTest)&#125;</span> 构造函数打印参数: <span class="subst">&#123;i&#125;</span> _<span class="subst">&#123;str&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoDebug</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">$&quot;<span class="subst">&#123;<span class="keyword">nameof</span>(MyTest)&#125;</span> DoDebug方法打印参数: <span class="subst">&#123;i&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/41282759">C#反射机制 - 知乎 (zhihu.com)</a></p><h3 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h3><ol><li>变量声明周期</li></ol><p>用<code>&#123;&#125;</code>包裹的变量 对于<code>值类型</code> 执行完 就会清空栈里面的值类型数据  对于<code>引用类型</code>会断开与堆中链接 等待下次GC回收</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> a=<span class="number">10</span>;  <span class="comment">//执行完毕会立即回收清除</span></span><br><span class="line">    <span class="built_in">string</span> str=<span class="string">&quot;aa&quot;</span>; <span class="comment">//栈上清除了 堆上还存在等待GC</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> a=<span class="number">10</span>; <span class="comment">//这里在栈中会一直出栈 又新的压入栈 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>值类型在内存中</p><p>值类型分配在内存栈中</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> TestStruct</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> a;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">object</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TestStruct tc=<span class="keyword">new</span> TestStruct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上一段代码 Struct 在内存中</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202204291836778.png" alt="image-20211028142635452"></p></li><li><p>引用类型在内存中</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span> obj=<span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">    <span class="keyword">public</span> TestStruct ts=<span class="keyword">new</span> TestStruct();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TestClass tc=<span class="keyword">new</span> TestClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202204291843060.png" alt="image-20211028143344536"></p><p><code>数组</code>也是引用类型</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> []nums=<span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">object</span>[]objs=<span class="keyword">new</span> <span class="built_in">object</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202204291836643.png" alt="image-20211028144044738"></p></li><li><p>struct 在继承接口进行里氏转换的时候会装修拆箱</p><p><code>原因是因为接口是引用类型</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IStruct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> Value &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> TestStruct: IStruct</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Value &#123;</span><br><span class="line">        <span class="keyword">get</span>;<span class="keyword">set</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">TestStruct ts1 = <span class="keyword">new</span> TestStruct();</span><br><span class="line">ts1.Value = <span class="number">10</span>;</span><br><span class="line">TestStruct ts2 = ts1;</span><br><span class="line">ts2.Value = <span class="number">100</span>;</span><br><span class="line">Debug.Log(<span class="string">$&quot;ts1:<span class="subst">&#123;ts1.Value&#125;</span> ts2:<span class="subst">&#123;ts2.Value&#125;</span>&quot;</span>);  <span class="comment">//10   100</span></span><br><span class="line"></span><br><span class="line">IStruct Its1 = ts1;</span><br><span class="line">Its1.Value = <span class="number">10</span>;</span><br><span class="line">IStruct Its2 = Its1;</span><br><span class="line">Its2.Value = <span class="number">100</span>;</span><br><span class="line">Debug.Log(<span class="string">$&quot;ts1:<span class="subst">&#123;Its1.Value&#125;</span> ts2:<span class="subst">&#123;Its2.Value&#125;</span>&quot;</span>);  <span class="comment">//100  100</span></span><br></pre></td></tr></table></figure><p>​</p></li></ol><p></p><h3 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h3><ol><li>异步编程不能加快<code>目标代码</code>的运行效率</li><li>异步方法不等于多线程</li><li>异步方法一般返回值是<code>Task&lt;T&gt;</code>或<code>Task</code>,方法名以<code>Async</code>结尾</li><li>调用异步方法一般在前面加上<code>await</code> 用于取得放回值</li><li>异步方法具有<code>传染性</code>,一个方法中如果要用<code>await</code>,则这个方法必须要用<code>async</code>修饰</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Start();</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(Thread.CurrentThread.ManagedThreadId);<span class="comment">//1</span></span><br><span class="line">            <span class="built_in">string</span> s = <span class="keyword">await</span> TestRead();</span><br><span class="line">            <span class="built_in">string</span> s2 = <span class="keyword">await</span> TestRead2();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">TestRead</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//用await获取结果</span></span><br><span class="line">            <span class="built_in">string</span> str = <span class="keyword">await</span> File.ReadAllTextAsync(<span class="string">@&quot;c:/temp/1.txt&quot;</span>);</span><br><span class="line">            <span class="comment">//一般不用</span></span><br><span class="line">            <span class="comment">//var task = File.ReadAllTextAsync(@&quot;c:/temp/1.txt&quot;);</span></span><br><span class="line">            <span class="comment">//string s = task.Result; </span></span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不用await 包装</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">TestRead2</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> File.ReadAllTextAsync(<span class="string">@&quot;c:/temp/1.txt&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>死锁情况:<a target="_blank" rel="noopener" href="http://blog.walterlv.com/post/deadlock-in-task-wait.html">使用 Task.Wait()？立刻死锁（deadlock） - walterlv</a></p><blockquote><p>明确了会造成死锁的条件和不会造成死锁的条件后，我们只需要做到以下几点即可避免死锁了：</p><ol><li>在 UI 线程，如果使用了 <code>async</code>&#x2F;<code>await</code>，就尽量不要再使用 <code>Task.Wait()</code>&#x2F;<code>Task.Result</code> 了，就一直异步一条路走到黑好了（微软称其为 Async All the Way）。</li><li>如果可能，尽量在异步任务后添加 <code>.ConfigureAwait(false)</code>；这样，异步任务后面继续执行的代码就不会回到原 UI 线程了，而是直接从线程池中再取出一个线程执行；这样，即便 UI 线程后续可能有别的原因造成阻塞，也不会产生死锁了。</li></ol></blockquote><p>第一段代码,基于.net core 3.1 windows窗口程序</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         Start();</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">     &#123;</span><br><span class="line">         Console.WriteLine(Thread.CurrentThread.ManagedThreadId);<span class="comment">//1</span></span><br><span class="line">         Test();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Test</span>()</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">await</span> Task.Delay(TimeSpan.FromSeconds(<span class="number">1f</span>));</span><br><span class="line">         Console.WriteLine(Thread.CurrentThread.ManagedThreadId);<span class="comment">//可能1,2,3,4</span></span><br><span class="line">        </span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>第二段,Untiy中编写的</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">      Debug.Log(Thread.CurrentThread.ManagedThreadId);<span class="comment">//1</span></span><br><span class="line">      Test();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Test</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">await</span> Task.Delay(TimeSpan.FromSeconds(<span class="number">1f</span>));</span><br><span class="line">      Debug.Log(Thread.CurrentThread.ManagedThreadId);<span class="comment">//1 和上面一样</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>为什么会有这两种情况</p><p>是因为Unity在框架中实现了一个<code>UnitySynchronizationContext</code>的类,该类继承<code>SynchronizationContext</code></p><p><code>ConfigureAwait</code> </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;id1:&quot;</span> + Thread.CurrentThread.ManagedThreadId); <span class="comment">//1</span></span><br><span class="line">        <span class="keyword">await</span> Test();</span><br><span class="line">        Debug.Log(<span class="string">&quot;id3:&quot;</span> + Thread.CurrentThread.ManagedThreadId);<span class="comment">//1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> Task.Run(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;id2:&quot;</span> + Thread.CurrentThread.ManagedThreadId); <span class="comment">//其他 线程</span></span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                sb.Append(<span class="string">&quot;xxxxxxxxxxxxx&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            File.WriteAllText(<span class="string">@&quot;C:\Users\Administrator\Desktop\1.txt&quot;</span>, sb.ToString());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;id1:&quot;</span> + Thread.CurrentThread.ManagedThreadId); <span class="comment">//1</span></span><br><span class="line">        <span class="keyword">await</span> Test().ConfigureAwait(<span class="literal">false</span>);</span><br><span class="line">        Debug.Log(<span class="string">&quot;id3:&quot;</span> + Thread.CurrentThread.ManagedThreadId);<span class="comment">//其他 线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> Task.Run(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;id2:&quot;</span> + Thread.CurrentThread.ManagedThreadId); <span class="comment">//其他 线程</span></span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                sb.Append(<span class="string">&quot;xxxxxxxxxxxxx&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            File.WriteAllText(<span class="string">@&quot;C:\Users\Administrator\Desktop\1.txt&quot;</span>, sb.ToString());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>await 后面需要接的类型是 <code>TaskAwaiter(INotifyCompletion)</code> 可等待对象,也就是说要实现<code>await</code>后面必须要返回一个可等待对象实例</p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33064771/article/details/115834815"> Unity 中的 async-await 咋用_东北砍王的栖息地-CSDN博客</a></p><p><code>什么是TaskCompletionSource</code></p><p>TaskCompletionSource是一个可以用来创建Task并且手动进行管理的类,我们可以手动设置结束(setResult()),或者取消(SetCancel()),或者设置异常,是一个包装类.</p><p>TaskCompletionSource<T>这是一种受你控制创建Task的方式。你可以使Task在任何你想要的时候完成，你也可以在任何地方给它一个异常让它失败。</p><p>他并不是真的启动了一个新的线程,这要看开发者是怎么处理的</p><p><code>什么是synchronizationContext</code></p><p>同步上下文,利用此对象可以实现线程间数据的同步、异步访问。包含一个<code>Send</code> 和一个<code>Post</code></p><p><code>send</code>是一个同步方法 实际就是调用了 回调</p><p><code>Post</code>是一个异步,会从其他线程中去调用,然后返回到当前线程中</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;泛型&quot;&gt;&lt;a href=&quot;#泛型&quot; class=&quot;headerlink&quot; title=&quot;泛型&quot;&gt;&lt;/a&gt;泛型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;泛型类 &lt;/p&gt;
&lt;figure class=&quot;highlight c#&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g</summary>
      
    
    
    
    <category term="C#" scheme="https://zeroultra.github.io/categories/C/"/>
    
    
    <category term="C#" scheme="https://zeroultra.github.io/tags/C/"/>
    
  </entry>
  
</feed>
