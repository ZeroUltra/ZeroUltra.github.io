<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Unity发布到Mac</title>
      <link href="/2025/10-14-Unity%E5%8F%91%E5%B8%83%E5%88%B0Mac/"/>
      <url>/2025/10-14-Unity%E5%8F%91%E5%B8%83%E5%88%B0Mac/</url>
      
        <content type="html"><![CDATA[<p>在Win的unityHub添加对应模块,可以发布Mac,但是只能打包<code>Mono</code>,IL2Cpp版本需要mac电脑. </p><h2 id="问题合集"><a href="#问题合集" class="headerlink" title="问题合集"></a>问题合集</h2><p>Unity2022.3.62f  urp环境</p><p>macos:15以上 metal</p><h3 id="无法运行"><a href="#无法运行" class="headerlink" title="无法运行"></a>无法运行</h3><ol><li><p>打开终端</p></li><li><p>输入 <code>chmod +x</code>+空格 然后把xxx.app包显示包内容把对应的直接拖进去 完整是:</p><p> <code>chmod +x /Users/tester_name/Downloads/xxx.app/Contents/MacOS/xxx</code>  (xxx是对应包名字)</p></li><li><p>如果此时还是提示无法打开(提示类似没有证书什么的) 此时在终端输入</p><p><code>sudo xattr -rd com.apple.quarantine /路径/xxx/aaa.app</code></p></li></ol><h3 id="在mac打开显示绿屏"><a href="#在mac打开显示绿屏" class="headerlink" title="在mac打开显示绿屏"></a>在mac打开显示绿屏</h3><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202510142234137.png" alt="image-20251014223441712"></p><p>关闭<code>UniversalRP.asset</code> 设置中的 Quality-&gt;HDR和Anti Aliasing (MSAA)</p><p>如果还是有问题关闭PlayerSetting-&gt;Allow HDR Display Output</p>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SDK接入记录和坑</title>
      <link href="/2024/08-11-SDK%E6%8E%A5%E5%85%A5%E8%AE%B0%E5%BD%95%E5%92%8C%E5%9D%91/"/>
      <url>/2024/08-11-SDK%E6%8E%A5%E5%85%A5%E8%AE%B0%E5%BD%95%E5%92%8C%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h2 id="ShareSDK"><a href="#ShareSDK" class="headerlink" title="ShareSDK"></a>ShareSDK</h2><p>在使用Unity接入shareSDK(版本:1690970592952126144.05)遇到的问题</p><p>按照官网中所说,只需在launcherTemplate.gradle中添加相应平台的id和key即可</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202408112120405.png" alt="image-20240811212041431"></p><p>但是在实际过程中,发现分享的时候(主要测了分享微信),提示<code>包名不对,请与开放平台包名一致</code>的错误.检查发现并没有问题, 后来发现也需要把挂到场景中脚本<code>ShareSDK</code>中<code>devinfo</code>中相应的平台id也要修改, 属实是坑, 官方文档也没写. shareSDK这个sdk做的还是比较差劲</p>]]></content>
      
      
      <categories>
          
          <category> SDk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dotween的优化以及注意事项</title>
      <link href="/2024/07-25-Dotween%E7%9A%84%E4%BC%98%E5%8C%96%E4%BB%A5%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/2024/07-25-Dotween%E7%9A%84%E4%BC%98%E5%8C%96%E4%BB%A5%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="方法记录"><a href="#方法记录" class="headerlink" title="方法记录"></a>方法记录</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target.DOMove(Vector3.one * <span class="number">1.5f</span>, <span class="number">1</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>第三个参数 <code>snaping</code> 表示是否取整 按照四舍五入规则</p><h2 id="优化记录"><a href="#优化记录" class="headerlink" title="优化记录"></a>优化记录</h2><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项:"></a>注意事项:</h2><h3 id="不要在OnDestory或者OnDisable中使用DoKill"><a href="#不要在OnDestory或者OnDisable中使用DoKill" class="headerlink" title="不要在OnDestory或者OnDisable中使用DoKill"></a>不要在OnDestory或者OnDisable中使用DoKill</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Transform tf;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    tf.DoMove(Vector3.one,<span class="number">1f</span>).SetLoops(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    tf.DoKill();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码很容易引起 <code>tf miss</code>错误,原因就是tf可能在场景跳转销毁的比这个脚本所在的物体要早,那么此时就会找不到tf,随机报错,建议做法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Transform tf;</span><br><span class="line"><span class="keyword">private</span> Tweener tw;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">   tw= tf.DoMove(Vector3.one,<span class="number">1f</span>).SetLoops(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">   tw.kill();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在重复使用一个Tween的时候-不要再OnPlay中重置值-会没效果"><a href="#在重复使用一个Tween的时候-不要再OnPlay中重置值-会没效果" class="headerlink" title="在重复使用一个Tween的时候,不要再OnPlay中重置值,会没效果"></a>在重复使用一个Tween的时候,不要再OnPlay中重置值,会没效果</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tw = target.DOMove(Vector3.one * <span class="number">2</span>, <span class="number">1f</span>).OnPlay(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这里无效</span></span><br><span class="line">    target.position = Vector3.one * <span class="number">-1f</span>;</span><br><span class="line">&#125;);</span><br><span class="line">tw.Pause();</span><br><span class="line">tw.SetAutoKill(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>可以在tween记录的时候设置默认值,那么tween每次播放的时候都是从记录前的位置开始</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Transform target;</span><br><span class="line"><span class="keyword">private</span> Tweener tw;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//记录位置</span></span><br><span class="line">    target.position = Vector3.one*<span class="number">0.5f</span>;</span><br><span class="line">    tw = target.DOMove(Vector3.one * <span class="number">2</span>, <span class="number">1f</span>).OnPlay(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;);</span><br><span class="line">    tw.Pause();</span><br><span class="line">    tw.SetAutoKill(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">[<span class="meta">NaughtyAttributes.Button</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DOStart</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//每次开始时都会从Vector3.one*0.5f;</span></span><br><span class="line">    tw.Restart();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UnityPlugins </tag>
            
            <tag> Dotween </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C# Linq</title>
      <link href="/2024/07-11-C#%20Linq/"/>
      <url>/2024/07-11-C#%20Linq/</url>
      
        <content type="html"><![CDATA[<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/linq/">C# 中的语言集成查询 (LINQ) | Microsoft Learn</a></p><p>LINQ（Language Integrated Query）是一种C#语言中的查询技术，它允许我们在代码中使用类似SQL的查询语句来操作各种数据源。</p><p>Linq有两种查询语法</p><ul><li>表达式查询 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/query-keywords">查询关键字 - C# reference | Microsoft Learn</a>   .    <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/linq/get-started/query-expression-basics">查询表达式基础 (LINQ) - C# | Microsoft Learn</a></li><li>链式查询</li></ul><h2 id="特性和注意点"><a href="#特性和注意点" class="headerlink" title="特性和注意点"></a>特性和注意点</h2><p>Linq具有延迟执行特性</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">int</span>&gt; numbers = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;() &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="comment">//此时这里的集合未执行 里面其实没有任何元素</span></span><br><span class="line"><span class="keyword">var</span> values = numbers.Select(x =&gt; x);</span><br><span class="line">numbers.Add(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//foreach 之后才执行 5也会输出</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> <span class="keyword">value</span> <span class="keyword">in</span> values)</span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="表达式查询"><a href="#表达式查询" class="headerlink" title="表达式查询"></a>表达式查询</h2><p>…</p><h2 id="链式查询"><a href="#链式查询" class="headerlink" title="链式查询"></a>链式查询</h2><p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.linq.queryable.aggregate?view=net-8.0">Queryable.Aggregate 方法 (System.Linq) | Microsoft Learn</a></p><h4 id="Where-筛选"><a href="#Where-筛选" class="headerlink" title="Where 筛选"></a>Where 筛选</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = Enumerable.Range(<span class="number">1</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">var</span> res = nums.Where(i =&gt; i % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line"><span class="comment">//也支持index</span></span><br><span class="line"><span class="keyword">var</span> res = nums.Where((item, index) =&gt; (item % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; index &gt; <span class="number">10</span>));</span><br></pre></td></tr></table></figure><h4 id="Selete-遍历"><a href="#Selete-遍历" class="headerlink" title="Selete 遍历"></a>Selete 遍历</h4><p>将每个元素投射到新表单</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = Enumerable.Range(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">//Select意思意思就是选择每个元素操作</span></span><br><span class="line">IEnumerable&lt;<span class="built_in">int</span>&gt; res = nums.Select(i =&gt; i + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> res)</span><br><span class="line">    Debug.Log(item);</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以重新映射</span></span><br><span class="line">IEnumerable&lt;<span class="built_in">string</span>&gt; strs= nums.Select(i=&gt;i.ToString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//result:2,3,4,5,6....</span></span><br></pre></td></tr></table></figure><h4 id="SelectMany-展平"><a href="#SelectMany-展平" class="headerlink" title="SelectMany  展平"></a>SelectMany  展平</h4><p>展平操作,不管多少维度,最终都会编程一个维度的集合</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">int</span>[]&gt; listNums = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>[]&gt;&#123;</span><br><span class="line">   <span class="keyword">new</span> <span class="built_in">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,</span><br><span class="line">   <span class="keyword">new</span> <span class="built_in">int</span>[]&#123;<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;,</span><br><span class="line">   <span class="keyword">new</span> <span class="built_in">int</span>[]&#123;<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">IEnumerable&lt;<span class="built_in">int</span>[]&gt; res1 = listNums.Select(item =&gt; item);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span>[] item <span class="keyword">in</span> res1)</span><br><span class="line">&#123;</span><br><span class="line">   Debug.Log(<span class="string">&quot;length:&quot;</span> + item.Length); <span class="comment">// 4 , 3 , 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IEnumerable&lt;<span class="built_in">int</span>&gt; res2 = listNums.SelectMany(item =&gt; item);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> item <span class="keyword">in</span> res2)</span><br><span class="line">&#123;</span><br><span class="line">   Debug.Log(<span class="string">&quot;v:&quot;</span> + item); <span class="comment">//1,2,3,4,10,11,12,20,21,22</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Zip-压缩-返回短"><a href="#Zip-压缩-返回短" class="headerlink" title="Zip   压缩(返回短)"></a>Zip   压缩(返回短)</h4><p>对两个序列中位置相同的两个元素进行操作,基于两个元素范围一个新元素. 最终返回的长度以短序列为准.</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = Enumerable.Range(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">string</span>[]strs=<span class="keyword">new</span> <span class="built_in">string</span>[]&#123;<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> result= strs.Zip(nums,(x,y)=&gt;x+y);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> result)</span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//result:11,22,33,44</span></span><br></pre></td></tr></table></figure><h4 id="Distinct-删除重复值"><a href="#Distinct-删除重复值" class="headerlink" title="Distinct 删除重复值"></a>Distinct 删除重复值</h4><p>删除集合中重复值</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">int</span>&gt; listnums = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;() &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> nums = listnums.Distinct();</span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> i <span class="keyword">in</span> nums)</span><br><span class="line">&#123;</span><br><span class="line">  Debug.Log(i); <span class="comment">//1,2,3,4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DistinctBy"><a href="#DistinctBy" class="headerlink" title="DistinctBy"></a>DistinctBy</h4><p>按key排除重复元素  Unity暂不支持(支持.net6789)</p> <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>[] words = [<span class="string">&quot;the&quot;</span>, <span class="string">&quot;quick&quot;</span>, <span class="string">&quot;brown&quot;</span>, <span class="string">&quot;fox&quot;</span>, <span class="string">&quot;jumped&quot;</span>, <span class="string">&quot;over&quot;</span>, <span class="string">&quot;the&quot;</span>, <span class="string">&quot;lazy&quot;</span>, <span class="string">&quot;dog&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">string</span> word <span class="keyword">in</span> words.DistinctBy(p =&gt; p.Length))</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(word);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This code produces the following output:</span></span><br><span class="line"><span class="comment">//     the</span></span><br><span class="line"><span class="comment">//     quick</span></span><br><span class="line"><span class="comment">//     jumped</span></span><br><span class="line"><span class="comment">//     over</span></span><br></pre></td></tr></table></figure><h4 id="Except-返回另一个结合没有的元素"><a href="#Except-返回另一个结合没有的元素" class="headerlink" title="Except  返回另一个结合没有的元素"></a>Except  返回另一个结合没有的元素</h4><p>对比两个集合,返回<code>当前集合中有</code>而<code>另一个集合没有</code>的元素</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] array1 = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="built_in">int</span>[] array2 = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> query = array1.Except(array2);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> query)</span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(item);<span class="comment">//4,5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ExceptBy"><a href="#ExceptBy" class="headerlink" title="ExceptBy"></a>ExceptBy</h4><p>和DistinctBy类似 Unity中暂不支持</p><h4 id="Intersect-返回集合相同元素"><a href="#Intersect-返回集合相同元素" class="headerlink" title="Intersect 返回集合相同元素"></a>Intersect 返回集合相同元素</h4><p>返回两个集合中相同元素</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] array1 = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="built_in">int</span>[] array2 = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> query = array1.Intersect(array2);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> query)</span><br><span class="line">&#123;</span><br><span class="line">   Debug.Log(item);<span class="comment">//2,3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="IntersectBy"><a href="#IntersectBy" class="headerlink" title="IntersectBy"></a>IntersectBy</h4><p>和DistinctBy类似 Unity中暂不支持</p><h4 id="Union-组合两个集合-并排除相同元素"><a href="#Union-组合两个集合-并排除相同元素" class="headerlink" title="Union 组合两个集合,并排除相同元素"></a>Union 组合两个集合,并排除相同元素</h4><p>组合两个集合,并排除相同元素</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] array1 = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="built_in">int</span>[] array2 = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> query = array1.Union(array2);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> query)</span><br><span class="line">&#123;</span><br><span class="line">   Debug.Log(item);<span class="comment">//2,3,4,5,6,7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="UnionBy"><a href="#UnionBy" class="headerlink" title="UnionBy"></a>UnionBy</h4><p>和DistinctBy类似 Unity中暂不支持</p><h4 id="OrderBy和OrderByDescending"><a href="#OrderBy和OrderByDescending" class="headerlink" title="OrderBy和OrderByDescending"></a>OrderBy和OrderByDescending</h4><p>对集合升序&#x2F;降序排序</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>[] str = <span class="keyword">new</span> <span class="built_in">string</span>[] &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;aaaaa&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> str.OrderBy(x=&gt;x.Length))</span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(item); <span class="comment">//a,bb,bbb,aaaaa</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ThenBy和ThenByDescending"><a href="#ThenBy和ThenByDescending" class="headerlink" title="ThenBy和ThenByDescending"></a>ThenBy和ThenByDescending</h4><p>次级排序</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">KVPair&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;[] kVPairs = <span class="keyword">new</span> KVPair&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;[] &#123;</span><br><span class="line">    <span class="keyword">new</span> KVPair&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;().AddData(<span class="number">4</span>,<span class="string">&quot;李四1111&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> KVPair&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;().AddData(<span class="number">2</span>,<span class="string">&quot;王二22&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> KVPair&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;().AddData(<span class="number">1</span>,<span class="string">&quot;大一1&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> KVPair&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;().AddData(<span class="number">2</span>,<span class="string">&quot;张三111&quot;</span>),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//ThenBy只能作用在次级</span></span><br><span class="line"><span class="comment">//先按照key升序 然后按照长度</span></span><br><span class="line"><span class="keyword">var</span> values = kVPairs.OrderBy(item =&gt; item.Key).ThenBy(item =&gt; item.Value.Length);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> pair <span class="keyword">in</span> values)</span><br><span class="line">&#123;</span><br><span class="line">    ZLog.LogMore(pair.Key, pair.Value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1 | 大一1</span></span><br><span class="line"><span class="comment">//2 | 王二22</span></span><br><span class="line"><span class="comment">//2 | 张三111</span></span><br><span class="line"><span class="comment">//4 | 李四1111</span></span><br></pre></td></tr></table></figure><h4 id="All、Any、Contains、Append、Prepend"><a href="#All、Any、Contains、Append、Prepend" class="headerlink" title="All、Any、Contains、Append、Prepend"></a>All、Any、Contains、Append、Prepend</h4><ul><li>All 确定是否序列中的所有元素都满足条件。</li><li>Any 确定序列中是否有元素满足条件。</li><li>Contains 确定序列是否包含指定的元素。</li><li>Append  在集合末尾追加一个元素</li><li>Prepend 在集合开头添加一个元素</li></ul><h4 id="Take、TakeWhile、Skip、-SkipWhile"><a href="#Take、TakeWhile、Skip、-SkipWhile" class="headerlink" title="Take、TakeWhile、Skip、 SkipWhile"></a>Take、TakeWhile、Skip、 SkipWhile</h4><ul><li><p>Take 按照索引拿个数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> query = table.Take(<span class="number">3</span>);<span class="comment">//取前3个元素</span></span><br></pre></td></tr></table></figure></li><li><p>TakeWhile 会取出连续满足条件的数据，直到遇到第一个不满足的数据  </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> number <span class="keyword">in</span> Enumerable.Range(<span class="number">0</span>, <span class="number">8</span>).TakeWhile(n =&gt; n &lt; <span class="number">5</span>))</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(number);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// This code produces the following output:</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure></li><li><p>Skip 按照索引跳过 </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> number <span class="keyword">in</span> Enumerable.Range(<span class="number">0</span>, <span class="number">8</span>).Skip(<span class="number">3</span>))</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(number);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// This code produces the following output:</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 7</span></span><br></pre></td></tr></table></figure></li><li><p>SkipWhile 会一直跳过连续满足条件的数据，直到遇到第一个不满足的数据就返回该元素之后的所有元素构成的序列。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> number <span class="keyword">in</span> Enumerable.Range(<span class="number">0</span>, <span class="number">8</span>).TakeWhile(n =&gt; n &lt; <span class="number">5</span>))</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(number);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// This code produces the following output:</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="Chunk"><a href="#Chunk" class="headerlink" title="Chunk"></a>Chunk</h4><ul><li>将序列的元素拆分为指定最大大小的区块。Unity中暂不适用(.net6789)</li></ul>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> chunkNumber = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span>[] chunk <span class="keyword">in</span> Enumerable.Range(<span class="number">0</span>, <span class="number">8</span>).Chunk(<span class="number">3</span>))</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;Chunk <span class="subst">&#123;chunkNumber++&#125;</span>:&quot;</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">int</span> item <span class="keyword">in</span> chunk)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;    <span class="subst">&#123;item&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Console.WriteLine();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// This code produces the following output:</span></span><br><span class="line"><span class="comment">// Chunk 1:</span></span><br><span class="line"><span class="comment">//    0</span></span><br><span class="line"><span class="comment">//    1</span></span><br><span class="line"><span class="comment">//    2</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//Chunk 2:</span></span><br><span class="line"><span class="comment">//    3</span></span><br><span class="line"><span class="comment">//    4</span></span><br><span class="line"><span class="comment">//    5</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//Chunk 3:</span></span><br><span class="line"><span class="comment">//    6</span></span><br><span class="line"><span class="comment">//    7</span></span><br></pre></td></tr></table></figure><h4 id="AsEnumerable、AsQueryable、-ToArray、-ToDictionary-、ToList"><a href="#AsEnumerable、AsQueryable、-ToArray、-ToDictionary-、ToList" class="headerlink" title="AsEnumerable、AsQueryable、 ToArray、 ToDictionary 、ToList"></a>AsEnumerable、AsQueryable、 ToArray、 ToDictionary 、ToList</h4><h4 id="Cast"><a href="#Cast" class="headerlink" title="Cast"></a>Cast</h4><p>Cast 强制转换</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Cast 如果元素不能强制转换则报错</span></span><br><span class="line">System.Collections.ArrayList fruits = <span class="keyword">new</span> System.Collections.ArrayList();</span><br><span class="line">fruits.Add(<span class="string">&quot;mango&quot;</span>);</span><br><span class="line">fruits.Add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line"><span class="comment">//fruits.Add(10); //InvalidCastException: Specified cast is not valid.</span></span><br><span class="line">fruits.Add(<span class="string">&quot;lemon&quot;</span>);</span><br><span class="line"></span><br><span class="line">IEnumerable&lt;<span class="built_in">string</span>&gt; query =</span><br><span class="line">    fruits.Cast&lt;<span class="built_in">string</span>&gt;().OrderBy(fruit =&gt; fruit).Select(fruit =&gt; fruit);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果这里不强制转换 那么会编译错误</span></span><br><span class="line"><span class="comment">//IEnumerable&lt;string&gt; query1 =</span></span><br><span class="line"><span class="comment">//    fruits.OrderBy(fruit =&gt; fruit).Select(fruit =&gt; fruit);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">string</span> fruit <span class="keyword">in</span> query)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(fruit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This code produces the following output:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// apple</span></span><br><span class="line"><span class="comment">// lemon</span></span><br><span class="line"><span class="comment">// mango</span></span><br></pre></td></tr></table></figure><h4 id="OfType-筛选指定类型集合中的元素"><a href="#OfType-筛选指定类型集合中的元素" class="headerlink" title="OfType  筛选指定类型集合中的元素"></a>OfType  筛选指定类型集合中的元素</h4><p>根据指定类型筛选集合中的元素。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">System.Collections.ArrayList fruits = <span class="keyword">new</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;Mango&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Orange&quot;</span>,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&quot;Apple&quot;</span>,</span><br><span class="line">    <span class="number">3.0</span>,</span><br><span class="line">    <span class="string">&quot;Banana&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply OfType() to the ArrayList.</span></span><br><span class="line">IEnumerable&lt;<span class="built_in">string</span>&gt; query1 = fruits.OfType&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Elements of type &#x27;string&#x27; are:&quot;</span>);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">string</span> fruit <span class="keyword">in</span> query1)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(fruit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ToLookup"><a href="#ToLookup" class="headerlink" title="ToLookup"></a>ToLookup</h4><p>按照key进行分组,每个key对应一个或者多个值,具有分组能力</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">int</span>&gt; numbers = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;() &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="comment">//按照key分组 key下存在多个值 一旦分配不能增删</span></span><br><span class="line"><span class="comment">//类似与 Dictionart&lt;key,value[]&gt; </span></span><br><span class="line"><span class="keyword">var</span> values = numbers.ToLookup(p =&gt; p, p =&gt; p.ToString() + <span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> <span class="keyword">value</span> <span class="keyword">in</span> values)</span><br><span class="line">&#123;</span><br><span class="line">    ZLog.LogMore(<span class="string">&quot;key&quot;</span>, <span class="keyword">value</span>.Key);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> <span class="keyword">value</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ZLog.LogMore(<span class="string">&quot;v&quot;</span>, item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// key | 5</span></span><br><span class="line">    <span class="comment">// v | 5a, v | 5a</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//key | 2</span></span><br><span class="line">    <span class="comment">//v | 2a</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//key | 4</span></span><br><span class="line">    <span class="comment">//v | 4a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Aggregate"><a href="#Aggregate" class="headerlink" title="Aggregate"></a>Aggregate</h4><p>聚合操作,(当前值,下一个值)&#x3D;&gt;操作</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//累加值</span></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; numbers = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="comment">//不指定初始值 acc=当前值 val下一个值</span></span><br><span class="line"><span class="built_in">int</span> sum = numbers.Aggregate((acc, val) =&gt; acc + val);</span><br><span class="line"><span class="comment">// sum = 15</span></span><br><span class="line">Debug.Log(sum);</span><br><span class="line"></span><br><span class="line"><span class="comment">//找最大值</span></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; numbers2 = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span> &#125;;</span><br><span class="line"><span class="comment">//int.MinValue初始值 acc当前值 val下一个值</span></span><br><span class="line"><span class="built_in">int</span> max = numbers2.Aggregate(<span class="built_in">int</span>.MinValue, (acc, val) =&gt; val &gt; acc ? val : acc);</span><br><span class="line"><span class="comment">//max=9</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span>[] fruits = &#123; <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;mango&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;passionfruit&quot;</span>, <span class="string">&quot;grape&quot;</span> &#125;;</span><br><span class="line"><span class="comment">//banana=初始值 longest=当前最长值 next=下一个值 fruit结果</span></span><br><span class="line"><span class="built_in">string</span> longestName = fruits.Aggregate(<span class="string">&quot;banana&quot;</span>,</span><br><span class="line">            (longest, next) =&gt;</span><br><span class="line">                next.Length &gt; longest.Length ? next : longest,</span><br><span class="line">            fruit =&gt; fruit.ToUpper());</span><br><span class="line"><span class="comment">//longestName=PASSIONFRUIT</span></span><br></pre></td></tr></table></figure><h4 id="Concat-组合两个集合"><a href="#Concat-组合两个集合" class="headerlink" title="Concat  组合两个集合"></a>Concat  组合两个集合</h4><p>组合两个集合</p><h4 id="DefaultIfEmpty"><a href="#DefaultIfEmpty" class="headerlink" title="DefaultIfEmpty"></a>DefaultIfEmpty</h4><p>如果序列为空，则返回指定序列的元素或类型参数在单一实例集合中的默认值。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DOStart</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;<span class="built_in">int</span>&gt; numbers = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">int</span> number <span class="keyword">in</span> numbers.DefaultIfEmpty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//值类型返回默认值</span></span><br><span class="line">        Debug.Log(number);<span class="comment">//0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果原色不是kong</span></span><br><span class="line">    List&lt;Pet&gt; pets = <span class="keyword">new</span> List&lt;Pet&gt;&#123; <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Barley&quot;</span>, Age=<span class="number">8</span> &#125;,</span><br><span class="line">                      <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Boots&quot;</span>, Age=<span class="number">4</span> &#125;,</span><br><span class="line">                      <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Whiskers&quot;</span>, Age=<span class="number">1</span> &#125; &#125;;</span><br><span class="line">    <span class="keyword">foreach</span> (Pet pet <span class="keyword">in</span> pets.DefaultIfEmpty())</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(pet.Name);<span class="comment">//Barley,Boots,Whiskers</span></span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Pet&gt; pets2 = <span class="keyword">new</span> List&lt;Pet&gt;();</span><br><span class="line">    <span class="keyword">foreach</span> (Pet pet2 <span class="keyword">in</span> pets.DefaultIfEmpty())</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(pet2.Name); <span class="comment">//NullReferenceException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="First-FirstOrDefault-Last-LastOrDefault"><a href="#First-FirstOrDefault-Last-LastOrDefault" class="headerlink" title="First,FirstOrDefault, Last, LastOrDefault"></a>First,FirstOrDefault, Last, LastOrDefault</h4><p>找到第一个&#x2F;最后一元素 default如果没找到则返回一个默认值</p><h4 id="Single和SingleOrDefault"><a href="#Single和SingleOrDefault" class="headerlink" title="Single和SingleOrDefault"></a>Single和SingleOrDefault</h4><p>Single判断集合是否只有一个元素 或找到集合中唯一元素,如果存在多个则报错</p><h4 id="Order-OrderByDescending"><a href="#Order-OrderByDescending" class="headerlink" title="Order,OrderByDescending"></a>Order,OrderByDescending</h4><p>排序</p><h4 id="GroupBy-GroupJoin"><a href="#GroupBy-GroupJoin" class="headerlink" title="GroupBy,GroupJoin"></a>GroupBy,GroupJoin</h4><ul><li>GroupBy 分组</li><li>GroupJoin 基于键值等同性将两个序列的元素进行关联，并对结果进行分组</li></ul><h4 id="SequenceEqual"><a href="#SequenceEqual" class="headerlink" title="SequenceEqual"></a>SequenceEqual</h4><p>根据相等比较器确定两个序列是否相等。如果自定义比较,需要实现IEqualityComparer接口</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SequenceEqualEx1</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Pet pet1 = <span class="keyword">new</span> Pet &#123; Name = <span class="string">&quot;Turbo&quot;</span>, Age = <span class="number">2</span> &#125;;</span><br><span class="line">    Pet pet2 = <span class="keyword">new</span> Pet &#123; Name = <span class="string">&quot;Peanut&quot;</span>, Age = <span class="number">8</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create two lists of pets.</span></span><br><span class="line">    List&lt;Pet&gt; pets1 = <span class="keyword">new</span> List&lt;Pet&gt; &#123; pet1, pet2 &#125;;</span><br><span class="line">    List&lt;Pet&gt; pets2 = <span class="keyword">new</span> List&lt;Pet&gt; &#123; pet1, pet2 &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> equal = pets1.SequenceEqual(pets2);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(</span><br><span class="line">        <span class="string">&quot;The lists &#123;0&#125; equal.&quot;</span>,</span><br><span class="line">        equal ? <span class="string">&quot;are&quot;</span> : <span class="string">&quot;are not&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> The lists are equal.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="Average-Min-Max-Sum-Count"><a href="#Average-Min-Max-Sum-Count" class="headerlink" title="Average , Min,Max,Sum,Count"></a>Average , Min,Max,Sum,Count</h4><ul><li>Average 平均值</li><li>Min 最小值</li><li>Max 最大值</li><li>Sum 求和</li><li>Count 计数</li></ul>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> Linq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity接入豆包AI</title>
      <link href="/2024/07-01-Unity%E6%8E%A5%E5%85%A5%E8%B1%86%E5%8C%85AI/"/>
      <url>/2024/07-01-Unity%E6%8E%A5%E5%85%A5%E8%B1%86%E5%8C%85AI/</url>
      
        <content type="html"><![CDATA[<p>官网</p><p><a target="_blank" rel="noopener" href="https://console.volcengine.com/ark/region:ark+cn-beijing/assistant">火山方舟管理控制台 (volcengine.com)</a></p><p><a target="_blank" rel="noopener" href="https://www.volcengine.com/docs/82379/1265793">Bot API V2–火山方舟大模型服务平台-火山引擎 (volcengine.com)</a></p><p>代码接入</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Newtonsoft.Json;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> TMPro;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Networking;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> ____DESC:       UITeach 逻辑界面</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">UITeach</span> : <span class="title">UIPanelBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将你的API密钥替换到这里</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> apiKey = <span class="string">&quot;eyJhbGciOiJSUzI1NiIsInR5cCxxxxxxxxxxx&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> url = <span class="string">&quot;https://ark.cn-beijing.volces.&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnAwake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        btnSend.OnClick.AddListener(OnClickSend);</span><br><span class="line">        btnBack.OnClick.AddListener(btn =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            GameEngine.SceneModule.LoadSceneAsyncFromAB(<span class="string">&quot;scenes/GameHome.unity&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        btnSetting.OnClick.AddListener(btn =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            GameEngine.UIModule.GetUIPanel&lt;UISetting&gt;().Show();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnClickSend</span>(<span class="params">ButtonPlus btn</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (InputField_Msg.text.IsNotNullOrEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> msg = InputField_Msg.text;</span><br><span class="line">            InputField_Msg.text = <span class="built_in">string</span>.Empty;</span><br><span class="line">            btn.Interactable = <span class="literal">false</span>;</span><br><span class="line">            CreateChatText(msg, <span class="literal">true</span>);</span><br><span class="line">            GameEngine.Startcoroutine(PostRequest(msg, msg =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                CreateChatText(msg, <span class="literal">false</span>);</span><br><span class="line">                btn.Interactable = <span class="literal">true</span>;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateChatText</span>(<span class="params"><span class="built_in">string</span> info, <span class="built_in">bool</span> isReverse</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> chatgo = GameObject.Instantiate(chatPrefab.gameObject, scrollView.content);</span><br><span class="line">        chatgo.gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">var</span> text = chatgo.GetComponentInChildren&lt;TextMeshProUGUI&gt;();</span><br><span class="line">        text.text = info;</span><br><span class="line">        <span class="keyword">if</span> (isReverse)</span><br><span class="line">        &#123;</span><br><span class="line">            chatgo.transform.localScale = <span class="keyword">new</span> Vector3(<span class="number">-1f</span>, <span class="number">1f</span>, <span class="number">1f</span>);</span><br><span class="line">            text.transform.localScale = <span class="keyword">new</span> Vector3(<span class="number">-1f</span>, <span class="number">1f</span>, <span class="number">1f</span>);</span><br><span class="line">            text.color = Color.blue;</span><br><span class="line">        &#125;</span><br><span class="line">        Timer.WaitOneFrameEnd(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            scrollView.verticalNormalizedPosition = <span class="number">0f</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">PostRequest</span>(<span class="params"><span class="built_in">string</span> msg, Action&lt;<span class="built_in">string</span>&gt; callback</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建JSON数据</span></span><br><span class="line">        <span class="keyword">var</span> send = <span class="keyword">new</span> SendToMessage();</span><br><span class="line">        send.messages = <span class="keyword">new</span> SendToMessage.Messages[<span class="number">1</span>];</span><br><span class="line">        send.messages[<span class="number">0</span>] = <span class="keyword">new</span> SendToMessage.Messages &#123; role = <span class="string">&quot;user&quot;</span>, content = msg &#125;;</span><br><span class="line">        send.parameters = <span class="keyword">new</span> SendToMessage.Parameters() &#123; max_tokens = <span class="number">100</span> &#125;;</span><br><span class="line">        <span class="comment">// 创建一个新的UnityWebRequest，指向指定的URL，并设置方法为POST</span></span><br><span class="line">        UnityWebRequest request = <span class="keyword">new</span> UnityWebRequest(url, <span class="string">&quot;POST&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将JSON数据转换为字节数组，并设置为请求体</span></span><br><span class="line">        <span class="built_in">byte</span>[] bodyRaw = <span class="keyword">new</span> System.Text.UTF8Encoding().GetBytes(send.ToString());</span><br><span class="line">        request.uploadHandler = <span class="keyword">new</span> UploadHandlerRaw(bodyRaw);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置请求头</span></span><br><span class="line">        request.SetRequestHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        request.SetRequestHeader(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;Bearer &quot;</span> + apiKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置下载处理器</span></span><br><span class="line">        request.downloadHandler = <span class="keyword">new</span> DownloadHandlerBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送请求并等待响应</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> request.SendWebRequest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查请求的结果</span></span><br><span class="line">        <span class="keyword">if</span> (request.result != UnityWebRequest.Result.Success)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(request.error);</span><br><span class="line">            callback?.Invoke(<span class="string">&quot;啊哦~，出现了一点问题，请在试试！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 请求成功，处理响应数据</span></span><br><span class="line">            Debug.Log(<span class="string">&quot;Response: &quot;</span> + request.downloadHandler.text);</span><br><span class="line">            ParseResponse(request.downloadHandler.text, callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ParseResponse</span>(<span class="params"><span class="built_in">string</span> jsonResponse, Action&lt;<span class="built_in">string</span>&gt; callback</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 定义与JSON结构匹配的C#类</span></span><br><span class="line">        RootObject responseObject = JsonConvert.DeserializeObject&lt;RootObject&gt;(jsonResponse);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 访问并处理解析后的数据</span></span><br><span class="line">        <span class="comment">//Debug.Log(&quot;Request ID: &quot; + responseObject.req_id);</span></span><br><span class="line">        <span class="comment">//Debug.Log(&quot;Message Content: &quot; + responseObject.choices[0].message.content);</span></span><br><span class="line">        <span class="comment">//Debug.Log(&quot;Prompt Tokens: &quot; + responseObject.usage.model_usage[0].prompt_tokens);</span></span><br><span class="line">        <span class="comment">//Debug.Log(&quot;Completion Tokens: &quot; + responseObject.usage.model_usage[0].completion_tokens);</span></span><br><span class="line">        <span class="comment">//Debug.Log(&quot;Total Tokens: &quot; + responseObject.usage.model_usage[0].total_tokens);</span></span><br><span class="line">        callback?.Invoke(responseObject.choices[<span class="number">0</span>].message.content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 定义与JSON结构匹配的C#类</span></span><br><span class="line">    [<span class="meta">System.Serializable</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SendToMessage</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> Messages[] messages;</span><br><span class="line">        <span class="comment">//public bool stream;</span></span><br><span class="line">        <span class="keyword">public</span> Parameters parameters;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">System.Serializable</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Messages</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">string</span> role;</span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">string</span> content;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">System.Serializable</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Parameters</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">int</span> max_tokens;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> str = JsonUtility.ToJson(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Serializable</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RootObject</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> req_id;</span><br><span class="line">        <span class="keyword">public</span> Choice[] choices;</span><br><span class="line">        <span class="keyword">public</span> Usage usage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Serializable</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Choice</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> index;</span><br><span class="line">        <span class="keyword">public</span> Message message;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> finish_reason;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Serializable</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Message</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> role;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Serializable</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Usage</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> ModelUsage[] model_usage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Serializable</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ModelUsage</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> prompt_tokens;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> completion_tokens;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> total_tokens;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TextMeshPro</title>
      <link href="/2024/05-03-TextMeshPro/"/>
      <url>/2024/05-03-TextMeshPro/</url>
      
        <content type="html"><![CDATA[<h1 id="TextMeshPro"><a href="#TextMeshPro" class="headerlink" title="TextMeshPro"></a>TextMeshPro</h1><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>[官方文档](<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.textmeshpro@4.0/manual/index.html">TextMesh Pro Documentation | TextMeshPro | 4.0.0-pre.2 (unity3d.com)</a>)</p><p><a target="_blank" rel="noopener" href="https://www.kodeco.com/22175776-introduction-to-textmesh-pro-in-unity/page/3">Unity 中的 TextMesh Pro 简介 |科德科 — Introduction to TextMesh Pro in Unity | Kodeco</a></p><p>[<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/457041220">UGUI图文混排一]TextMehPro(TMP)使用手册 - 知乎 (zhihu.com)</a></p><h2 id="动态-静态字体区别"><a href="#动态-静态字体区别" class="headerlink" title="动态&#x2F;静态字体区别"></a>动态&#x2F;静态字体区别</h2><p><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.textmeshpro@4.0/manual/FontAssetsDynamicFonts.html">动态字体资源 |文本网格专业版 |4.0.0-pre.2 — Dynamic fonts assets | TextMeshPro | 4.0.0-pre.2 (unity3d.com)</a></p><p>TextMeshPro现在又自动扩容机制,即指定字体自动使用字体中的文字,不用手动生成,代价是稍许消耗.</p><p>动态字体需要保留原来的字体文件(.ttf.otf),不然无法动态生成,这意味者会增大包体,而静态字体可以生成之后删除</p><p>制作中文字用得到的常用字</p><p><a target="_blank" rel="noopener" href="https://github.com/wy-luke/Unity-TextMeshPro-Chinese-Characters-Set">wy-luke&#x2F;Unity-TextMeshPro-Chinese-Characters-Set</a></p><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/91035197">Unity手游实战：从0开始SLG——TextMeshPro（三）Rich Text - 知乎 (zhihu.com)</a></p><p>[<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/458678835">UGUI图文混排二]TMP支持的富文本(Rich Text)标签 - 知乎 (zhihu.com)</a></p><p>可以查看这个类 <code>TMP_RichTextTagsCommon.cs</code></p><ul><li><p>给图文中的图加颜色 <code>&lt;sprite index=0 color=#FFEB04&gt;</code></p></li><li><p>缩进 <code>&lt;line-indent=15%&gt;</code></p></li><li><p>图文帧动画的图帧动画,只支持2帧<code>&lt;anim=&quot;first frame, last frame, frame rate&quot;&gt; </code>   eg:  <code>&lt;sprite index=0 anim=&quot;1,2,1&quot;&gt;</code>   <code>注:rate 越小越慢,最小为1</code></p></li></ul><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202405032214189.png" alt="image-20240503212053605"></p><p>这里说明一下<code>LineBreaking Following Characters</code>和<code>LineBreaking Leading Characters</code></p><p><code>LineBreaking Following Characters</code>: 里面定义的标点字符，表示<code>跟随</code>，<strong>即不能出现在句首</strong>，例如句号逗号。。。</p><p><code>LineBreaking Leading Characters</code>：定义的标点符号，表示可以启新行，<strong>能出现在句首</strong>，例如括号。。。</p><h2 id="食用方案"><a href="#食用方案" class="headerlink" title="食用方案"></a>食用方案</h2><ol><li><p>使用<code>7000字+常用符号</code>作为常用字,把<code>□</code>(unicode:\u25A1)打入进去,当文字找不到时候自动会使用□占位（前提是你的字体本身就含有该字）,然后使用工具将字体贴图压缩,作为静态字体为默认字体</p></li><li><p>找一个全字体设置为动态字体作为最后的fallback,要使用反向裁剪去除该字体中<code>7000字+常用符号</code>,只保留其他文字，(当然也要包含制作<code>7000字+常用符号</code>时miss的文字)目的是精简该字体，减少内存</p></li></ol><p>当然第二步如果不想做动态字体,也可以弄个只有生僻字的静态字体(可以参考通用规范汉子表大概8160多字 - 常用7000字)或者当运行时缺什么字就把这个字打到fallback子体中</p><p>在TMP中当文字缺失会出现如下警告</p><p><code>The character with Unicode value xxxx was not found in the [xxxx] font asset or any potential fallbacks. It was replaced by Unicode character xxxx in text object [xxxx].</code></p><p>这个警告在<strong>TMPro_UGUI_Private.cs</strong>脚本中，如果有必要可以修改源代码变成Error</p><p>还有这个<code>反向裁剪</code>该怎么实现,我参考ai给的py脚本使用<code>fonttools</code>库,但是还没验证,不知道有没有道友有明确的验证的方案.</p><p>7000字+常用符号: <a target="_blank" rel="noopener" href="https://github.com/wy-luke/Unity-TextMeshPro-Chinese-Characters-Set">https://github.com/wy-luke/Unity-TextMeshPro-Chinese-Characters-Set</a></p><p>字体贴图压缩: <a target="_blank" rel="noopener" href="https://www.lfzxb.top/unity-textmeshpro-something/">https://www.lfzxb.top/unity-textmeshpro-something/</a></p><h2 id="TextMeshPro打包AssetBundle"><a href="#TextMeshPro打包AssetBundle" class="headerlink" title="TextMeshPro打包AssetBundle"></a>TextMeshPro打包AssetBundle</h2><p>当导入TestMeshPro的时候会自动导入一些资源包，大部分都在Resources文件夹下</p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202405032214884.png" alt="image-20240503221431727"></p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202405032118547.png" alt="image-20240503211840790"></p><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><h4 id="2025年8月12日更新"><a href="#2025年8月12日更新" class="headerlink" title="2025年8月12日更新"></a>2025年8月12日更新</h4><p>现在可以不修改tmp源代码直接利用反射设置</p><h5 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在合适地方加载</span></span><br><span class="line"><span class="built_in">string</span> tmpsettingPath = <span class="string">&quot;fonts/TMP Settings.asset&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> tmpSetting = GameEngine.AssetModule.LoadAsset&lt;TMP_Settings&gt;(tmpsettingPath);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_EDITOR</span></span><br><span class="line"><span class="keyword">if</span> (tmpSetting == <span class="literal">null</span>)</span><br><span class="line">&#123; </span><br><span class="line">    ZLog.LogError(<span class="string">$&quot;未找到TMP Settings.asset path:<span class="subst">&#123;tmpsettingPath&#125;</span>,请创建并放在: <span class="subst">&#123;tmpsettingPath&#125;</span>&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">// 反射替换静态字段 s_Instance</span></span><br><span class="line"><span class="keyword">var</span> field = <span class="keyword">typeof</span>(TMP_Settings).GetField(<span class="string">&quot;s_Instance&quot;</span>, BindingFlags.NonPublic | BindingFlags.Static);</span><br><span class="line">field.SetValue(<span class="literal">null</span>, tmpSetting);</span><br></pre></td></tr></table></figure><h5 id="Editor"><a href="#Editor" class="headerlink" title="Editor"></a>Editor</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">InitializeOnLoad</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">TextMeshProSetting</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">TextMeshProSetting</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> guids = AssetDatabase.FindAssets(<span class="string">&quot;t:ScriptableObject TMP Settings&quot;</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> guid <span class="keyword">in</span> guids)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> path = AssetDatabase.GUIDToAssetPath(guid);</span><br><span class="line">            <span class="keyword">var</span> obj = AssetDatabase.LoadMainAssetAtPath(path);</span><br><span class="line">            <span class="keyword">if</span> (obj <span class="keyword">is</span> TMP_Settings _settings)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> field = <span class="keyword">typeof</span>(TMP_Settings).GetField(<span class="string">&quot;s_Instance&quot;</span>, BindingFlags.NonPublic | BindingFlags.Static);</span><br><span class="line">                field.SetValue(<span class="literal">null</span>, _settings);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ol><li>将TextMeshPro包变成本地包</li></ol><p>​<img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202405032209070.png" alt="image-20240503220912444"></p><ol start="2"><li><p>修改源代码</p><p>主要是修改TMP_Settings中</p></li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Get a singleton instance of the settings class.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TMP_Settings instance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (TMP_Settings.s_Instance == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//从这里可以看到是从Resources加载</span></span><br><span class="line">            TMP_Settings.s_Instance = Resources.Load&lt;TMP_Settings&gt;(<span class="string">&quot;TMP Settings&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//在这里会加载TMP_Setting,如果没有就导入资源包</span></span><br><span class="line">            <span class="meta">#<span class="keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">            <span class="comment">// Make sure TextMesh Pro UPM packages resources have been added to the user project</span></span><br><span class="line">            <span class="keyword">if</span> (TMP_Settings.s_Instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Open TMP Resources Importer</span></span><br><span class="line">                TMP_PackageResourceImporterWindow.ShowPackageImporterWindow();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> TMP_Settings.s_Instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>修改为</del>(不建议 建议使用更新方案)</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> TMP_Settings instance</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (TMP_Settings.s_Instance == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//TMP_Settings.s_Instance = Resources.Load&lt;TMP_Settings&gt;(&quot;TMP Settings&quot;);</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">                    <span class="comment">//使用编辑器加载</span></span><br><span class="line">                    TMP_Settings.s_Instance = AssetDatabase.LoadAssetAtPath&lt;TMP_Settings&gt;(<span class="string">&quot;Assets/Assetbundle/fonts/TMP Settings.asset&quot;</span>);</span><br><span class="line">                    <span class="comment">// Make sure TextMesh Pro UPM packages resources have been added to the user project</span></span><br><span class="line">                    <span class="keyword">if</span> (TMP_Settings.s_Instance == <span class="literal">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// Open TMP Resources Importer</span></span><br><span class="line">                        TMP_PackageResourceImporterWindow.ShowPackageImporterWindow();</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> TMP_Settings.s_Instance;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">set</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//runtime下 使用 set 赋值</span></span><br><span class="line">                TMP_Settings.s_Instance = <span class="keyword">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2025年7月9日-更新-才用AssetDatabase-FindAssets不使用固定路径-不要修改-TMP-Settings名字-当然想改名字直接把查找变成AssetDatabase-FindAssets-“t-ScriptableObject”"><a href="#2025年7月9日-更新-才用AssetDatabase-FindAssets不使用固定路径-不要修改-TMP-Settings名字-当然想改名字直接把查找变成AssetDatabase-FindAssets-“t-ScriptableObject”" class="headerlink" title="2025年7月9日 更新  才用AssetDatabase.FindAssets不使用固定路径 不要修改 TMP Settings名字(当然想改名字直接把查找变成AssetDatabase.FindAssets(“t:ScriptableObject”))"></a>2025年7月9日 更新  才用AssetDatabase.FindAssets不使用固定路径 不要修改 TMP Settings名字(当然想改名字直接把查找变成AssetDatabase.FindAssets(“t:ScriptableObject”))</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TMP_Settings instance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (TMP_Settings.s_Instance == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">            <span class="keyword">var</span> guids = AssetDatabase.FindAssets(<span class="string">&quot;t:ScriptableObject TMP Settings&quot;</span>);</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> guid <span class="keyword">in</span> guids)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> path = AssetDatabase.GUIDToAssetPath(guid);</span><br><span class="line">                <span class="keyword">var</span> obj = AssetDatabase.LoadMainAssetAtPath(path);</span><br><span class="line">                <span class="keyword">if</span> (obj <span class="keyword">is</span> TMP_Settings _settings)</span><br><span class="line">                &#123;</span><br><span class="line">                    TMP_Settings.s_Instance = _settings;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Make sure TextMesh Pro UPM packages resources have been added to the user project</span></span><br><span class="line">            <span class="keyword">if</span> (TMP_Settings.s_Instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Open TMP Resources Importer</span></span><br><span class="line">                TMP_PackageResourceImporterWindow.ShowPackageImporterWindow();</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> TMP_Settings.s_Instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//runtime下 使用 set 赋值</span></span><br><span class="line">        TMP_Settings.s_Instance = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在启动运行时</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TMP_Settings.instance = GameEngine.AssetModule.LoadAsset&lt;TMP_Settings&gt;(<span class="string">&quot;fonts/TMP Settings.asset&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="修改Font-Asset-Creator-窗口Glyph-Report存放位置"><a href="#修改Font-Asset-Creator-窗口Glyph-Report存放位置" class="headerlink" title="修改Font Asset Creator 窗口Glyph Report存放位置"></a>修改Font Asset Creator 窗口Glyph Report存放位置</h2><p>当使用Tmp的Font Asset Creator时，如果出现miss文字他会生成一个<code>Glyph Report.txt</code>文件，这个文件必须是<strong>Assets&#x2F;TextMesh Pro&#x2F;Glyph Report.txt</strong>路径，所以当你一旦更改了TextMesh Pro文件夹的名字或者位置都不会生成。</p><p>修改 <code>TMPro_FontAssetCreatorWindow.cs-&gt;UpdateRenderFeedbackWindow()</code>源代码<br>源代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// Save Missing Glyph Report file</span></span><br><span class="line"> <span class="keyword">if</span> (Directory.Exists(<span class="string">&quot;Assets/TextMesh Pro&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">     missingGlyphReport = System.Text.RegularExpressions.Regex.Replace(missingGlyphReport, <span class="string">@&quot;&lt;[^&gt;]*&gt;&quot;</span>, <span class="built_in">string</span>.Empty);</span><br><span class="line">     File.WriteAllText(<span class="string">&quot;Assets/TextMesh Pro/Glyph Report.txt&quot;</span>, missingGlyphReport);</span><br><span class="line">     AssetDatabase.Refresh();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>直接改成存放到Asset目录下,防止因为修改了文件夹而没有正确存放位置</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//if (Directory.Exists(&quot;Assets/TextMesh Pro&quot;))</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line">   missingGlyphReport = System.Text.RegularExpressions.Regex.Replace(missingGlyphReport, <span class="string">@&quot;&lt;[^&gt;]*&gt;&quot;</span>, <span class="built_in">string</span>.Empty);</span><br><span class="line">   File.WriteAllText(<span class="string">&quot;Assets/Glyph Report.txt&quot;</span>, missingGlyphReport);</span><br><span class="line">   AssetDatabase.Refresh();</span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><h2 id="如何打入□和自定义Miss-Character"><a href="#如何打入□和自定义Miss-Character" class="headerlink" title="如何打入□和自定义Miss Character"></a>如何打入□和自定义Miss Character</h2><h3 id="如何打入□"><a href="#如何打入□" class="headerlink" title="如何打入□"></a>如何打入□</h3><p>首先得确保你的源文件字体有这个□字，验证方案也很简单，直接将字体生成一个Dynamic字体然后附加到一个textmeshpro组件上，然后在文本中打入查看是否显示，能显示出来说明就有，如果没有可以找个通用的字（比如思源）做fallback。</p><p>然后讲你的txt通用字中加入□这个字（截止目前2025年9月8日  [<a target="_blank" rel="noopener" href="https://github.com/wy-luke/Unity-TextMeshPro-Chinese-Characters-Set]">https://github.com/wy-luke/Unity-TextMeshPro-Chinese-Characters-Set]</a> 这个库中已经该字 ）</p><p>接着就是常规操作了</p><h3 id="自定义Miss-Character"><a href="#自定义Miss-Character" class="headerlink" title="自定义Miss Character"></a>自定义Miss Character</h3><p>Tmp源码文件<code>TMPro_UGUI_Private.cs</code>中有如下代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unicode = unicodeChars[i].unicode = TMP_Settings.missingGlyphCharacter == <span class="number">0</span> ? <span class="number">9633</span> : TMP_Settings.missingGlyphCharacter;</span><br></pre></td></tr></table></figure><p>Tmp默认是使用了一个<code>□</code>(unicode:\u25A1,十进制是9633)来占位当miss的文字。能显示这个<code>□</code>的前提是你的字体支持这个字，当字体本身就不支持这个字时，就会发现miss时不会被任何字占位。</p><p>当字体本身就不支持<code>□</code>时，有两个解决办法</p><ul><li>添加一个支持的fallback字体</li><li>自定义一个字体来占用</li></ul><p>两种方案都很好实现，第二种方案就是在<code>TMP Setting</code>的<code>Missing Character Unicode</code>添加一个想要的unicode(十进制)</p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202509081834334.png" alt="image-20250908183432252"></p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NewMonoBehaviour</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> TextMeshProUGUI text;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        text.text = <span class="string">&quot;你好哒实际哒&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在有字体A中没有<strong>哒</strong>这个字，直接运行显示</p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202509081841593.png" alt="image-20250908183918496"></p><p>随便找个字符来替换Missing Character</p><table><thead><tr><th align="left">字符</th><th align="left">名称</th><th align="left">八进制</th><th align="left">十进制</th><th align="left">十六进制</th></tr></thead><tbody><tr><td align="left">☯</td><td align="left">U+262F</td><td align="left">23057</td><td align="left">9775</td><td align="left">0x262F</td></tr></tbody></table><p>将9775 填写在<code>TMP Setting</code>的<code>Missing Character Unicode</code>，再运行</p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202509081841719.png" alt="image-20250908184147947"></p><p>当然前提是你的字体A能支持☯这个字，如果不支持可以支持的用个fallback(比如思源)，就把这一个文字打进去</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> TextMeshPro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UnityEngine.Object和System.Object</title>
      <link href="/2024/01-01-UnityEngine.Object%E5%92%8CSystem.Object%20-%20%E5%89%AF%E6%9C%AC/"/>
      <url>/2024/01-01-UnityEngine.Object%E5%92%8CSystem.Object%20-%20%E5%89%AF%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="由编辑器引发的思考，普通类是UnityEngine-Object？"><a href="#由编辑器引发的思考，普通类是UnityEngine-Object？" class="headerlink" title="由编辑器引发的思考，普通类是UnityEngine.Object？"></a>由编辑器引发的思考，普通类是UnityEngine.Object？</h2><p>​起因是我想在Unity的Inspector界面绘制一个普通类（类似每个Mono脚本的Script字段），一个普通类应该默认继承的是<code>System.Object</code>，而使用EditorGUILayout.ObjectField绘制的是一个UnityEngine.Object,该如何绘制呢？</p><p>我写了个测试代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NewClass</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Print</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">Debug.Log(<span class="string">&quot;this NewClass&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NewMonoBehaviour2</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> UnityEngine.Object obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我将新建的普通类拖上去居然能拖入！！！那么自己建的普通类属于UnityEngine.Object吗？？？</p><p>然后我又答应了一下这个<code>obj</code>所在的父类</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NewMonoBehaviour2</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> UnityEngine.Object obj;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">Start</span>()</span></span><br><span class="line">     &#123;</span><br><span class="line">         PrintInheritanceChain(obj.GetType());</span><br><span class="line">         <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintInheritanceChain</span>(<span class="params">Type type</span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         Type baseType = type.BaseType;</span><br><span class="line">         <span class="keyword">if</span> (baseType != <span class="literal">null</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             Debug.Log(<span class="string">&quot;  继承 from: &quot;</span> + baseType.ToString());</span><br><span class="line">             PrintInheritanceChain(baseType); <span class="comment">// 递归调用，打印父类的继承链</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>打印结果是：<code>继承 form UnityEngine.TextAsset</code>-&gt;<code>继承 form UnityEngine.Object</code>-&gt;<code>继承 form System.Object</code></p><p>此时我怀疑的信了普通类也是继承了UnityEngine.Object，问了一下AI，都说普通类如果没有强声明继承System.Object，那就是隐氏继承了UnityEngine.Object</p><p>疑惑了一会我改了代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NewMonoBehaviour2</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">public</span> NewClass _newClass; <span class="comment">//自定义类 不继承MonoBehaviour</span></span><br><span class="line">     <span class="keyword">public</span> UnityEngine.Object obj;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">Start</span>()</span></span><br><span class="line">     &#123;</span><br><span class="line">         _newClass = <span class="keyword">new</span> NewClass();</span><br><span class="line">         PrintInheritanceChain(_newClass.GetType());</span><br><span class="line">         <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintInheritanceChain</span>(<span class="params">Type type</span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         Type baseType = type.BaseType;</span><br><span class="line">         <span class="keyword">if</span> (baseType != <span class="literal">null</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             Debug.Log(<span class="string">&quot;  继承 from: &quot;</span> + baseType.ToString());</span><br><span class="line">             PrintInheritanceChain(baseType); <span class="comment">// 递归调用，打印父类的继承链</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>此时打印的只有一个，就是<code>继承 form System.Object</code></p><p>查阅了资料最后得出结论</p><ul><li>不管是普通类还是继承了Mono的类，只要是C#文件，在<code>编辑器中</code>都会当成MonoScript文件来对待，把它当成Unity中可识别的资源（<a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2021.3/ScriptReference/MonoScript.html">MonoScript - Unity 脚本 API</a>）,这里就解释了为什么一开始能拖到面板上，并且打印的是继承TextAssets,UnityObject…</li><li>当在运行时，声明一个普通类需要通过<code>new</code>来声明，这个时候它是来自于.net内存中（先这么叫），所以就是继承System.Object</li></ul><h2 id="UnityEngine-Object和"><a href="#UnityEngine-Object和" class="headerlink" title="UnityEngine.Object和?.  ??"></a>UnityEngine.Object和?.  ??</h2><p>首先微软没有提供<code>?? ?.</code> 这两的重写，所以UnityEngine.Object不支持，官方文档 <a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2020.3/ScriptReference/Object.html">Object - Unity 脚本 API</a></p><p>那么在如下代码为什么发现又是可行的呢？</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NewMonoBehaviour2</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> TestMono _testMono; <span class="comment">//自定义脚本继承了MonoBehaviour</span></span><br><span class="line">    <span class="keyword">public</span> BoxCollider2D _collider2D;  <span class="comment">//Unity中的Collider</span></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//物体添加了这个mono脚本和BoxCollider2D</span></span><br><span class="line">        _testMono ??= GetComponent&lt;TestMono&gt;(); <span class="comment">//获取到了</span></span><br><span class="line">        _collider2D ??= GetComponent&lt;BoxCollider2D&gt;(); <span class="comment">//没获取到</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>从结果看，大可以这么认为，自己的脚本继承Mono属于C#层，可以使用??，但是BoxCollider2D是Unity引擎的C++层，所以不适用??，  再加上雨松的一篇文章：<a target="_blank" rel="noopener" href="https://www.xuanyusong.com/archives/4713">Unity3D研究院之UnityEngine.Object和System.Object</a>，就更确信无疑了。</p><p>但是我们知道继承的Mono也是来继承自UnityEngine.Object，官方说了不支持?? ?. 这里发现是支持的，还为自己找了借口，难道错了吗？</p><p>查看<a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2020.3/Manual/overview-of-dot-net-in-unity.html">Unity 中的 .NET 概述 - Unity 手册</a>中有说到</p><blockquote><h3 id="Unity-C-和-Unity-C-共享-UnityEngine-对象"><a href="#Unity-C-和-Unity-C-共享-UnityEngine-对象" class="headerlink" title="Unity C# 和 Unity C++ 共享 UnityEngine 对象"></a>Unity C# 和 Unity C++ 共享 UnityEngine 对象</h3><p>使用诸如 <a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2020.3/ScriptReference/Object.Destroy.html">Object.Destroy</a> 或 <a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2020.3/ScriptReference/Object.DestroyImmediate.html">Object.DestroyImmediate</a> 等方法销毁 UnityEngine.Object 派生对象时，Unity 会销毁（卸载）原生对应对象。无法使用显式调用销毁 C# 对象，因为垃圾回收器会管理内存。一旦不再引用托管对象，垃圾回收器便会收集并销毁它。</p><p>如果再次访问已销毁的 &#96;UnityEngine.Object，则 Unity 会为大多数类型重新创建原生对应对象。此重新创建行为的两个例外是 <a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2020.3/ScriptReference/MonoBehaviour.html">MonoBehaviour</a> 和 <a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2020.3/Manual/ScriptableObject">ScriptableObject</a>：一旦被销毁，Unity 便绝不会重新加载它们。</p><p>MonoBehaviour 和 ScriptableObject 会覆盖相等 (<code>==</code>) 和不相等 (<code>!=</code>) 运算符。因此，如果将销毁的 MonoBehaviour 或 ScriptableObject 与 null 进行比较，则当托管对象仍然存在且尚未进行垃圾收集时，运算符会返回 true。</p><p>因为 <code>??</code> 和 <code>?.</code> 运算符不可重载，所以它们与从 <code>UnityEngine.Object</code> 派生的对象不兼容。在托管对象仍然存在的情况下对销毁的 MonoBehaviour 或 ScriptableObject 进行使用时，这些运算符不会返回与相等和不相等运算符相同的结果。</p></blockquote><p>主要最后一句：<code>因为 </code>??<code>和</code>?.<code> 运算符不可重载，所以它们与从 UnityEngine.Object 派生的对象不兼容。在托管对象仍然存在的情况下对销毁的 MonoBehaviour 或 ScriptableObject 进行使用时，这些运算符不会返回与相等和不相等运算符相同的结果。</code></p><p>意思是如果对销毁的Mono进行<code>?? ?.</code>操作，不会返回正确的结果，代码如下</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NewMonoBehaviour2</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//自定义脚本继承了MonoBehaviour</span></span><br><span class="line">    <span class="keyword">public</span> TestMono _testMono;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//物体添加了这个mono脚本</span></span><br><span class="line">        _testMono ??= GetComponent&lt;TestMono&gt;();</span><br><span class="line">        Debug.Log(_testMono == <span class="literal">null</span>);  <span class="comment">//结果:false</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//销毁 要等一帧 际的对象销毁操作始终延迟到当前更新循环结束，但始终在渲染前完成</span></span><br><span class="line">        <span class="comment">//https://docs.unity.cn/cn/2020.3/ScriptReference/Object.Destroy.html</span></span><br><span class="line">        Destroy(_testMono); </span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        Debug.Log(_testMono == <span class="literal">null</span>); <span class="comment">//结果:true</span></span><br><span class="line">        _testMono ??= <span class="keyword">this</span>.gameObject.AddComponent&lt;TestMono&gt;();</span><br><span class="line">        Debug.Log(_testMono == <span class="literal">null</span>); <span class="comment">//结果:true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_testMono == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;testmono is null?&quot;</span>); <span class="comment">//打印了该条信息</span></span><br><span class="line">            _testMono = <span class="keyword">this</span>.gameObject.AddComponent&lt;TestMono&gt;();</span><br><span class="line">            Debug.Log(_testMono == <span class="literal">null</span>); <span class="comment">//结果:false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码结果来看，销毁了之后通过??就是不对的结果。这里的销毁时Unity引擎对Mono C++上的销毁，但是C#托管代码还在（UnityEngine.Object重写了&#x3D;&#x3D; !&#x3D;，可以通过<code>System.Object.ReferenceEquals(go, null)</code>来判断是否还存在），此时用??判断结果是不为null，所以获取不到。</p><h2 id="最后建议"><a href="#最后建议" class="headerlink" title="最后建议"></a>最后建议</h2><ul><li>对于继承<code>MonoBehaviour或者ScriptableObject </code>+Unity内置类都不要使用?? ?.    只对自己使用的普通类使用</li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity中的内置资源以及打AB包注意事项</title>
      <link href="/2024/01-01-Unity%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E8%B5%84%E6%BA%90%E4%BB%A5%E5%8F%8A%E6%89%93AB%E5%8C%85%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%20-%20%E5%89%AF%E6%9C%AC/"/>
      <url>/2024/01-01-Unity%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E8%B5%84%E6%BA%90%E4%BB%A5%E5%8F%8A%E6%89%93AB%E5%8C%85%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%20-%20%E5%89%AF%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="关于Unity中的内置资源"><a href="#关于Unity中的内置资源" class="headerlink" title="关于Unity中的内置资源"></a>关于Unity中的内置资源</h1><p>内置资源主要分为两个来源：<code>Resources/unity_builtin_extra</code> 和<code>Library/unity default resources</code></p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202401020126553.png" alt="image-20240102012629532"></p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202401020015476.png" alt="image-20240102001507173"></p><p>可以通过代码得到资源类型</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> assets = AssetDatabase.LoadAllAssetsAtPath(<span class="string">&quot;Resources/unity_builtin_extra&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> assets2 = AssetDatabase.LoadAllAssetsAtPath(<span class="string">&quot;Library/unity default resources&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li><p>Resources&#x2F;unity_builtin_extra下资源对应的guid始终为0000000000000000f000000000000000。</p></li><li><p>Library&#x2F;unity default resources下资源对应的guid始终为0000000000000000e000000000000000。</p></li></ul><h2 id="Library-unity-default-resources"><a href="#Library-unity-default-resources" class="headerlink" title="Library&#x2F;unity default resources"></a>Library&#x2F;unity default resources</h2><p>这里面资源是固定的，是一些<code>shader和GUISkin(IMGUI资源),Arial字体和一些Unity内部texture(如logo,development标记..)</code>等等，虽以<code>Library</code>开头但是在library文件夹中找不到它，<code>这个文件一定会全部打进包里，unity版本不同可能里面的也资源不同</code>。</p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202401020009365.png" alt="image-20240102000909809"></p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202401020012306.png" alt="资源"></p><h3 id="打包AssetBundle"><a href="#打包AssetBundle" class="headerlink" title="打包AssetBundle"></a>打包AssetBundle</h3><p>如果某些assetbundle包中包含了这些资源将不会的打进ab包中， 即<code>永远不会造成ab资源冗余</code>,很像unity自己打了一个ab包</p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202401020037667.png" alt="7bbaaeda323863e954df35032a0e6d6c"></p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202401020038636.png" alt="image-20240102003808039"></p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202401020038021.png" alt="image-20240102003850870"></p><p>由上图可见，我在Text组件中用了Arial字体属于<code>unity default resources</code>,不会打进ab包。同样我在gameobject_1中用了一个脚本引用了GUISkin也是没有打进ab包的(只是打了一个mono脚本)</p><h2 id="Resources-unity-builtin-extra"><a href="#Resources-unity-builtin-extra" class="headerlink" title="Resources&#x2F;unity_builtin_extra"></a>Resources&#x2F;unity_builtin_extra</h2><p>里面包括资源：Shader，Material，Texture(都是UGUI的图,看文章开头图,这些图原格式都是psd,具体可以ugui源代码)以及Sprite(UGUI的精灵图),内置资源在发布时是会按需裁剪的,影响他的大小因素(现在所知),来自Project Setting-&gt;Graphics-&gt;Always included shaders的size大小</p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202401020048876.png" alt="image-20240102004814241"></p><p>通过解包来看里面的资源(手机版暂没发现),里面都是shader</p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202401020112830.png" alt="image-20240102011228983"></p><h3 id="打包AssetBundle-1"><a href="#打包AssetBundle-1" class="headerlink" title="打包AssetBundle"></a>打包AssetBundle</h3><p>这里面的资源不会剥离,而是会随着ab包打进,如果有两个uiprefab的ab包，都引用了其中的Sprite资源(例如Background)，那么他会打进两个ab中，<code>会造成冗余,需要注意</code></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/386625317">Unity实践—Unity 内置资源独立打包 - 知乎 (zhihu.com)</a></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/669070779">Unity冗余资源全面优化 - 知乎 (zhihu.com)</a></p><p><a target="_blank" rel="noopener" href="https://blog.uwa4d.com/archives/1577.html">Unity 5.x AssetBundle零冗余解决方案 - UWA问答 | 博客 | 游戏及VR应用性能优化记录分享 | 侑虎科技 (uwa4d.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Asset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Asset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>书记：《Unity游戏优化第三版》</title>
      <link href="/2023/12-24-%E4%B9%A6%E8%AE%B0%EF%BC%9A%E3%80%8AUnity%E6%B8%B8%E6%88%8F%E4%BC%98%E5%8C%96%E7%AC%AC%E4%B8%89%E7%89%88%E3%80%8B/"/>
      <url>/2023/12-24-%E4%B9%A6%E8%AE%B0%EF%BC%9A%E3%80%8AUnity%E6%B8%B8%E6%88%8F%E4%BC%98%E5%8C%96%E7%AC%AC%E4%B8%89%E7%89%88%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<p>内容来自《Unity游戏优化第三版》，书中内容也不一定全对，有比较基础的部分，做个简要记录</p><h1 id="第二章-脚本策略"><a href="#第二章-脚本策略" class="headerlink" title="第二章:脚本策略"></a>第二章:脚本策略</h1><ul><li>获取组件采用泛型获取即：<code>GetComponent&lt;T&gt;</code></li><li>移除MonoBehaviour中空定义，即如果不需要Update OnGUI等Unity的回调函数，直接删除</li><li>避免在运行时修改Transform的父对象</li></ul><blockquote><p>在Unity早期版本中，Transform组件的引用通常是在内存中随机排列的<br>也就是在多个Transform迭代是相当慢的，会存在缓存丢失的可能</p><p>修改GameObject的父节点为另一个对象不会造成显著的性能下降，因为Transform操作起来像堆数据结构，插入和删除的速度相对较快</p><p>但是在Unity5.4以后，Transform组件的内存布局发生了很大的变化<br>Transform组件的父子关系操作起来更像动态数组，Unity尝试将所有共享相同的父元素 Transform 按顺序存储在预先分配的内存缓冲区中的内存中，并在 Hierarchy 窗口下的深度进行排序<br>这样做的好处就是可以进行更快的迭代，尤其是物理和动画系统。</p><p>缺点：<br>1.如果将一个 GameObject 的父对象重新指定为另一个对象，父对象必须将新的子对象放入预先分配的内存缓冲区中，并根据新的深度对所有这些 Transform 排序<br>2.如果没有预先分配足够的空间来容纳新的子对象，就必须扩展缓冲区，以便以深度优先的顺序容纳新的子对象</p><p>通过 Object.Instantiate() 实例化新的 GameObject 时，其默认的父节点是 null，都放在 Hierarchy的根元素下<br>这里的所有元素同样也需要分配一个缓冲区来存储他当前的元素以及以后可能添加的元素<br>如果需要<strong>立即</strong>将Transform的元素重新修改为另一个元素，刚才的缓冲区就白分配了<br><strong>尽可能使用参数，跳过缓冲区分配的步骤</strong></p></blockquote><p>​在Instantiate()Gameobject的时候,如果要进行父对象变化,可以先直接传入,避免变化</p><p>​有多个变化,尽量使用一次性变化,例如使用<code>SetPositionAndRotation</code></p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> 优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity&amp;Zapworks</title>
      <link href="/2023/07-30-Unity&amp;Zapworks/"/>
      <url>/2023/07-30-Unity&amp;Zapworks/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity使用zapworks开发webgl平台AR项目"><a href="#Unity使用zapworks开发webgl平台AR项目" class="headerlink" title="Unity使用zapworks开发webgl平台AR项目"></a>Unity使用zapworks开发webgl平台AR项目</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li><a target="_blank" rel="noopener" href="https://docs.zap.works/universal-ar/unity/">Zapworks官网</a></li><li>支持webgl,android,ios三个平台</li><li>支持的技术有:<ul><li><p>图像跟踪(Image Tracking)</p></li><li><p>面部跟踪(Face Tracking)</p></li><li><p>即时世界跟踪(Instant World Tracking)类似slma技术</p></li></ul></li><li>其他具体看官网</li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="图像识别需要训练自己的图片对象"><a href="#图像识别需要训练自己的图片对象" class="headerlink" title="图像识别需要训练自己的图片对象"></a>图像识别需要训练自己的图片对象</h3><p>​打开<code>Zappar-&gt;Editor-&gt;Open Image Trainer</code></p><p>​<img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202307310014586.png" alt="image-20230731001418550"></p><p>​选择使用即可</p><h3 id="自定义开始模板语言"><a href="#自定义开始模板语言" class="headerlink" title="自定义开始模板语言"></a>自定义开始模板语言</h3><p>官方的语言很多都不支持</p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202307310017073.jpeg" alt="IMG_9694" style="zoom:67%;" /><p>根据办法:<a target="_blank" rel="noopener" href="https://forum.zap.works/t/camera-permission-message/8441">Camera Permission Message - Universal AR - ZapWorks Forum</a></p><p>下载回答中<a target="_blank" rel="noopener" href="https://zapworksforumuploads.s3.dualstack.eu-west-1.amazonaws.com/original/2X/1/1e762c65ba63210f1f7aaca34653ced03f447faf.zip">custom_permission.zip</a></p><p>然后修改对应的index.html文件,然后修改permission.js文件里面的注释(这段注释代码是插入html解释)</p><p>如下:</p><p> 在unity中打开<code>Zap ArSetting</code></p><p>   <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202307310028848.png" alt="image-20230731002804575"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//修改index.html文件中代码</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://libs.zappar.com/zappar-cv/2.1.4/zappar-cv.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">//在原来基础上增加这行,注意正确路径地址</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;permission/permission.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//WaitForZCVLoad();</span><br><span class="line">//改成下面</span><br><span class="line">custom_permission_request_ui_async(PermissionResolve);</span><br><span class="line">function PermissionResolve(success) &#123;</span><br><span class="line">        console.log(&quot;permission allowed: &quot;+success);</span><br><span class="line">    if(success)</span><br><span class="line">        WaitForZCVLoad();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> //修改permission.js中代码 </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;zappar-title&quot;</span>&gt;</span>自定义标题<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;zappar-text&quot;</span>&gt;</span>提示信息<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;custom-permission-request-button&quot;</span>&gt;</span>按钮信息<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​      </p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Zapworks </tag>
            
            <tag> AR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity小记</title>
      <link href="/2023/07-05-Unity%E5%B0%8F%E8%AE%B0/"/>
      <url>/2023/07-05-Unity%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Camera-Main问题"><a href="#Camera-Main问题" class="headerlink" title="Camera.Main问题"></a>Camera.Main问题</h1><p>​<code>camera.main是个静态属性，用起来好用，但是其中内部使用的是</code>GameObject.FindGameObjectWithTag&#96;</p><p>所以再Update或者经常使用这个函数的地方需要注意。</p><p>​这个问题也直接导致了UGUI相关的耗时，在Canvas Renderer modes使用<code>Screen Space-Camera</code>或者<code>World Space</code>的时候如果要获取相机使用内部函数也会导致一些问题</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">UnityEngine.UI</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">AddComponentMenu(<span class="string">&quot;Event/Graphic Raycaster&quot;</span>)</span>]</span><br><span class="line">    [<span class="meta">RequireComponent(typeof(Canvas))</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GraphicRaycaster</span> : <span class="title">BaseRaycaster</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//……</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">override</span> Camera eventCamera</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (canvas.renderMode == RenderMode.ScreenSpaceOverlay || (canvas.renderMode == RenderMode.ScreenSpaceCamera &amp;&amp; canvas.worldCamera == <span class="literal">null</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">return</span> canvas.worldCamera != <span class="literal">null</span> ? canvas.worldCamera : Camera.main;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2021-12-19更新"><a href="#2021-12-19更新" class="headerlink" title="2021&#x2F;12&#x2F;19更新"></a>2021&#x2F;12&#x2F;19更新</h3><p>官方2020.02版本更新了这个问题(不管他改不改 还是自己记录)</p><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/K5tIJmd5ZquTQdJnctn1RQ">有史以来最快的Unity编辑器版本，Unity 2020.2 中的性能优化 (qq.com)</a></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202204291912660.png" alt="image-20211219203011654"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/murongxiaopifu/p/7823487.html">https://www.cnblogs.com/murongxiaopifu/p/7823487.html</a> </li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/cyf649669121/article/details/83661023">https://blog.csdn.net/cyf649669121/article/details/83661023</a></li></ol><h1 id="Unity中-的使用问题"><a href="#Unity中-的使用问题" class="headerlink" title="Unity中 ?? ?.的使用问题"></a>Unity中 <code>??</code> <code>?.</code>的使用问题</h1><p><code>??</code>是c#的一个语法糖,叫<code>空合并运算符</code>,如果左边不为空返回左边,否则返回右边</p><p>例子a&#x3D;b??c,如果b不为空,则a&#x3D;b,否则a&#x3D;c</p><p>在unity中我们可能这样使用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T t=<span class="keyword">this</span>.gameobject.GetComponent&lt;T&gt;()??<span class="keyword">this</span>.gameobject.AddComponent&lt;T&gt;();</span><br></pre></td></tr></table></figure><p>获取某个物体上面的Component,<code>但是我们获取Unity中内置的组件的时候这个方法得到的结果是永远不会为null</code></p><p>比如我们获取一个物体上面的相机,假如这个物体上面没有添加相机组件</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> camera = GetComponent&lt;Camera&gt;() ?? gameObject.AddComponent&lt;Camera&gt;();<span class="comment">//Camera组件不会被添加</span></span><br><span class="line"><span class="keyword">var</span> custom =  GetComponent&lt;CustomScript&gt;() ?? gameObject.AddComponent&lt;CustomScript&gt;(); <span class="comment">//CustomScript组件正常被添加</span></span><br></pre></td></tr></table></figure><p>原因是Unity底层是C++,而且C#源码<code>??</code> <code>?.</code>不能重载</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202212171836029.png" alt="image-20221217183624831"></p><p>总结:不要使用<code>?? ?.</code>操作unity 对象</p><h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ol><li><a target="_blank" rel="noopener" href="https://www.xuanyusong.com/archives/4713">https://www.xuanyusong.com/archives/4713</a></li><li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/2020.3/Manual/overview-of-dot-net-in-unity.html">Unity 中的 .NET 概述 - Unity 手册 (unity3d.com)</a></li></ol><h1 id="UGUI-点击Bug"><a href="#UGUI-点击Bug" class="headerlink" title="UGUI 点击Bug"></a>UGUI 点击Bug</h1><p>​<code>当UI中父物体实现了IPointerDownHandler接口,而子物体实行了IPointerClickHandler接口的时候 ,点击子物体时候不会触发 Click事件.</code></p><p>​原因是UI源码中鼠标按下的时候会寻找实现了<code>IPointerDownHandler</code>这个接口的物体,从子物体向上寻找,所以这里就找到了父物体,然后鼠标抬起,找到实现了Click接口的物体,然后通过判断两者是否一直来触发Click事件. 这里寻找到了父物体,而寻找到click物体是子物体,所以判断不一致无法触发</p><p>链接:<a target="_blank" rel="noopener" href="https://www.cnblogs.com/msxh/p/10588783.html">https://www.cnblogs.com/msxh/p/10588783.html</a></p><p><a target="_blank" rel="noopener" href="http://www.sikiedu.com/course/468/task/35891/show">http://www.sikiedu.com/course/468/task/35891/show</a></p><h1 id="UnityWebRequest-UnEscapeURL和UnityWebRequest-EscapeURL"><a href="#UnityWebRequest-UnEscapeURL和UnityWebRequest-EscapeURL" class="headerlink" title="UnityWebRequest.UnEscapeURL和UnityWebRequest.EscapeURL"></a>UnityWebRequest.UnEscapeURL和UnityWebRequest.EscapeURL</h1><p>要想知道这两个参数是什么意思,需要理解Http中URL的特殊字符</p><blockquote><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1074824">Url参数中出现+、空格、&#x3D;、%、&amp;、#等字符的解决办法 - 云+社区 - 腾讯云 (tencent.com)</a></p><p>Url出现了有+，空格，&#x2F;，?，%，#，&amp;，&#x3D;等特殊符号的时候，可能在<a target="_blank" rel="noopener" href="https://www.yisu.com/">服务器</a>端无法获得正确的参数值，抑或是造成不能正常下载文件(作为Download Url时候)，如何是好？解决办法：就是需要将这些字符转化成服务器可以识别的字符；但是为何Url中有这些字符就会出现问题呢？这就得涉及到URL编码与解码问题了</p><p>一般来说，URL只能使用英文字母、阿拉伯数字和某些标点符号，不能使用其他文字和符号。Url的编码格式采用的是ASCII码，而不是Unicode，这也就是说你不能在Url中包含任何非ASCII字符，例如希腊字母or中文。比如，世界上有英文字母的网址<a target="_blank" rel="noopener" href="http://www.abc.com,但是没有希腊字母的网址http//www.a%CE%B2%CE%B3.com%EF%BC%88%E8%AF%BB%E4%BD%9C%E9%98%BF%E5%B0%94%E6%B3%95-%E8%B4%9D%E5%A1%94-%E4%BC%BD%E7%8E%9B.com%EF%BC%89%E3%80%82%E8%BF%99%E6%98%AF%E5%9B%A0%E4%B8%BA%E7%BD%91%E7%BB%9C%E6%A0%87%E5%87%86RFC">http://www.abc.com，但是没有希腊字母的网址http://www.aβγ.com（读作阿尔法-贝塔-伽玛.com）。这是因为网络标准RFC</a> 1738做了硬性规定</p><p>*<em>只有字母和数字[0-9a-zA-Z]、一些特殊符号”$-_.+!<em>’(),”[不包括双引号]、以及某些保留字，才可以不经过编码直接用于URL。</em></em></p><p>URL中有汉字，等特殊字符的时候，就必须编码后使用。而+，空格，&#x2F;，?，%，#，&amp;，&#x3D;，这些字符(不安全)，当把他们直接放在Url中的时候，可能会引起解析程序的歧义，因此也必须经过编码才能使用</p></blockquote><p>除了那些无法显示的字符外(例如中文)，还需要在URL中对那些保留(reserved)字符和不安全(unsafe)字符进行编码。</p><p><code>保留字符</code>就是那些在URL中具有特定意义的字符。<code>不安全字符</code>是指那些在URL中没有特殊含义，但在URL所在的上下文中可能具有特殊意义的字符。例如双引号(“”)</p><table><thead><tr><th align="left">部分保留字符和不安全字符及其URL编码</th><th></th><th></th><th></th></tr></thead><tbody><tr><td align="left">字符</td><td>描述</td><td>用法</td><td>编码</td></tr><tr><td align="left">;</td><td>分号</td><td>保留</td><td>%3B</td></tr><tr><td align="left">&#x2F;</td><td>斜线</td><td>保留</td><td>%2F</td></tr><tr><td align="left">?</td><td>问号</td><td>保留</td><td>%3F</td></tr><tr><td align="left">:</td><td>冒号</td><td>保留</td><td>%3A</td></tr><tr><td align="left">@</td><td>“at”符号</td><td>保留</td><td>%4O</td></tr><tr><td align="left">&#x3D;</td><td>等号</td><td>保留</td><td>%3D</td></tr><tr><td align="left">&amp;</td><td>“和”符号</td><td>保留</td><td>%26</td></tr><tr><td align="left">&lt;</td><td>小于号</td><td>不安全</td><td>%3C</td></tr><tr><td align="left">&gt;</td><td>大于号</td><td>不安全</td><td>%3E</td></tr><tr><td align="left">“</td><td>双引号</td><td>不安全</td><td>%22</td></tr><tr><td align="left">#</td><td>井号</td><td>不安全</td><td>%23</td></tr><tr><td align="left">%</td><td>百分号</td><td>不安全</td><td>%25</td></tr><tr><td align="left">{</td><td>左大括号</td><td>不安全</td><td>%7B</td></tr><tr><td align="left">}</td><td>右大括号</td><td>不安全</td><td>%7D</td></tr><tr><td align="left">|</td><td>竖线</td><td>不安全</td><td>%7C</td></tr><tr><td align="left">\</td><td>反斜线</td><td>不安全</td><td>%5C</td></tr><tr><td align="left">^</td><td>加字号</td><td>不安全</td><td>%5E</td></tr><tr><td align="left">~</td><td>波浪</td><td>不安全</td><td>%7E</td></tr><tr><td align="left">[</td><td>左中括号</td><td>不安全</td><td>%5B</td></tr><tr><td align="left">]</td><td>右中括号</td><td>不安全</td><td>%5D</td></tr><tr><td align="left">&#96;</td><td>反单引号</td><td>不安全</td><td>%60</td></tr><tr><td align="left"></td><td>空格</td><td>不安全</td><td>%20</td></tr></tbody></table><p>综上所述所研究所得:</p><ul><li>URL都是ASCll码,其他字符需要转义</li><li>URL编码其实是字符ASCll码的十六进制然后在前面加上%号,对应ASCII表格</li></ul><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162306856.png" alt="20220616230611"><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202308072137827.jpeg" alt="ASCII"></p><h1 id="关于Unity中帧率过高导致update计算过快的影响"><a href="#关于Unity中帧率过高导致update计算过快的影响" class="headerlink" title="关于Unity中帧率过高导致update计算过快的影响"></a>关于Unity中帧率过高导致update计算过快的影响</h1><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>unity程序发布如果没有设置<code>Dont Vsync+Application.targetFrame=xx</code>,且电脑关闭了垂直同步,电脑会以极高的帧率运行程序,如果设置了<code>Dont Vsync</code> 有可能会出现<code>画面撕裂</code>状况</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202307051206215.png" alt="image-20230705120604480"></p><p> 代码中有如下示例代码:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> currMousePos=Input.MousePosition;</span><br><span class="line">    <span class="comment">//计算移动距离</span></span><br><span class="line">    <span class="keyword">if</span>((currMousePos-lastMousePos).sqrMagnitude&gt;<span class="number">10000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//do</span></span><br><span class="line">    &#125;</span><br><span class="line">    lastMousePos=currMousePos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在编辑下帧率只要60的话,也许<code>10000</code>这个数值是可以,但是如果帧率很高的话,会导致结果偏小也许就100</p><p>原因是帧率搞运行快,检测的两帧移动距离就会偏小</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>要解决上面问题,就要是计算结果与帧率无关,这个其实就是在update中移动物体一样,使用<code>Time.deltaTime</code></p><p><code>帧率越大,Time.deltaTime越小</code></p><p><code>帧率越小,Time.deltaTime越大</code></p><p>改进后代码:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> currMousePos=Input.MousePosition;</span><br><span class="line">    <span class="comment">//计算移动距离 可以在Time.deltaTime*一个固定倍数,防止数值过大</span></span><br><span class="line">    <span class="keyword">var</span> detlaDis=(currMousePos-lastMousePos).sqrMagnitude/(Time.deltaTime);</span><br><span class="line">    <span class="keyword">if</span>(detlaDis&gt;<span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//do</span></span><br><span class="line">    &#125;</span><br><span class="line">    lastMousePos=currMousePos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="关于Unity的Playersetting-OtherSetting-Stack-Track"><a href="#关于Unity的Playersetting-OtherSetting-Stack-Track" class="headerlink" title="关于Unity的Playersetting-&gt;OtherSetting-&gt;Stack Track"></a>关于Unity的Playersetting-&gt;OtherSetting-&gt;Stack Track</h1><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202307151853485.png" alt="image-20230715185315689"></p><p>这个是关于Unity中发布之后的日志<code>堆栈信息</code>,打包勾选<code>development build</code>,然后查看<code>console-&gt;open log file</code>如下</p><ul><li><p>None</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202307151905942.png" alt="image-20230715190544740"></p></li><li><p>ScriptOnly</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202307151906734.png" alt="image-20230715190639540"></p></li><li><p>Full</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202307151907609.png" alt="image-20230715190740710"></p></li></ul><h3 id="优化记录"><a href="#优化记录" class="headerlink" title="优化记录"></a>优化记录</h3><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202307151911183.png" alt="image-20230715191152056"></p><h1 id="关于为什么使用Animation-Legacy-动画系统不能制作序列帧动画"><a href="#关于为什么使用Animation-Legacy-动画系统不能制作序列帧动画" class="headerlink" title="关于为什么使用Animation(Legacy)动画系统不能制作序列帧动画"></a>关于为什么使用Animation(Legacy)动画系统不能制作序列帧动画</h1><blockquote><p>Legacy doesn’t support any PPtr Animation, you can animate any property of the Components, but you can not animate the reference to another object like the Sprite reference.</p></blockquote><p><a target="_blank" rel="noopener" href="https://discussions.unity.com/t/legacy-animation-doesnt-work/191131/4">Legacy Animation doesn’t work… - Questions &amp; Answers - Unity Discussions</a></p><p>legacy动画只能改变动画值属性,像spriterender.sprite属于引用类型不支持,<strong>PPtr</strong> 是 Unity 内部使用的术语，全称是 <strong>Pointer to Unity Object</strong>（指向 Unity 引用对象的指针）。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见设备分辨率</title>
      <link href="/2023/03-02-%E5%B8%B8%E8%A7%81%E8%AE%BE%E5%A4%87%E5%88%86%E8%BE%A8%E7%8E%87/"/>
      <url>/2023/03-02-%E5%B8%B8%E8%A7%81%E8%AE%BE%E5%A4%87%E5%88%86%E8%BE%A8%E7%8E%87/</url>
      
        <content type="html"><![CDATA[<h1 id="常见分辨率"><a href="#常见分辨率" class="headerlink" title="常见分辨率"></a>常见分辨率</h1><h2 id="IOS"><a href="#IOS" class="headerlink" title="IOS"></a>IOS</h2><table><thead><tr><th>分辨率</th><th>比例</th><th>设备</th></tr></thead><tbody><tr><td>960 x 640</td><td>3:2</td><td>iPhone 4S</td></tr><tr><td>1136 x 640</td><td>16:9</td><td>iPhone 5, iPhone 5C, iPhone 5S</td></tr><tr><td>1334 x 750</td><td>16:9</td><td>iPhone 6, iPhone 6S, iPhone 7, iPhone 8</td></tr><tr><td>1920 x 1080</td><td>16:9</td><td>iPhone 6 Plus, iPhone 6S Plus, iPhone 7 Plus, iPhone 8 Plus</td></tr><tr><td>2208 x 1242</td><td>16:9</td><td>iPhone X, iPhone XS, iPhone 11 Pro</td></tr><tr><td>2436 x 1125</td><td>19.5:9</td><td>iPhone XR, iPhone 11</td></tr><tr><td>2688 x 1242</td><td>19.5:9</td><td>iPhone XS Max, iPhone 11 Pro Max</td></tr><tr><td>2532 x 1170</td><td>19.5:9</td><td>iPhone 12, iPhone 12 Pro</td></tr><tr><td>2778 x 1284</td><td>19.5:9</td><td>iPhone 12 Pro Max</td></tr><tr><td>2340 x 1080</td><td>19.5:9</td><td>iPhone 12 mini</td></tr><tr><td>2532 x 1170</td><td>19.5:9</td><td>iPhone 13 mini</td></tr><tr><td>2532 x 1170</td><td>19.5:9</td><td>iPhone 13, iPhone 13 Pro</td></tr><tr><td>2778 x 1284</td><td>19.5:9</td><td>iPhone 13 Pro Max</td></tr></tbody></table><table><thead><tr><th>iPad型号</th><th>分辨率</th><th>宽高比</th></tr></thead><tbody><tr><td>iPad (第1代)</td><td>1024 x 768</td><td>4:3</td></tr><tr><td>iPad 2</td><td>1024 x 768</td><td>4:3</td></tr><tr><td>iPad (第3代)</td><td>2048 x 1536</td><td>4:3</td></tr><tr><td>iPad (第4代)</td><td>2048 x 1536</td><td>4:3</td></tr><tr><td>iPad Air</td><td>2048 x 1536</td><td>4:3</td></tr><tr><td>iPad Air 2</td><td>2048 x 1536</td><td>4:3</td></tr><tr><td>iPad (第5代)</td><td>2048 x 1536</td><td>4:3</td></tr><tr><td>iPad (第6代)</td><td>2048 x 1536</td><td>4:3</td></tr><tr><td>iPad Air (第3代)</td><td>2224 x 1668</td><td>4:3</td></tr><tr><td>iPad (第7代)</td><td>2160 x 1620</td><td>4:3</td></tr><tr><td>iPad (第8代)</td><td>2160 x 1620</td><td>4:3</td></tr><tr><td>iPad Air (第4代)</td><td>2360 x 1640</td><td>4:3</td></tr><tr><td>iPad Mini</td><td>1024 x 768</td><td>4:3</td></tr><tr><td>iPad Mini 2</td><td>2048 x 1536</td><td>4:3</td></tr><tr><td>iPad Mini 3</td><td>2048 x 1536</td><td>4:3</td></tr><tr><td>iPad Mini 4</td><td>2048 x 1536</td><td>4:3</td></tr><tr><td>iPad Mini (第5代)</td><td>2048 x 1536</td><td>4:3</td></tr><tr><td>iPad Pro (12.9英寸，第1代)</td><td>2732 x 2048</td><td>4:3</td></tr><tr><td>iPad Pro (9.7英寸)</td><td>2048 x 1536</td><td>4:3</td></tr><tr><td>iPad Pro (12.9英寸，第2代)</td><td>2732 x 2048</td><td>4:3</td></tr><tr><td>iPad Pro (10.5英寸)</td><td>2224 x 1668</td><td>4:3</td></tr><tr><td>iPad Pro (11英寸)</td><td>2388 x 1668</td><td>4:3</td></tr><tr><td>iPad Pro (12.9英寸，第3代)</td><td>2732 x 2048</td><td>4:3</td></tr><tr><td>iPad Pro (11英寸，第2代)</td><td>2388 x 1668</td><td>4:3</td></tr><tr><td>iPad Pro (12.9英寸，第4代)</td><td>2732 x 2048</td><td>4:3</td></tr><tr><td>iPad Pro (11英寸，第3代)</td><td>2388 x 1668</td><td>4:3</td></tr><tr><td>iPad Pro (12.9英寸，第5代)</td><td>2732 x 2048</td><td>4:3</td></tr><tr><td>iPad Pro (11英寸，第4代)</td><td>2388 x 1668</td><td>4:3</td></tr></tbody></table><h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><table><thead><tr><th>分辨率</th><th>比例</th></tr></thead><tbody><tr><td>720 x 1280</td><td>9:16</td></tr><tr><td>1080 x 1920</td><td>9:16</td></tr><tr><td>1440 x 2560</td><td>9:16</td></tr><tr><td>1440 x 3040</td><td>19:9</td></tr><tr><td>1080 x 2220</td><td>18.5:9</td></tr><tr><td>1080 x 2280</td><td>19:9</td></tr><tr><td>1080 x 2340</td><td>19.5:9</td></tr><tr><td>1440 x 3120</td><td>19.5:9</td></tr><tr><td>1440 x 3200</td><td>20:9</td></tr><tr><td>1440 x 1440</td><td>1:1</td></tr><tr><td>1600 x 2560</td><td>5:8</td></tr><tr><td>1600 x 900</td><td>16:9</td></tr><tr><td>1920 x 1080</td><td>16:9</td></tr><tr><td>2160 x 3840</td><td>9:16</td></tr><tr><td>2400 x 1080</td><td>19:9</td></tr><tr><td>2400 x 1080</td><td>20:9</td></tr><tr><td>2400 x 1176</td><td>20.5:9</td></tr><tr><td>2560 x 1440</td><td>16:9</td></tr><tr><td>3040 x 1440</td><td>20:9</td></tr><tr><td>3200 x 1440</td><td>19:9</td></tr><tr><td>3200 x 1800</td><td>16:9</td></tr><tr><td>3840 x 2160</td><td>16:9</td></tr></tbody></table><table><thead><tr><th>安卓平板</th><th>分辨率</th><th>宽高比</th></tr></thead><tbody><tr><td>华为平板M5 8.4英寸</td><td>2560 x 1600</td><td>16:10</td></tr><tr><td>华为平板M5 10.8英寸</td><td>2560 x 1600</td><td>16:10</td></tr><tr><td>华为平板M6 8.4英寸</td><td>2560 x 1600</td><td>16:10</td></tr><tr><td>华为平板M6 10.8英寸</td><td>2560 x 1600</td><td>16:10</td></tr><tr><td>小米平板4 8.0英寸</td><td>1920 x 1200</td><td>16:10</td></tr><tr><td>小米平板4 Plus 10.1英寸</td><td>1920 x 1200</td><td>16:10</td></tr><tr><td>荣耀平板5 8.0英寸</td><td>1920 x 1200</td><td>16:10</td></tr><tr><td>荣耀平板5 10.1英寸</td><td>1920 x 1200</td><td>16:10</td></tr><tr><td>三星平板S6 Lite</td><td>2000 x 1200</td><td>5:3</td></tr><tr><td>三星平板Tab A 8.0</td><td>1280 x 800</td><td>16:10</td></tr><tr><td>三星平板Tab A 10.1</td><td>1920 x 1200</td><td>16:10</td></tr><tr><td>华硕平板ZenPad 3S 10</td><td>2048 x 1536</td><td>4:3</td></tr><tr><td>华硕平板ZenPad S 8.0</td><td>2048 x 1536</td><td>4:3</td></tr></tbody></table><h2 id="PC"><a href="#PC" class="headerlink" title="PC"></a>PC</h2><table><thead><tr><th>分辨率</th><th>比例</th></tr></thead><tbody><tr><td>800 x 600</td><td>4:3</td></tr><tr><td>1024 x 768</td><td>4:3</td></tr><tr><td>1280 x 720</td><td>16:9</td></tr><tr><td>1280 x 800</td><td>16:10</td></tr><tr><td>1280 x 960</td><td>4:3</td></tr><tr><td>1280 x 1024</td><td>5:4</td></tr><tr><td>1360 x 768</td><td>16:9</td></tr><tr><td>1366 x 768</td><td>16:9</td></tr><tr><td>1440 x 900</td><td>16:10</td></tr><tr><td>1600 x 900</td><td>16:9</td></tr><tr><td>1600 x 1200</td><td>4:3</td></tr><tr><td>1680 x 1050</td><td>16:10</td></tr><tr><td>1920 x 1080</td><td>16:9</td></tr><tr><td>1920 x 1200</td><td>16:10</td></tr><tr><td>2560 x 1440</td><td>16:9</td></tr><tr><td>2560 x 1600</td><td>16:10</td></tr><tr><td>3840 x 2160</td><td>16:9</td></tr><tr><td>4096 x 2160</td><td>17:9</td></tr></tbody></table><hr><h1 id="Unity中向Game视图添加分辨率"><a href="#Unity中向Game视图添加分辨率" class="headerlink" title="Unity中向Game视图添加分辨率"></a>Unity中向Game视图添加分辨率</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> GameViewSizeType</span><br><span class="line">  &#123;</span><br><span class="line">      AspectRatio, FixedResolution</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="meta">MenuItem(<span class="string">&quot;Window/Add Resolution&quot;</span>)</span>]</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddGameViewResolution</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">//ipad基本都是4:3</span></span><br><span class="line">      <span class="comment">//android pad 有16:10 4:3 5:3</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//类型 宽 高 名称</span></span><br><span class="line">      List&lt;(GameViewSizeType type, <span class="built_in">int</span> width, <span class="built_in">int</span> heigth, <span class="built_in">string</span> title)&gt; listCustomResolution = <span class="keyword">new</span> List&lt;(GameViewSizeType, <span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">string</span>)&gt;();</span><br><span class="line">             listCustomResolution.Add((GameViewSizeType.FixedResolution, <span class="number">1024</span>, <span class="number">1280</span>, <span class="string">&quot;1024x1280 (5:4==1.25)&quot;</span>));</span><br><span class="line">      listCustomResolution.Add((GameViewSizeType.FixedResolution, <span class="number">1280</span>, <span class="number">1024</span>, <span class="string">&quot;1280x1024&quot;</span>));</span><br><span class="line">      listCustomResolution.Add((GameViewSizeType.FixedResolution, <span class="number">768</span>, <span class="number">1024</span>, <span class="string">&quot;768x1024 (4:3==1.333)&quot;</span>));</span><br><span class="line">      listCustomResolution.Add((GameViewSizeType.FixedResolution, <span class="number">1024</span>, <span class="number">768</span>, <span class="string">&quot;1024x768&quot;</span>));</span><br><span class="line">      listCustomResolution.Add((GameViewSizeType.FixedResolution, <span class="number">1536</span>, <span class="number">2048</span>, <span class="string">&quot;1536x2048 (4:3=1.333)&quot;</span>));</span><br><span class="line">      listCustomResolution.Add((GameViewSizeType.FixedResolution, <span class="number">2048</span>, <span class="number">1536</span>, <span class="string">&quot;2048x1536&quot;</span>));</span><br><span class="line">      listCustomResolution.Add((GameViewSizeType.FixedResolution, <span class="number">1200</span>, <span class="number">2000</span>, <span class="string">&quot;1200x2000 (5:3=1.667)&quot;</span>));</span><br><span class="line">      listCustomResolution.Add((GameViewSizeType.FixedResolution, <span class="number">2000</span>, <span class="number">1200</span>, <span class="string">&quot;2000x1200&quot;</span>));</span><br><span class="line">      listCustomResolution.Add((GameViewSizeType.FixedResolution, <span class="number">1080</span>, <span class="number">2340</span>, <span class="string">&quot;1080x2340 (9.5:9=2.167)&quot;</span>));</span><br><span class="line">      listCustomResolution.Add((GameViewSizeType.FixedResolution, <span class="number">2340</span>, <span class="number">1080</span>, <span class="string">&quot;2340x1080&quot;</span>));</span><br><span class="line">      listCustomResolution.Add((GameViewSizeType.FixedResolution, <span class="number">1600</span>, <span class="number">2560</span>, <span class="string">&quot;1600x2560 (16:10==1.6)&quot;</span>));</span><br><span class="line">      listCustomResolution.Add((GameViewSizeType.FixedResolution, <span class="number">2560</span>, <span class="number">1600</span>, <span class="string">&quot;2560x1600&quot;</span>));</span><br><span class="line">      listCustomResolution.Add((GameViewSizeType.FixedResolution, <span class="number">1080</span>, <span class="number">1920</span>, <span class="string">&quot;1080x1920 (16:9==1.778)&quot;</span>));</span><br><span class="line">      listCustomResolution.Add((GameViewSizeType.FixedResolution, <span class="number">1920</span>, <span class="number">1080</span>, <span class="string">&quot;1920x1080&quot;</span>));</span><br><span class="line">      listCustomResolution.Add((GameViewSizeType.FixedResolution, <span class="number">2160</span>, <span class="number">4096</span>, <span class="string">&quot;2160x4096 (17:9==1.889)&quot;</span>));</span><br><span class="line">      listCustomResolution.Add((GameViewSizeType.FixedResolution, <span class="number">4096</span>, <span class="number">2160</span>, <span class="string">&quot;4096x2160&quot;</span>));</span><br><span class="line">      listCustomResolution.Add((GameViewSizeType.FixedResolution, <span class="number">1080</span>, <span class="number">2400</span>, <span class="string">&quot;1080x2400 (30:13.5=2.222)&quot;</span>));</span><br><span class="line">      listCustomResolution.Add((GameViewSizeType.FixedResolution, <span class="number">2400</span>, <span class="number">1080</span>, <span class="string">&quot;2400x1080&quot;</span>));</span><br><span class="line">      listCustomResolution.Add((GameViewSizeType.FixedResolution, <span class="number">1176</span>, <span class="number">2400</span>, <span class="string">&quot;1176x2400 (20.5:9=2.278)&quot;</span>));</span><br><span class="line">      listCustomResolution.Add((GameViewSizeType.FixedResolution, <span class="number">2400</span>, <span class="number">1176</span>, <span class="string">&quot;2400x1176&quot;</span>));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//反射添加</span></span><br><span class="line">      <span class="keyword">var</span> sizesType = <span class="keyword">typeof</span>(Editor).Assembly.GetType(<span class="string">&quot;UnityEditor.GameViewSizes&quot;</span>);</span><br><span class="line">      <span class="keyword">var</span> singleType = <span class="keyword">typeof</span>(ScriptableSingleton&lt;&gt;).MakeGenericType(sizesType);</span><br><span class="line">      <span class="comment">//找到单例</span></span><br><span class="line">      <span class="keyword">var</span> instance = singleType.GetProperty(<span class="string">&quot;instance&quot;</span>).GetValue(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">var</span> <span class="keyword">group</span> = instance.GetType().GetProperty(<span class="string">&quot;currentGroup&quot;</span>, System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public).GetValue(instance);</span><br><span class="line">      <span class="comment">//找到方法</span></span><br><span class="line">      <span class="keyword">var</span> addCustomSize = <span class="keyword">group</span>.GetType().GetMethod(<span class="string">&quot;AddCustomSize&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//这里不能用for循环 奇怪</span></span><br><span class="line">      <span class="comment">//var removeCustomSize = group.GetType().GetMethod(&quot;RemoveCustomSize&quot;);</span></span><br><span class="line">      <span class="comment">//for (int i = 18; i &lt; 5; i++)</span></span><br><span class="line">      <span class="comment">//&#123;</span></span><br><span class="line">      <span class="comment">//    removeCustomSize.Invoke(group, new object[] &#123; i &#125;);</span></span><br><span class="line">      <span class="comment">//&#125;</span></span><br><span class="line">      <span class="comment">//removeCustomSize.Invoke(group, new object[] &#123; 37 &#125;);</span></span><br><span class="line">      <span class="comment">//removeCustomSize.Invoke(group, new object[] &#123; 38 &#125;);</span></span><br><span class="line">      <span class="comment">//removeCustomSize.Invoke(group, new object[] &#123; 39 &#125;);</span></span><br><span class="line">      <span class="comment">//removeCustomSize.Invoke(group, new object[] &#123; 40 &#125;);</span></span><br><span class="line">      <span class="comment">//removeCustomSize.Invoke(group, new object[] &#123; 41 &#125;);</span></span><br><span class="line">      <span class="comment">//removeCustomSize.Invoke(group, new object[] &#123; 42 &#125;);</span></span><br><span class="line">      <span class="comment">//return;</span></span><br><span class="line"></span><br><span class="line">      Assembly assembly = Assembly.Load(<span class="string">&quot;UnityEditor.dll&quot;</span>);</span><br><span class="line">      Type gameViewSize = assembly.GetType(<span class="string">&quot;UnityEditor.GameViewSize&quot;</span>);</span><br><span class="line">      Type gameViewSizeType = assembly.GetType(<span class="string">&quot;UnityEditor.GameViewSizeType&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> listCustomResolution)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">//创建一个GameViewSize类</span></span><br><span class="line">          ConstructorInfo ctor = gameViewSize.GetConstructor(<span class="keyword">new</span> Type[]</span><br><span class="line">           &#123;</span><br><span class="line">               gameViewSizeType,</span><br><span class="line">               <span class="keyword">typeof</span>(<span class="built_in">int</span>),</span><br><span class="line">               <span class="keyword">typeof</span>(<span class="built_in">int</span>),</span><br><span class="line">               <span class="keyword">typeof</span>(<span class="built_in">string</span>)</span><br><span class="line">           &#125;);</span><br><span class="line">          <span class="comment">//GameViewSizeType.FixedResolution就是1</span></span><br><span class="line">          <span class="keyword">var</span> newSize = ctor.Invoke(<span class="keyword">new</span> <span class="built_in">object</span>[] &#123; (<span class="built_in">int</span>)item.type, item.width, item.heigth, item.title &#125;);</span><br><span class="line">          <span class="comment">//调用方法添加</span></span><br><span class="line">          addCustomSize.Invoke(<span class="keyword">group</span>, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; newSize &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//保存</span></span><br><span class="line">      <span class="keyword">var</span> saveMethod = instance.GetType().GetMethod(<span class="string">&quot;SaveToHDD&quot;</span>);</span><br><span class="line">      saveMethod.Invoke(instance, <span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2022/12-24-Java%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/12-24-Java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Objective-C基础</title>
      <link href="/2022/09-24-Objective-C%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/09-24-Objective-C%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>来源于视频<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1NJ411T78u">https://www.bilibili.com/video/BV1NJ411T78u</a></p><h2 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h2><ol><li><p><strong>OC是扩充C的面向对象编程语言,本质上还是C语言</strong></p><p>所以OC中是可以写C语言的,也是完全可以兼容C语言的(也就是可以在OC中写C语言)</p></li></ol><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209241442310.png" alt="image-20220924144253965"></p><ol start="2"><li><p>OC文件名后缀是<code>.m</code>,     m代表message 代表<code>OC中的消息机制</code>,OC大多以<code>NS开头</code>,是因为NextStep开发.</p></li><li><p>#Import指令</p><ul><li>是c语言 #include的增强版 无论inport多少次 只会包含一次</li><li>作用是导入库</li></ul></li><li><p>Foundation框架</p><p>基础 基本,提供了一些基础功能 一些数据类型</p></li><li><p><code>@autoreleasetpool</code> 自动释放池 相当于c# using</p></li><li><p>一些占位符(c语言)</p><table><thead><tr><th>占位符</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>%d</td><td>int</td><td></td></tr><tr><td>%f</td><td>float 浮点类型</td><td><code>NSLog(@&quot;num=%f&quot;,100f)</code></td></tr><tr><td>%lf</td><td>double类型</td><td></td></tr><tr><td>%hd</td><td>short int</td><td></td></tr><tr><td>%ld</td><td>long</td><td></td></tr><tr><td>%lld</td><td>long long</td><td></td></tr><tr><td>%u</td><td>unsigned</td><td></td></tr><tr><td>%c</td><td>char类型</td><td></td></tr><tr><td>%s</td><td>c中 字符串</td><td><code>printf(&quot;hell%s&quot;,&quot;o&quot;)</code></td></tr><tr><td>%@</td><td>OC中字符串</td><td><code>NSLog(@&quot;hello %@&quot;,@&quot;world&quot;)</code></td></tr><tr><td>%p</td><td>指针</td><td></td></tr></tbody></table></li><li><p>字符串</p><p><strong>C中</strong></p><pre><code>* char str[10]=&quot;abc&quot;  后面会用 `\0` 补齐* char *str=&quot;abc&quot;* char str[]=&#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;&#125;</code></pre><p><strong>OC中</strong></p><ul><li>OC字符串<strong>必须加一个<code>@</code>符号</strong>  @”hello”  NSString *str&#x3D;@”abc”</li><li>使用<code>NSString</code>类型 存储的是一个指针变量,存贮的是字符的指针</li></ul></li><li><p>@符号</p><ol><li>将C字符串转换为OC字符串</li><li>OC中绝大部分关键字都是@开头</li></ol></li><li><p>函数定义与调用</p><ol><li>先定义然后再调用</li></ol></li><li><p>数据类型(加粗是OC特有)</p><table><thead><tr><th>关键字</th><th>占用空间</th><th>范围</th></tr></thead><tbody><tr><td>char</td><td>1 字节</td><td>-128 到 127 或 0 到 255</td></tr><tr><td>unsigned char</td><td>1 字节</td><td>0 到 255</td></tr><tr><td>signed char</td><td>1 字节</td><td>-128 到 127</td></tr><tr><td>int</td><td>2 或 4 字节</td><td>-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647</td></tr><tr><td>unsigned int</td><td>2 或 4 字节</td><td>0 到 65,535 或 0 到 4,294,967,295</td></tr><tr><td>short</td><td>2 字节</td><td>-32,768 到 32,767</td></tr><tr><td>unsigned short</td><td>2 字节</td><td>0 到 65,535</td></tr><tr><td>long</td><td>4 字节</td><td>-2,147,483,648 到 2,147,483,647</td></tr><tr><td>unsigned long</td><td>4 字节</td><td>0 到 4,294,967,295</td></tr><tr><td><strong>BOOL类型</strong></td><td><strong>1字节</strong></td><td><strong>BOOL&#x3D;YES &#x2F;NO (都是大写)</strong> 实际是 typedef signed char BOOL</td></tr><tr><td><strong>Boolean</strong></td><td><strong>1字节</strong></td><td><strong>Boolean&#x3D;true&#x2F;false 实际是 typedef unsigned char</strong></td></tr><tr><td><strong>id类型</strong></td><td></td><td></td></tr><tr><td><strong>nil</strong></td><td></td><td><strong>&#x3D;&#x3D;NULL</strong> oc用nil c用null</td></tr><tr><td><strong>SEL</strong></td><td></td><td><strong>方法选择器</strong></td></tr></tbody></table></li><li><p>类</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">//声明类</span><br><span class="line">@interface ClassName:NSObject  </span><br><span class="line">&#123;</span><br><span class="line">NSString *_name; //默认外部不可以反问</span><br><span class="line">    </span><br><span class="line">@publicint _age; //可以外部访问</span><br><span class="line">&#125;</span><br><span class="line">//方法声明和实现必须一个整体 不然调用会报错</span><br><span class="line">- (void) Run; //方法声明 无返回值</span><br><span class="line">- (void) Eat:(NSString *) foodName; //带参数方法 无返回值</span><br><span class="line">- (int) Sum:(int) num1:(int) num2; //带参数 有返回值</span><br><span class="line">-(void) CallOther; //调用其他方法</span><br><span class="line">@end</span><br><span class="line">    </span><br><span class="line">//实现类</span><br><span class="line">@implementation ClassName</span><br><span class="line">    - (void) Run //方法实现</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%@跑&quot;,_name); //谁跑 直接访问字段</span><br><span class="line">&#125;</span><br><span class="line">- (void) Eat:(NSString *) foodName</span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@&quot;正在吃%@&quot;,foodName);</span><br><span class="line">    &#125;</span><br><span class="line">- (int) Sum:(int) num1:(int) num2</span><br><span class="line">    &#123;</span><br><span class="line">        int sum=num1+num2;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">    - (void) CallOther</span><br><span class="line">    &#123;</span><br><span class="line">        [self Run];//调用本类中其他方法</span><br><span class="line">    &#125;</span><br><span class="line">@end</span><br><span class="line">    </span><br><span class="line">int main(int v,const char * args[])</span><br><span class="line">&#123;</span><br><span class="line">    //实例化</span><br><span class="line">ClassName *cn=[ClassName new];</span><br><span class="line">    //设置字段</span><br><span class="line">    cn-&gt;_age=10;//或者 (*cn)._age=10;</span><br><span class="line">    //调用方法</span><br><span class="line">    [cn Run];</span><br><span class="line">    [cn Eat:@&quot;西湖醋鱼&quot;];</span><br><span class="line">    int sum= [cn Sum:10:20];</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Objective-C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>热更新系列(二)——HybridCLR(huatuo)</title>
      <link href="/2022/09-22-%E7%83%AD%E6%9B%B4%E6%96%B002/"/>
      <url>/2022/09-22-%E7%83%AD%E6%9B%B4%E6%96%B002/</url>
      
        <content type="html"><![CDATA[<h2 id="关于HybridCLR"><a href="#关于HybridCLR" class="headerlink" title="关于HybridCLR"></a>关于HybridCLR</h2><p>[官网](<a target="_blank" rel="noopener" href="https://hybridclr.doc.code-philosophy.com/">HybridCLR | HybridCLR (code-philosophy.com)</a>)</p><p>HybridCLR改进了unity的Il2cpp部分,使得其能”解释”执行一些代码,每个unity都可以在安装文件下找到<code>\Data\il2cpp\libil2cpp</code>, HybridCLR就是改进了这一部分.</p><p>具体查看:<a target="_blank" rel="noopener" href="https://hybridclr.doc.code-philosophy.com/docs/basic/install#hybridclrinstaller%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">安装HybridCLR | HybridCLR (code-philosophy.com)</a></p><blockquote><p>原始il2cpp是AOT运行时，不支持动态注册dll元数据。我们轻微改造了metadata管理模块，插入了一些hook代码，支持动态加载dll元数据</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="依赖模块"><a href="#依赖模块" class="headerlink" title="依赖模块"></a>依赖模块</h3><p><a target="_blank" rel="noopener" href="https://hybridclr.doc.code-philosophy.com/docs/basic/install">安装HybridCLR </a></p><ul><li>Unity Hub 安装相应的IL2cpp模块</li><li>Windows<ul><li>Win下需要安装<code>visual studio 2019</code>或更高版本。安装时至少要包含 <code>使用Unity的游戏开发</code> 和 <code>使用c++的游戏开发</code> 组件。</li><li>安装git</li></ul></li><li>Mac<ul><li>要求MacOS版本 &gt;&#x3D; 12，xcode版本 &gt;&#x3D; 13，例如<code>xcode 13.4.1， macos 12.4</code>。</li><li>安装 git</li><li>安装cmake</li></ul></li></ul><h3 id="目录说明"><a href="#目录说明" class="headerlink" title="目录说明"></a>目录说明</h3><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202307171107442.png" alt="image-20230717110653078"></p><ul><li><p>AssembliesPostIl2CppStrip</p><p><strong>打包过程生成的裁剪后的AOT dll</strong>. 用于补充元数据,分为不同平台,不同平台不可混用,至于为什么是剪裁后的AOTdll,这是为了减小生成的dll大小也是为了减小内存(下同)</p></li><li><p>HotUpdateDlls</p><p>生成的热更程序集</p></li><li><p>hybridclr_repo</p><p>Hybridclr仓库代码.扩充了il2cpp的代码，使它由纯<a href="https://gitee.com/link?target=https://en.wikipedia.org/wiki/Ahead-of-time_compilation">AOT</a> runtime变成‘AOT+Interpreter’ 混合runtime，进而原生支持动态加载assembly，使得基于il2cpp backend打包的游戏不仅能在Android平台，也能在IOS、Consoles等限制了JIT的平台上高效地以<strong>AOT+interpreter</strong>混合模式执行，从底层彻底支持了热更新。为解释器部分的核心代码，包含元数据加载、代码transform(编译)、代码解释执行</p></li><li><p>il2cpp_plus_repo</p><p>il2cpp_plus仓库代码,原始的<code>libil2cpp</code>是AOT运行,Hybirdclr改造了metadata管理模块,插入一些hook代码,支持动态加载dll元数据</p></li><li><p>LocalIl2CppData-WindowsEditor</p><p>这里是把Unity自带的<code>MonoBleedingEdge(2019以上)+Il2cpp+改造后的libil2cpp</code></p><p><img src="https://hybridclr.doc.code-philosophy.com/assets/images/merge_hybridclr_dir-04680fdb60dccd43bfd2593b4affd10e.jpg" alt="merge_hybridclr_dir"></p><p>​注:每个平台Editor自带il2cpp不同(windows.linux,macos…),所有要区分</p><p>​<a target="_blank" rel="noopener" href="https://hybridclr.doc.code-philosophy.com/docs/basic/install#hybridclrinstaller%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">hybridclrinstaller工作原理</a></p></li><li><p>StrippedAOTDllsTempProj</p><p>生成剪裁后的AOTdll临时工程(意思就是要生成剪裁后的AOTdll得有个工程)</p></li></ul><h3 id="Unity-HybridSetting"><a href="#Unity-HybridSetting" class="headerlink" title="Unity HybridSetting"></a>Unity HybridSetting</h3><p><a target="_blank" rel="noopener" href="https://hybridclr.doc.code-philosophy.com/docs/basic/com.code-philosophy.hybridclr#hybridclr%E8%8F%9C%E5%8D%95%E4%BB%8B%E7%BB%8D">hybridclr菜单介绍</a></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202307171156412.png" alt="image-20230717115637369"></p><h3 id="关于AOTGenericReferences"><a href="#关于AOTGenericReferences" class="headerlink" title="关于AOTGenericReferences"></a>关于AOTGenericReferences</h3><p>​<code>HybridCLR/generate/AOTGenericReference</code> 命令生成的<code>AOTGenericReferences.cs</code>文件中包含了应该补充元数据的assembly列表.分为三部分</p><ul><li>1是需要补充的元数据assembly</li><li>2是<strong>AOT中用到的</strong>泛型类</li><li>3是<strong>AOT中用到的</strong>泛型方法</li></ul><h2 id="遇到的一些问题和注意事项"><a href="#遇到的一些问题和注意事项" class="headerlink" title="遇到的一些问题和注意事项"></a>遇到的一些问题和注意事项</h2><h4 id="IL2CPP泛型共享代码"><a href="#IL2CPP泛型共享代码" class="headerlink" title="IL2CPP泛型共享代码"></a>IL2CPP泛型共享代码</h4><blockquote><p>il2cpp为了避免泛型代码膨胀，节约内存，在保证代码逻辑正确性的情况下对于一些能够共享代码，只生成一份代码。为此引入一个概念叫<strong>泛型代码共享</strong> <a target="_blank" rel="noopener" href="https://blog.unity.com/technology/il2cpp-internals-generic-sharing-implementation">Generic Sharing</a>。 简单来说，你只要<strong>在AOT中实例化过某个泛型类或泛型函数的共享实例</strong>，你就可以在热更新代码中使用它了。</p><p>以List<T> 举例：</p><ul><li>可以使用AOT中使用过的任何List的实例化类型。例如你在AOT里用过List<vector3>,则热更新里也可以用</li><li>可以使用任意List<HotUpdateEnum>。 只需要你在AOT里实例化某一个List&lt;相同underlying type的枚举类型&gt;。</li><li>可以使用任意引用类型的泛型参数List<HotUpdateClass>。 只需要你在AOT里实例化过 List<object>(或任意一个引用泛型参数如List<string>)</li></ul></blockquote><p>注意最后一条,只要实例化一个了任意引用类型,那么在热更中可以不用补充元数据</p><p><a target="_blank" rel="noopener" href="https://hybridclr.doc.code-philosophy.com/docs/basic/aotgeneric#%E5%9F%BA%E4%BA%8E%E8%A1%A5%E5%85%85%E5%85%83%E6%95%B0%E6%8D%AE%E7%9A%84%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%8A%80%E6%9C%AFhybridclr%E7%9A%84%E4%B8%93%E5%88%A9%E6%8A%80%E6%9C%AF">基于补充元数据的泛型函数实例化技术hybridclr的专利技术</a></p><h4 id="热更入口函数的坑"><a href="#热更入口函数的坑" class="headerlink" title="热更入口函数的坑"></a>热更入口函数的坑</h4><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202307191755070.png" alt="image-20230719175528223"></p><p>如上图所示,如果直接在入口函数调用了泛型操作,那么会报错,报错原因就是没找到元数据</p><p>那么为什么会出现这个问题呢,因为已经补充元数据了</p><p>这是因为hybridclr是以<code>methodbody</code>解释执行的,也就是整ge解释属于这个方法里面内容,例如<code>start方法</code>里面如果包含了泛型,先整个解释这个start方法,发现没有补充元数据所以就报错了,直接log函数都不打印</p><p><code>解决办法</code>就是用个方法包裹一层,先补充元数据,后面就没啥问题了</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> 热更新 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 热更新 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>热更新系列(一)——.Net工作机制</title>
      <link href="/2022/09-22-%E7%83%AD%E6%9B%B4%E6%96%B001/"/>
      <url>/2022/09-22-%E7%83%AD%E6%9B%B4%E6%96%B001/</url>
      
        <content type="html"><![CDATA[<h2 id="Net-概念"><a href="#Net-概念" class="headerlink" title="Net 概念"></a>Net 概念</h2><h3 id="什么是-NET-NET-framework-NET-core-NET-Standard"><a href="#什么是-NET-NET-framework-NET-core-NET-Standard" class="headerlink" title="什么是.NET .NET framework .NET core .NET Standard"></a>什么是.NET .NET framework .NET core .NET Standard</h3><ol><li><p><code>.NET framework</code>是针对<code>windows</code>平台下的应用.现在的版本是.NET Framework 4.8，很有可能这是.NET Framework的最后一个版本了。在未来并没有计划有新的.NET Framework版本</p></li><li><p><code>.NET Core</code>是开源跨平台开发,NET Core 3.0支持了WPF和Windows Forms。.NET Core 3.0 还支持UWP，WPF和Windows Forms三者的开发。</p></li><li><p><code>.Net Standard</code> 是一个规范，它定义了Net Framewoek和Net Core必须实现的Api,它的出现为各种平台上开发的.Net人员解决了代码共享问题，但是仅用于开发类库，意思就是说如果你的类库是Net Standard规范的，那么此类库既可以是Net Framewoek也可以是Net Core类库.</p></li><li><p><code>.NET</code>是.NET Framework和.NET Core核心的结合，旨在统一.NET平台，微软将其描述为“.NET的未来”</p></li></ol><h3 id="Net工作过程原理"><a href="#Net工作过程原理" class="headerlink" title="Net工作过程原理"></a>Net工作过程原理</h3><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209221457728.png" alt="image-20220922145709673"></p><h4 id="CLI-Common-Language-Infrastructure-公共语言基础"><a href="#CLI-Common-Language-Infrastructure-公共语言基础" class="headerlink" title="CLI(Common Language Infrastructure) 公共语言基础"></a>CLI(Common Language Infrastructure) 公共语言基础</h4><p><strong>是为了实现.Net跨语言而定下的基础,<strong>任何语言只要实现这一套标准就可以运行在.Net之上.比如</strong>Mono</strong></p><p>CLI已经成为了国际计算机标准规范,<a target="_blank" rel="noopener" href="https://www.ecma-international.org/publications-and-standards/standards/ecma-335/">ECMA-335 - Ecma International (ecma-international.org)</a></p><p>CLI包括CLS和CTS:</p><h5 id="CTS-Common-Type-System-公共类型系统"><a href="#CTS-Common-Type-System-公共类型系统" class="headerlink" title="CTS(Common Type System) 公共类型系统"></a>CTS(Common Type System) 公共类型系统</h5><p>解决不同语言数据类型不同的问题，如C#中的整形是int,而VB.net中的整形是Integer，通过CTS我们把它们两个编译成通用的类型Int32。</p><p>   所有的.NET语言共享这一类型系统，在它们之间实现对接，简单说：就是把各种语言中的不同数据类型，转换成统一的通用的数据类型。</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209221436628.png" alt="image-20220922143648598"></p><h5 id="CLS-Common-Language-Specification-公共语言规范"><a href="#CLS-Common-Language-Specification-公共语言规范" class="headerlink" title="CLS(Common Language Specification) 公共语言规范"></a>CLS(Common Language Specification) 公共语言规范</h5><p>​    是一种最低的语言标准，定义了实现.Net语言的规则 属性 行为</p><p>​    凡是遵守这个标准的语言在.NET框架下都可以实现互相调用。简单说：就是把各种语言转换成统一的语法规范</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209221433607.png" alt="image-20220922143346569"></p><h4 id="CLR-Common-Language-Runtime-公共语言运行时"><a href="#CLR-Common-Language-Runtime-公共语言运行时" class="headerlink" title="CLR(Common Language Runtime) 公共语言运行时"></a>CLR(Common Language Runtime) 公共语言运行时</h4><p>可以理解为.Net虚拟机 Mono跨平台就是扩展了原来的CLR,现在.Net能跨平台也是增加了对其他平台的执行.</p><p>提供了必要的运行时服务,比如自动化内存管理,异常处理,垃圾回收等等,是.NET运行的核心</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209221448384.png" alt="image-20220922144808340"></p><h4 id="CIL-Common-Intermediate-Language-公共中间语言"><a href="#CIL-Common-Intermediate-Language-公共中间语言" class="headerlink" title="CIL(Common Intermediate Language) 公共中间语言"></a>CIL(Common Intermediate Language) 公共中间语言</h4><p>也称为<code>IL</code> <code>MSIL</code>,基于堆栈，又支持面向对象,运行在虚拟机之上</p><p>CLR就是来解释执行CIL的</p><p>CLR的编译过程：</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209221109092.png" alt="202202151744878"></p><h4 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/szlblog/p/11803623.html">Net Framework,Net Core 和 Net Standard 区别 - 乐途 - 博客园 (cnblogs.com)</a></p><p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/standard/net-standard">.NET Standard | Microsoft Docs</a></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/kebi007/article/details/109616747">NET 5.0 正式版发布了！_dotNet全栈开发-CSDN博客</a></p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xmyjcs/p/10381655.html">C# .NET .NET Framework .NET CORE 等的关系简介 - 陈松（Andy） - 博客园 (cnblogs.com)</a></p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/1996V/p/9037603.html">通俗易懂，什么是.NET?什么是.NET Framework？什么是.NET Core? - 小曾看世界 - 博客园 (cnblogs.com)</a></p><h2 id="Mono和IL2CPP"><a href="#Mono和IL2CPP" class="headerlink" title="Mono和IL2CPP"></a>Mono和IL2CPP</h2><h3 id="Mono"><a href="#Mono" class="headerlink" title="Mono"></a>Mono</h3><p>当年Net的CLR只是针对于Window平台,使得与使用Net的不能实现跨平台,Mono扩展了.Net的CLR,在很多平台实现了一遍,所以可以使用Mono就可以跨平台了</p><p>这也是当时Unity为什么选中Mono的原因</p><p>特征</p><ol><li>实现Mono vm比较麻烦 有多少个平台 就要在对应平台上实现一次 有时还不能完全能实现</li><li>Mono明显的版本跟不上C#版本,这也是Unity 之前的问题 一直是Net2.0,现在能用.Net standard2.1,但是微软已经是.Net6了(原因就是实现困难)</li><li>Mono使用Jit编译 所以构建很快</li><li>APP Store发布规定：全新App必须在15年2月1日支持64位CPU,Unity引擎4.6.2之前的版本采用Mono的AOT机制提前将C#代码编译为机器识别的二进制代码，Unity官方为了支持IOS平台下64位的APP游戏，4.6.2之后的版本采用IL2CPP机制编译和处理IOS平台下的游戏,现在大多数都要求64位了,Unity的Mono是无法生成64位应用</li></ol><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209221516463.png" alt="image-20220922151650413"></p><h3 id="IL2CPP"><a href="#IL2CPP" class="headerlink" title="IL2CPP"></a>IL2CPP</h3><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209221520180.png" alt="image-20220922152005123"></p><p>从上图可以看到,IL2CPP将生成的IL有重新编译生成了C++代码,然后由各个平台的C++编译器编译,IL2CPP VM只是实现了垃圾回收,内存管理<br> 特征</p><ol><li>相比Mono, 代码生成有很大的提高</li><li>可以调试生成的C++代码</li><li>程序的运行效率比Mono高，运行速度快</li><li>多平台移植非常方便</li><li>相比Mono构建应用慢</li><li>只支持AOT(Ahead of Time)编译</li></ol><h4 id="题外话"><a href="#题外话" class="headerlink" title="题外话:"></a>题外话:</h4><p>Q:为什么unity的mono不支持64位打包</p><p>A:unity使用的是mono下的一个分支,不是完全的mono   Unity uses a <a target="_blank" rel="noopener" href="https://github.com/Unity-Technologies/mono">fork</a> of the open source <a target="_blank" rel="noopener" href="https://www.mono-project.com/">Mono project</a>   <a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2021.3/Manual/Mono.html">Mono overview - Unity 手册</a></p><p>chatgpt a: </p><blockquote><p>Unity中使用的Mono是一个跨平台的实现了.NET Framework的运行时环境。在Windows平台上，Unity默认使用的是32位版本的Mono，因为它可以在所有版本的Windows上运行。</p><p>虽然有64位版本的Mono，但Unity并没有直接集成这个版本。这是因为Unity使用的Mono版本是定制的，而且在其它平台上，如macOS和Linux，也只支持32位版本的Mono。为了确保跨平台的兼容性，Unity团队决定只支持32位版本的Mono。</p><p>虽然在Windows上使用64位版本的Mono可能会提高性能，但是这样会使得Windows之外的平台上的性能变差，因为那里只有32位版本可用。因此，Unity团队为了平衡跨平台的兼容性和性能，选择了使用32位版本的Mono。</p></blockquote><blockquote><p>Unity和Godot都使用Mono作为它们的脚本运行时环境，但它们实现Mono的方式略有不同。</p><p>在Unity中，Mono是通过Unity自己的Mono实现，即Unity的Mono是一个轻量级的Mono实现。 Unity的Mono实现仅包含Mono的一个子集，包括Mono C#编译器、Mono运行时环境和C#标准库的一个子集。因此，Unity的Mono仅支持使用该子集的C#语言功能。</p><p>另一方面，Godot使用官方的Mono实现，该实现包括完整的Mono运行时环境和C#标准库，因此它支持完整的C#语言功能。此外，Godot的Mono支持C# 8.0和C# 9.0的一些新特性，而Unity的Mono仅支持C# 7.3的特性。</p><p>总之，虽然Unity和Godot都使用Mono作为脚本运行时环境，但它们实现Mono的方式略有不同，因此它们对C#语言的支持也略有不同</p></blockquote><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/352463394">【Unity游戏开发】Mono和IL2CPP的区别 - 知乎 (zhihu.com)</a></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/19972689">Unity将来时：IL2CPP是什么？ - 知乎 (zhihu.com)</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><code>Assembly-CSharp.dll和Assembly-CSharp-firstpass.dll</code></p><p>firstpass表示先编译，Editor表示放在Editor文件夹下的脚本。</p><p>根据官方的解释，它们的编译顺序如下： </p><ol><li><p>Assembly-CSharp-filepass.csproj：所有在Standard Assets、Pro Standard Assets或者Plugins文件夹中的脚本</p></li><li><p>Assembly-CSharp-Editor-filepass.csproj：所有在Standard Assets&#x2F;Editor、Pro Standard Assets&#x2F;Editor或者Plugins&#x2F;Editor文件夹中的脚本产生工程文件</p></li><li><p>Assembly-CSharp.csproj：所有在Assets&#x2F;Editor外面的，并且不在(1),(2)中的脚本文件(一般这些脚本就是我们自己写的非编辑器扩展脚本)会产生工程文件</p></li><li><p>Assembly-CSharp-Editor-vs.csproj：所有在Assets&#x2F;Editor中的脚本产生一个工程文件。</p></li><li><p><strong>JIT(Just in Time) 动态(即时)编译，边运行边编译,把代码编译成IL 运行时候逐条翻译成原生码CPU执行</strong></p></li><li><p><strong>AOT(Ahead Of Time)运行前编译, 编译成IL之后,然后翻译成原生代码</strong></p></li></ol><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209221110375.png" alt="202202151744735"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209221110463.png" alt="202202151744285"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209221110583.png" alt="202202151744709"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209221855906.png" alt="202202151744276"></p><h3 id="ILRuntime"><a href="#ILRuntime" class="headerlink" title="ILRuntime"></a>ILRuntime</h3><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209221111535.png" alt="ilruntime111"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209221112241.png" alt="202202151744255"></p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> 热更新 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 热更新 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity &amp; IOS</title>
      <link href="/2022/09-14-Unity2IOS/"/>
      <url>/2022/09-14-Unity2IOS/</url>
      
        <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h3><p>苹果电脑安装Xcode,苹果手机或者ipad</p><h3 id="Unity"><a href="#Unity" class="headerlink" title="Unity"></a>Unity</h3><p>安装IOS模块</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>证书:development证书或者distribute证书和对应描述文件(.mobileprovision)</p><h2 id="打包苹果流程"><a href="#打包苹果流程" class="headerlink" title="打包苹果流程"></a>打包苹果流程</h2><h3 id="注意-不要有中文路径"><a href="#注意-不要有中文路径" class="headerlink" title="注意:不要有中文路径!!!"></a>注意:不要有中文路径!!!</h3><p>我使用的是windows电脑发布工程,然后使用Mac电脑发布,为了方便,我在window磁盘添加了一个共享文件夹,使用Mac访问共享文件夹,Xcode直接打开工程,这样就不用传来传去了. 当然也可以直接使用MacUnity发布</p><ul><li>Win中Unity中发布到共享文件夹</li><li>Mac中XCode直接打开共享文件夹中工程</li></ul><h3 id="Unity中发布工程"><a href="#Unity中发布工程" class="headerlink" title="Unity中发布工程"></a>Unity中发布工程</h3><p>设置Icon,最好用一个1024*1024的图,直接设置为<code>DefaultIcon</code>就行了</p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209171524658.png" alt="image-20220917152425621"></p><p>设置Bundle Identifier,<code>一定要和证书保持一致</code>(也就是和你苹果后台app包名一致)</p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209171527672.png" alt="image-20220917152741643"></p><p>然后直接Build就可以了,打出的是一个Xcode工程,<strong>要求发布的文件夹是一个空文件,所以重复打包同一个文件夹,最好删除原来的或者把里面的文件都删了</strong></p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209171548400.png" alt="image-20220917154844374"></p><h3 id="XCode打包"><a href="#XCode打包" class="headerlink" title="XCode打包"></a>XCode打包</h3><p><code>一定要注意磁盘空间够用,不然有很多问题,确保有10G以上</code></p><p>我使用的windows系统build xcode工程到一个共享文件夹,然后mac通过局域网直接访问windows 里面的工程</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209171546838.png" alt="image-20220917154641798"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209171548281.png" alt="image-20220917154807198"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209171549529.png" alt="image-20220917154926468"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209171552466.png" alt="image-20220917155247395"></p><p>可以使用自动签名登录一下开发者账号,也可以使用证书配置文件</p><p>点击<code>Provisioning Profile</code>,选择对应配置文件就可以</p><p>然后点击<strong>Product</strong>,如果想直接跑在手机上,点击run,如果需要发布ipa或者上传App StoreConnect就点击<code>Archive</code></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209171557015.png" alt="image-20220917155726924"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209171610935.png" alt="image-20220917161010874"></p><ul><li><p>App Store Connetct ：导出的ipa 包可以发布到App Store或者在越狱的iOS设备。</p></li><li><p>Ad Hoc ：安装测试用的,有udid限制。该ipa包不能提交到AppStore.</p></li><li><p>Enterprise ：导出的ipa 包是用于企业应用账号的，个人账号是无法选择的。而且没有任何udid设备数量限制。</p></li><li><p>Development ：导出的ipa包是dev证书编译的，其实这个和第二Ad Hoc很类似，唯一区别这个用dev证书编译的，而Ad Hoc用的是dis证书编译的。</p></li></ul><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209171610065.png" alt="image-20220917161050016"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209171616563.png" alt="image-20220917161601509"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209171616387.png" alt="image-20220917161647336"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209171617638.png" alt="image-20220917161715583"></p><p>最后导出到目标文件夹就可以了</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209171618989.png" alt="image-20220917161818948"></p><p>然后就可以安装了</p><h4 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h4><ul><li>第一方式是直接手机连接上Mac,XCode-&gt;Wondow-&gt;Diveces and Simulators</li></ul><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209171621873.png" alt="image-20220917162105757"></p><ul><li>第二种通过<code>蒲公英平台</code>上传下载,不会的自行搜索</li></ul><h3 id="修改代码重新打包"><a href="#修改代码重新打包" class="headerlink" title="修改代码重新打包"></a>修改代码重新打包</h3><p>unity重新build如果又重新把项目拷贝到mac,那么之前的设置都没了很麻烦, 大部分我们只要把新生成的copy,然后覆盖<code>Classes</code> <code>Data</code> <code>Library</code> 文件夹</p><p><code>Classes</code> 是程序文件(il2cpp,生成的cpp)</p><p><code>Data</code> 跟其他差不多</p><p><code>Library</code> 是一些插件包 一般也不会修改这个</p><h2 id="Unity与IOS交互"><a href="#Unity与IOS交互" class="headerlink" title="Unity与IOS交互"></a>Unity与IOS交互</h2><table><thead><tr><th>扩展名</th><th>说明</th></tr></thead><tbody><tr><td>.h</td><td>头文件，它包含类名，类继承的父类，还有方法和变量的声明。它定义的类的成员变量以及方法等等是公开的，外部是可以访问的。</td></tr><tr><td>.m</td><td><strong>是纯Object-C 文件</strong>(.m只能调用纯Object-C的类，不能调用混合的). 实现文件，可以包含Objective-C和C代码。同时，它是对.h文件中方法的实现外部不能访问,</td></tr><tr><td>.mm</td><td><strong>是Object-C和C++混合</strong>(.mm可以调用Object-C的，也可以调用C++的). 实现文件，和.m文件类似，唯一的不同点就是，除了可以包含Objective-C和C代码以外，<strong>还可以包含C++代码</strong>。仅在你的Objective-C代码中确实需要使用C++类或者特性的时候才用这种扩展名。</td></tr></tbody></table><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/herenzhiming/articles/7920386.html">Objective-c中.m、.h、.mm文件 - 何人之名 - 博客园 (cnblogs.com)</a></p><p>C#可以调用C和C++代码，而C和C++可以调用Objective-C代码，这里我们将.m后缀改为.mm，这样，就可以在里面编写C和C++代码.</p><p>Unity做插件就是使用<code>.mm文件</code>,调用的都是c和c++代码</p><p><strong>什么是<code>extern &quot;C&quot;</code></strong></p><p>extern “C” 是C++ 指令,是告诉编译器 ,这里面的代码用C规则来编译</p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_36817189/article/details/110423243">extern “C“的作用及理解_米碎师兄的博客</a></p><h3 id="Unity调用IOS"><a href="#Unity调用IOS" class="headerlink" title="Unity调用IOS"></a>Unity调用IOS</h3><p>Unity 中是直接调用IOS声明的方法,不用找到类</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//固定写法</span></span><br><span class="line">[<span class="meta">DllImport(<span class="string">&quot;__Internal&quot;</span>)</span>]</span><br><span class="line"><span class="comment">//在mm或者.h中声明的方法名字 必须保持一致</span></span><br><span class="line"><span class="comment">//c# extern关键字 表示这个方法由外部实现,简单说这个方法是外部某个文件某个dll实现的 自己不需要实现</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">UnityCallIOS</span>()</span>; </span><br></pre></td></tr></table></figure><p>OC代码基本都是面向对象的,即需要new一个对象才能调用,但是C不用,<strong>Unity直接调用C代码</strong>,然后再对应代码 newOC对象.</p><p>调用代码中写的方法,需要使用符合C代码写法.</p><h3 id="IOS调用Unity"><a href="#IOS调用Unity" class="headerlink" title="IOS调用Unity"></a>IOS调用Unity</h3><p> <code>UnitySendMessage(const char *obj, const char *method, const char *msg)</code></p><p>第一个参数是物体名字 第二个参数是物体上面的方法(private也可以) 第三个参数</p><h3 id="示例-使用Scheme-url-打开其他app"><a href="#示例-使用Scheme-url-打开其他app" class="headerlink" title="示例(使用Scheme url 打开其他app)"></a>示例(使用Scheme url 打开其他app)</h3><ol><li>在xcode中声明一个.h文件和.mm文件</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;UnityAppController.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span> <span class="comment">//引入库文</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="comment">//使用C语言编译</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局固定字段声明</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * UnityGoName=<span class="string">&quot;NativeManager&quot;</span>; <span class="comment">//unity中接收信息物体</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * UnityMethodName=<span class="string">&quot;NativeToUnity&quot;</span>; <span class="comment">//物体上面的方法名 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法声明</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">ShowToast</span><span class="params">(NSString *message,<span class="type">float</span> duration)</span>; <span class="comment">//显示toast</span></span><br><span class="line">    BOOL <span class="title function_">OpenScheme</span><span class="params">(NSString *scheme)</span>;     <span class="comment">//打开某个app 带有返回值</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">UnityCallIOS</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* key,<span class="type">const</span> <span class="type">char</span>* args)</span>; <span class="comment">//unity调用ios</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">IOS2Unity</span><span class="params">(NSString *msg)</span>;<span class="comment">//ios发消息给unity</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;MyIOSBridge.h&quot;</span> <span class="comment">//引入头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UnityCallIOS</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* cmd,<span class="type">const</span> <span class="type">char</span>* args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//得到指令</span></span><br><span class="line">    NSString *strcmd=[NSString stringWithUTF8String:cmd];</span><br><span class="line">    <span class="comment">//把参数按照 | 切分</span></span><br><span class="line">    NSArray *strArgs=[[NSString stringWithUTF8String:args]componentsSeparatedByString:@<span class="string">&quot;|&quot;</span>];</span><br><span class="line">    <span class="comment">//NSLog(@&quot;指令-&gt;%@&quot;,strcmd);</span></span><br><span class="line">    <span class="comment">//如果指令是Toast </span></span><br><span class="line">    <span class="keyword">if</span>([strcmd isEqualToString:@<span class="string">&quot;Toast&quot;</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//参数1: 消息</span></span><br><span class="line">        <span class="comment">//参数2: 持续时间</span></span><br><span class="line">        NSString *msg=strArgs[<span class="number">0</span>];</span><br><span class="line">        <span class="type">float</span> duration=[strArgs[<span class="number">1</span>] floatValue];</span><br><span class="line">        ShowToast(msg, duration);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果指令是OpenScheme </span></span><br><span class="line">    <span class="keyword">if</span>([strcmd isEqualToString:@<span class="string">&quot;OpenScheme&quot;</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//参数1:scheme url</span></span><br><span class="line">        <span class="comment">//参数2:app 名字</span></span><br><span class="line">        NSString *msg=strArgs[<span class="number">0</span>];</span><br><span class="line">        NSString *appName=strArgs[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//NSLog(@&quot;scheme指令-&gt;%@ 程序=%@&quot;,msg,appName);</span></span><br><span class="line">        BOOL result= OpenScheme(msg);</span><br><span class="line">        <span class="keyword">if</span>(result==NO)</span><br><span class="line">        &#123;</span><br><span class="line">            ShowToast([NSString stringWithFormat:@<span class="string">&quot;没有安装该App:%@&quot;</span>,appName], <span class="number">2.0f</span>);</span><br><span class="line">            <span class="comment">//发送一个消息到unity</span></span><br><span class="line">            IOS2Unity([NSString stringWithFormat:@<span class="string">&quot;noapp|%@&quot;</span>,appName]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送消息到unity</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IOS2Unity</span><span class="params">(NSString *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//会有一帧的延迟</span></span><br><span class="line">    <span class="comment">//IPhonePlayer表示是IPhonePlayer平台</span></span><br><span class="line">    msg=[NSString stringWithFormat:@<span class="string">&quot;IPhonePlayer|%@&quot;</span>,msg];</span><br><span class="line">    UnitySendMessage(UnityGoName, UnityMethodName, msg.UTF8String);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Toast</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">ShowToast</span><span class="params">(NSString *message, <span class="type">float</span> toastLengthInSeconds)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// NSString *message = [NSString stringWithUTF8String:toastText];</span></span><br><span class="line">    UIAlertController *alert = [UIAlertController alertControllerWithTitle:nil</span><br><span class="line">                                                                   message:message</span><br><span class="line">                                                            preferredStyle:UIAlertControllerStyleAlert];</span><br><span class="line">    UIViewController *rootViewController = UnityGetGLViewController();</span><br><span class="line">    [rootViewController presentViewController:alert animated:YES completion:nil];</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, toastLengthInSeconds * NSEC_PER_SEC), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [alert dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打开某个app 使用的是scheme url</span></span><br><span class="line">BOOL <span class="title function_">OpenScheme</span><span class="params">(NSString *scheme)</span></span><br><span class="line">&#123;</span><br><span class="line">    NSURL *url = [NSURL URLWithString:scheme];</span><br><span class="line">    <span class="keyword">if</span>([[UIApplication sharedApplication] canOpenURL:url])&#123;</span><br><span class="line">        [[UIApplication sharedApplication] openURL:url];</span><br><span class="line">            <span class="keyword">return</span> YES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li><p>将两个文件导入Unity-&gt;Plugins-&gt;IOS目录</p></li><li><p>在Unity脚本</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> ____DESC:      Unity IOS 交互</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Native_IOS</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//固定写法</span></span><br><span class="line">    [<span class="meta">DllImport(<span class="string">&quot;__Internal&quot;</span>)</span>]</span><br><span class="line">    <span class="comment">//在mm或者.h中声明的方法名字 必须保持一致</span></span><br><span class="line">    <span class="comment">//c# extern 表示这个方法由外部实现,简单说这个方法是外部某个文件某个dll实现的 自己不需要实现</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 调用IOS  args用 &quot;|&quot;分割</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">UnityCallIOS</span>(<span class="params"><span class="built_in">string</span> key,<span class="built_in">string</span> args</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UnityToIOS</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> v = <span class="built_in">string</span>.Join(<span class="string">&#x27;|&#x27;</span>, args);</span><br><span class="line">        UnityCallIOS(key, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> ____DESC:      与原生平台交互管理器</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NativeManager</span> : <span class="title">MonoSingleton</span>&lt;<span class="title">NativeManager</span>&gt;, <span class="title">IManager</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> System.Action&lt;RuntimePlatform, <span class="built_in">string</span>[]&gt; OnReceiveNativeMsg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Native_IOS native_IOS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> IsInit &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RuntimePlatform currRuntimePlatform;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Init</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.gameObject.name = <span class="keyword">nameof</span>(NativeManager);</span><br><span class="line">        currRuntimePlatform = Application.platform;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (currRuntimePlatform == RuntimePlatform.IPhonePlayer)</span><br><span class="line">            native_IOS = <span class="keyword">new</span> Native_IOS();</span><br><span class="line">        SetDontDestoryOnload();</span><br><span class="line">        IsInit = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 接收到其他平台发来的消息,可以是私有方法</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;msg&quot;&gt;</span>msg包含一个|<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">NativeToUnity</span>(<span class="params"><span class="built_in">string</span> msg</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//用|切分 第0个是平台</span></span><br><span class="line">        <span class="keyword">var</span> msgs = msg.Split(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (System.Enum.TryParse&lt;RuntimePlatform&gt;(msgs[<span class="number">0</span>], ignoreCase: <span class="literal">true</span>, <span class="keyword">out</span> RuntimePlatform runtimePlatform))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//其他参数 </span></span><br><span class="line">            List&lt;<span class="built_in">string</span>&gt; args = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; msgs.Length; i++)</span><br><span class="line">                args.Add(msgs[i]);</span><br><span class="line"></span><br><span class="line">            OnReceiveNativeMsg?.Invoke(runtimePlatform, args.ToArray());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            MyLog.LogError(<span class="string">$&quot;平台错误:<span class="subst">&#123;msgs[<span class="number">0</span>]&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Unity调用原生平台</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;runtimePlatform&quot;&gt;</span>平台<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>key<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;args&quot;&gt;</span>参数<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UnityCallNative</span>(<span class="params">RuntimePlatform runtimePlatform, <span class="built_in">string</span> key, <span class="keyword">params</span> <span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (runtimePlatform)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> RuntimePlatform.IPhonePlayer:</span><br><span class="line">                <span class="keyword">if</span> (currRuntimePlatform == RuntimePlatform.IPhonePlayer)</span><br><span class="line">                &#123;  </span><br><span class="line">                    native_IOS.UnityToIOS(key,args);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Button btnQQ, btnWeibo, btnLofter, btnBilibili, btnNone;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//QQ</span></span><br><span class="line">    <span class="built_in">string</span> schemeQQGroup = <span class="string">&quot;mqqapi://card/show_pslcard?src_type=internal&amp;version=1&amp;card_type=group&amp;uin=1020819114&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> schemeQQGroup2 = <span class="string">&quot;tim://card/show_pslcard?src_type=internal&amp;version=1&amp;uin=1020819114&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Lofter</span></span><br><span class="line">    <span class="built_in">string</span> schemeLofter = <span class="string">&quot;lofter://qiyunyimeng.lofter.com/&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> httpLofter = <span class="string">&quot;https://qiyunyimeng.lofter.com/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//B站</span></span><br><span class="line">    <span class="built_in">string</span> schemeBilibili = <span class="string">&quot;bilibili://space/1346329729&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> httpBilibili = <span class="string">&quot;https://m.bilibili.com/space/1346329729&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//抖音</span></span><br><span class="line">    <span class="built_in">string</span> schemeDouyin = <span class="string">&quot;https://v.douyin.com/2XR7GQ2/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//微博</span></span><br><span class="line">    <span class="built_in">string</span> schemeWeibo = <span class="string">&quot;sinaweibo://userinfo?uid=5904919311&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> schemeWeibo2 = <span class="string">&quot;weibointernational://userinfo?uid=5904919311&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> httpWeibo = <span class="string">&quot;https://weibo.com/u/5904919311&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        NativeManager.Ins.Init();</span><br><span class="line">        NativeManager.Ins.OnReceiveNativeMsg += Ins_OnReceiveNativeMsg;</span><br><span class="line">        btnQQ.onClick.AddListener(() =&gt; NativeManager.Ins.UnityCallNative(RuntimePlatform.IPhonePlayer, <span class="string">&quot;OpenScheme&quot;</span>, schemeQQGroup,<span class="string">&quot;QQ&quot;</span>));</span><br><span class="line">        btnWeibo.onClick.AddListener(() =&gt; NativeManager.Ins.UnityCallNative(RuntimePlatform.IPhonePlayer, <span class="string">&quot;OpenScheme&quot;</span>, schemeWeibo2,<span class="string">&quot;weibo&quot;</span>));</span><br><span class="line">        btnLofter.onClick.AddListener(() =&gt; NativeManager.Ins.UnityCallNative(RuntimePlatform.IPhonePlayer, <span class="string">&quot;OpenScheme&quot;</span>, schemeLofter,<span class="string">&quot;lofter&quot;</span>));</span><br><span class="line">        btnBilibili.onClick.AddListener(() =&gt; NativeManager.Ins.UnityCallNative(RuntimePlatform.IPhonePlayer, <span class="string">&quot;OpenScheme&quot;</span>, schemeBilibili, <span class="string">&quot;bilibili&quot;</span>));</span><br><span class="line">        btnNone.onClick.AddListener(() =&gt; NativeManager.Ins.UnityCallNative(RuntimePlatform.IPhonePlayer, <span class="string">&quot;OpenScheme&quot;</span>, <span class="string">&quot;tt://sdfsdfdss&quot;</span>,<span class="string">&quot;tt&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接收到消息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Ins_OnReceiveNativeMsg</span>(<span class="params">RuntimePlatform platform, <span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;接收到消息:&quot;</span> + platform.ToString() + <span class="string">&quot; &quot;</span> + args[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (platform == RuntimePlatform.IPhonePlayer)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提示没有安装该app</span></span><br><span class="line">            <span class="keyword">if</span> (args[<span class="number">0</span>] == <span class="string">&quot;noapp&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//如果是qq</span></span><br><span class="line">                <span class="keyword">if</span> (args[<span class="number">1</span>] == <span class="string">&quot;QQ&quot;</span>)</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果没有微博 就直接打开微博uri</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (args[<span class="number">1</span>] == <span class="string">&quot;weibo&quot;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Application.OpenURL(httpWeibo);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (args[<span class="number">1</span>] == <span class="string">&quot;lofter&quot;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Application.OpenURL(httpWeibo);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (args[<span class="number">1</span>] == <span class="string">&quot;bilibili&quot;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Application.OpenURL(httpBilibili);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (args[<span class="number">1</span>] == <span class="string">&quot;tt&quot;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Application.OpenURL(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p>IOS使用scheme的时候需要添加白名单,不然打不开.</p><p>添加scheme的时候不用加<code>://</code></p><p>第一种添加方式</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209261938423.png" alt="image-20220926193759959"></p><p>第二种添加方式</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209261938080.png" alt="image-20220926193846672"></p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/yangxuan0261/article/details/113766453">unity-与ios交互_蝶泳奈何桥.的博客-CSDN博客_unity与ios交互</a></li><li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f397d51e4447">iOS Unity 交互（系列二）iOS调用Unity函数 iOS给Unity传值 - 简书 (jianshu.com)</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/huanguuuu1234567/article/details/78027207">定制 UnityAppController_云之逸的博客-CSDN博客</a></li><li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ba716bebab22?tdsourcetag=s_pcqq_aiomsg">Unity iOS打包之覆写UnityAppController.mm - 简书 (jianshu.com)</a></li></ul></li></ol><h2 id="问题合集"><a href="#问题合集" class="headerlink" title="问题合集"></a>问题合集</h2><h3 id="证书不受信任"><a href="#证书不受信任" class="headerlink" title="证书不受信任"></a>证书不受信任</h3><p>如果是别人给的证书那么就是以<code>.p12</code>结尾,双击就可以导入,然后再钥匙串中就可以看到</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209171602987.png" alt="image-20220917160230943"></p><p>如果证书显示不受信任</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209171604518.png" alt="image-20220917160415447"></p><p>那么需要重新下载一个  证书</p><p>地址:<a target="_blank" rel="noopener" href="https://www.apple.com/certificateauthority/">Apple PKI - Apple</a>    下载之后双击按照就可以</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209171607147.png" alt="image-20220917160718076"></p><h3 id="Distribution-APP过程出现问题"><a href="#Distribution-APP过程出现问题" class="headerlink" title="Distribution APP过程出现问题"></a>Distribution APP过程出现问题</h3><p>出现<code>The data couldn’t be read because it isn’t in the correct format</code>或者<code>zip faild</code>什么的,都先检查是否存贮空间不够了</p><h3 id="打出的IPA文件名是ProductName"><a href="#打出的IPA文件名是ProductName" class="headerlink" title="打出的IPA文件名是ProductName"></a>打出的IPA文件名是ProductName</h3><p>ProductName 就是BundleName 游戏名字是Bundle Diaplay Name</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209171633157.png" alt="image-20220917163355081"></p><p>在Unity中设置了<strong>Productname</strong> 如果是英文名 好像不会出现这个错误,如果是中文,那么就有可能出现这个名字</p><ul><li>可以在Xcode工程中改</li><li>也可以在Unity导出的时候改 <code>Info.plist</code>文件</li></ul><p>这个时候我们可以在打包出IOS的时候自动设置一下,在unity 新建一个Editor脚本,加上代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">PostProcessBuild</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnPostProcessBuild</span>(<span class="params">BuildTarget buildTarget, <span class="built_in">string</span> pathToBuiltProject</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (buildTarget == BuildTarget.iOS)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> pbxProjectPath = PBXProject.GetPBXProjectPath(pathToBuiltProject);</span><br><span class="line">            <span class="comment">//xcode对象读取的就是xxxx.xcodeproj下面的project.pbxproj</span></span><br><span class="line">            <span class="comment">//PBXProject pbxProject = new PBXProject();</span></span><br><span class="line">            <span class="comment">//pbxProject.ReadFromFile(pbxProjectPath);</span></span><br><span class="line">            <span class="comment">//string targetGUID = pbxProject.GetUnityMainTargetGuid();</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//var configNames = pbxProject.BuildConfigNames();</span></span><br><span class="line">            <span class="comment">//foreach (var configName in configNames)</span></span><br><span class="line">            <span class="comment">//&#123;</span></span><br><span class="line">            <span class="comment">//    var config = pbxProject.BuildConfigByName(targetGUID, configName);</span></span><br><span class="line">            <span class="comment">//    pbxProject.SetBuildProperty(config, &quot;PRODUCT_NAME_APP&quot;, &quot;qqym222&quot;);</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">            <span class="comment">//pbxProject.WriteToFile(pbxProjectPath);</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> identifiers = PlayerSettings.GetApplicationIdentifier(BuildTargetGroup.iOS).Split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            <span class="keyword">var</span> bundleName = identifiers.Length &gt; <span class="number">1</span> ? identifiers[identifiers.Length - <span class="number">1</span>] : identifiers[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *修改ProductName 打包发现BundleName如果是中文显示的就是&quot;ProductName&quot; 而不是app名字</span></span><br><span class="line"><span class="comment">             *设置称为包名最后一个名字 com.aaaa.bbb 那么就是bbb</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//直接替换所有</span></span><br><span class="line">            <span class="built_in">string</span> pbxProjectContent = File.ReadAllText(pbxProjectPath);</span><br><span class="line">            pbxProjectContent = pbxProjectContent.Replace(<span class="string">&quot;PRODUCT_NAME_APP = ProductName&quot;</span>, <span class="string">$&quot;PRODUCT_NAME_APP = <span class="subst">&#123;bundleName&#125;</span>&quot;</span>);</span><br><span class="line">            File.WriteAllText(pbxProjectPath, pbxProjectContent);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//读取修改Info.plist 是以键值对存在的</span></span><br><span class="line">            <span class="comment">//string plistPath = pathToBuiltProject + &quot;/&quot; + &quot;Info.plist&quot;;</span></span><br><span class="line">            <span class="comment">//PlistDocument plist = new PlistDocument();</span></span><br><span class="line">            <span class="comment">//plist.ReadFromFile(plistPath);</span></span><br><span class="line">            <span class="comment">//plist.root.SetString(&quot;CFBundleName&quot;, bundleName);</span></span><br><span class="line">            <span class="comment">//plist.WriteToFile(plistPath);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://xmanyou.com/unity-using-script-modify-xcode-project/">#Unity# 在编辑器扩展中用PostProcessBuildAttribute来修改XCode工程的Product Name (xmanyou.com)</a></p><h3 id="使用www-UnityWebRequest-无法读取SteamingAssets中的文件"><a href="#使用www-UnityWebRequest-无法读取SteamingAssets中的文件" class="headerlink" title="使用www(UnityWebRequest)无法读取SteamingAssets中的文件"></a>使用www(UnityWebRequest)无法读取SteamingAssets中的文件</h3><p><a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2020.3/Manual/StreamingAssets.html">流媒体资源 - Unity 手册</a></p><blockquote><p><code>Application.streamingAssetsPath</code> 返回的位置因平台而异：</p><ul><li>大多数平台（Unity Editor、Windows、Linux 播放器、PS4、Xbox One、Switch）使用 <code>Application.dataPath + &quot;/StreamingAssets&quot;</code>。</li><li>macOS 播放器使用 <code>Application.dataPath + &quot;/Resources/Data/StreamingAssets&quot;</code>。</li><li>iOS 使用 <code>Application.dataPath + &quot;/Raw&quot;</code>。</li><li>Android 使用经过压缩的 APK&#x2F;JAR 文件中的文件：<code>&quot;jar:file://&quot; + Application.dataPath + &quot;!/assets&quot;</code>。</li></ul><p>要在无法直接访问流媒体资源文件的平台（如 Android 和 WebGL）上读取流媒体资源，请使用 <a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2020.3/ScriptReference/Networking.UnityWebRequest.html">UnityWebRequest</a>。有关示例，请参阅 <a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2020.3/ScriptReference/Application-streamingAssetsPath.html">Application.streamingAssetsPath</a>。</p><p>在许多平台上，流媒体资源文件夹位置是只读的；您不能在运行时在这些位置修改或写入新文件。请使用 <a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2020.3/ScriptReference/Application-persistentDataPath.html">Application.persistentDataPath</a> 来获取可写的文件夹位置。</p></blockquote><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209171710730.jpeg"></p><p><strong>即使有些平台可以用IO在SteamingAssets进行写入操作,但是最好不要这么做</strong></p><p>IOS与Android不同,IOS需要在前面加一个 <code>file://</code>   <code>Android是经过压缩的 所以不能直接IO读取 要使用www 加上&quot;jar:file://&quot;协议</code></p><p><strong><code>用WWW类加载本地，要注意各个平台路径需要加的访问名称，例如Android平台的路径前要加&quot;jar:file://&quot;，其他平台使用&quot;file://&quot;</code></strong></p><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/59558c02a4f0">Unity安卓、iOS、PC、Mac读写目录 - 简书 (jianshu.com)</a></p><h3 id="The-App-Store-Icon-in-the-asset-catalog-in-‘qyym-app’-can’t-be-transparent-nor-contain-an-alpha-channel"><a href="#The-App-Store-Icon-in-the-asset-catalog-in-‘qyym-app’-can’t-be-transparent-nor-contain-an-alpha-channel" class="headerlink" title="The App Store Icon in the asset catalog in ‘qyym. app’ can’t be transparent nor contain an alpha channel"></a>The App Store Icon in the asset catalog in ‘qyym. app’ can’t be transparent nor contain an alpha channel</h3><p>这个报错原因是图标有透明或者有透明通道</p><ul><li><p>方法一:</p><p>直接把unity icon 图标搞成jpg然后再打包</p></li><li><p>方法二:</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202210111701250.png" alt="image-20221011170141146"></p><p>把每个图片用windows自带画图编辑保存(画图保存自然会丢失a通道)</p></li></ul><h3 id="The-bundle-at-‘my-app-Frameworks-UnityFramework-framework’-contains-disallowed-file-‘Frameworks’"><a href="#The-bundle-at-‘my-app-Frameworks-UnityFramework-framework’-contains-disallowed-file-‘Frameworks’" class="headerlink" title="The bundle at ‘my.app&#x2F;Frameworks&#x2F;UnityFramework.framework’ contains disallowed file ‘Frameworks’."></a>The bundle at ‘my.app&#x2F;Frameworks&#x2F;UnityFramework.framework’ contains disallowed file ‘Frameworks’.</h3><p><del>就是不能嵌套包含,这个问题不知出在哪,我自己打包的时候没啥问题,用火星人工具打包出现了问题</del></p><p>新的解决方案:将ks广告设置为动态库</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202310221213469.png" alt="屏幕截图 2023-10-22 121246"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202310221214471.png" alt="屏幕截图 2023-10-22 121415"></p><p>最后点击Add Files重新添加相应的Framework</p><p><del>解决方案</del></p><ol><li>XCode在上传testflight前会先<strong>Archive</strong>，首先先在Achieve成功后的项目中右键<strong>Show in Finder</strong></li></ol><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202210111705295.png" alt="image-20221011170555053"></p><ol start="2"><li>在.xcarchive文件点右键<strong>显示包内容</strong></li></ol><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202210111706795.png" alt="image-20221011170618609"></p><ol start="3"><li>在Products&#x2F;Applications&#x2F;xx.app文件再点右键<strong>显示包内容</strong></li></ol><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202210111706436.png" alt="image-20221011170632329"></p><ol start="4"><li>删除Frameworks&#x2F;UnityFramework.framework&#x2F;Frameworks文件夹</li></ol><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202210111706957.png" alt="image-20221011170643670"></p><ol start="5"><li>再重新上传testflight就可以成功上传了！</li></ol><p>以上这些步骤可以用shell命令来处理，步骤如下：</p><p><strong>在Build Phases下新增Run Script，并添加以下代码：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span>            </span><br><span class="line"><span class="string">&quot;<span class="variable">$&#123;CONFIGURATION_BUILD_DIR&#125;</span>/<span class="variable">$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;</span>/Frameworks/UnityFramework.framework/&quot;</span> </span><br><span class="line"><span class="keyword">if</span> [[ -d <span class="string">&quot;Frameworks&quot;</span> ]]; <span class="keyword">then</span> </span><br></pre></td></tr></table></figure><p>转自：<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://www.weixiuzhan.cn/news/show-29533.html">https://www.weixiuzhan.cn/news/show-29533.html</a></p><h3 id="Command-Ld-failed-with-a-nonzero-exit-code"><a href="#Command-Ld-failed-with-a-nonzero-exit-code" class="headerlink" title="Command Ld failed with a nonzero exit code"></a>Command Ld failed with a nonzero exit code</h3><p>这个问题多种多样,我这里记录一下</p><p>1:是我用mac连接window共享文件夹问题(很奇怪之前没这个问题)</p><h3 id="DerivedData-Unity-iPhone-fazbdskwtnuvvqcdjsitsmtzxowo-Build-Products-ReleaseForRunning-iphoneos-UnityFramework-framework-UnityFramework’-does-not-contain-bitcode-You-must-rebuild-it-with-bitcode-enabled-Xcode-setting-ENABLE-BITCODE-obtain-an-updated-library-from-the-vendor-or-disable-bitcode-for-this-target"><a href="#DerivedData-Unity-iPhone-fazbdskwtnuvvqcdjsitsmtzxowo-Build-Products-ReleaseForRunning-iphoneos-UnityFramework-framework-UnityFramework’-does-not-contain-bitcode-You-must-rebuild-it-with-bitcode-enabled-Xcode-setting-ENABLE-BITCODE-obtain-an-updated-library-from-the-vendor-or-disable-bitcode-for-this-target" class="headerlink" title="DerivedData&#x2F;Unity-iPhone-fazbdskwtnuvvqcdjsitsmtzxowo&#x2F;Build&#x2F;Products&#x2F;ReleaseForRunning-iphoneos&#x2F;UnityFramework.framework&#x2F;UnityFramework’ does not contain bitcode. You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target."></a>DerivedData&#x2F;Unity-iPhone-fazbdskwtnuvvqcdjsitsmtzxowo&#x2F;Build&#x2F;Products&#x2F;ReleaseForRunning-iphoneos&#x2F;UnityFramework.framework&#x2F;UnityFramework’ does not contain bitcode. You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target.</h3><p>在xcode中 build setting-&gt;bitcode 设置为NO</p><h3 id="添加动态库设置"><a href="#添加动态库设置" class="headerlink" title="添加动态库设置"></a>添加动态库设置</h3><p>例如添加AVPRO</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202310221208801.png" alt="1"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202310221208309.png" alt="3"><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202310221208246.png" alt="2"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202310221208598.png" alt="4"></p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> IOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> IOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity &amp; Android</title>
      <link href="/2022/08-25-Unity2Android/"/>
      <url>/2022/08-25-Unity2Android/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="Unity调用Android"><a href="#Unity调用Android" class="headerlink" title="Unity调用Android"></a>Unity调用Android</h2><p>这么做方便,但是对于一般人而言,不太会写,而且容易拼写错误</p><p>所有还是使用AS导出jar包或者aar包,亦或者直接把写好的java代码放在<code>unity/plugins/android</code>目录下面</p><p>新建AS工程然后导入unity下路的classes.jar包, 2019版本及以上版本中classes.jar包中可能没有<code>UnityPlayerActivity</code>,需要单独重新导入</p><ul><li>classes.jar路径:xx&#x2F;Editor\Data\PlaybackEngines\AndroidPlayer\Variations\mono\Release\Classes</li><li>UnityPlayerActivity:xx&#x2F;Editor\Data\PlaybackEngines\AndroidPlayer\Source\com\unity3d\player</li></ul><ol><li><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202212241413109.png" alt="image-20221224141313616"></p></li><li><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202212241416106.png" alt="image-20221224141551392"></p></li><li><p>新建一个Activity继承UnityPlayerActivity,然后在里面写一些逻辑代码</p></li><li><p>如果只是工具类 不想继承UnityPlayerActivity,那么自己规定好包名使用静态方法调用即可</p></li><li><p>如新建了Activity继承UnityPlayerActivity,需要在Unity中创建AndroidManifest.xml,指向启动的activity</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202212241421607.png"></p><blockquote><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wu_wenhuan/article/details/44941545/">https://blog.csdn.net/wu_wenhuan/article/details/44941545/</a><br>Android.intent.action.MAIN决定应用程序最先启动的<br>ctivity android.intent.category.LAUNCHER决定应用程序是否显示在程序列表里<br>通过实验后，发现有问题？<br>MAIN 与 LAUNCHER 并不是单纯的各管各的事情；<br>我测试的结果是，如果一个应用没有LAUNCHER则该apk仍能安装到设备上，但是在桌面中图标中看不到。如果给那个Activity 设定了LAUNCHER，且同时设定了Main,则这个Activity就可出现在程序图标中；如果没有Main，则不知启动哪个Activity，故也不会有图标出现。可见，Main指的是，点击图标后启动哪个Activity。当然，Main可以给多个Activity设定，但只设定Main不设定LAUNCHER，仍然无法进入activity。<br>可见，Main和LAUNCHER同时设定才有意义，如果多个activity同时设定，则会出现两个图标，分别先进入不同的activity.</p></blockquote></li><li><p>最后把写好的java代码放到Unity&#x2F;Plugins&#x2F;Android 目录下</p></li><li><p>编写C#代码</p><p><code>AndroidJavaClass</code> : <code>是java.lang.Class 类 </code>主要用于获取静态字段或调用静态方法 <code>C#中静态类.方法 或类.静态方法</code><br><code>AndroidJavaObject</code>:<code>是java.lang.Object 实例对象</code> 调用对象方法: Call 方法，需要new</p><p>直接找到包名下对应的类,是一个类 只能调用一些static 方法<br><strong>AndroidJavaClass androidJC &#x3D; new AndroidJavaClass(com.xxx.xx.xxxClass)</strong></p><p>获取一个对象也可以直接用<br><strong>AndroidJavaObject androidJO &#x3D; new AndroidJavaObject(com.xxx.xx.xxxClass)</strong></p><p>表示new一个该包名下的类,这个也可以直接找到对象 然后调用对象上面的普通方法</p><p>我们常用的<br><code>AndroidJavaClass androidJC = new AndroidJavaClass(com.unity3d.player.UnityPlayer); AndroidJavaObject jo=androidJC.GetStatic&lt;AndroidObject&gt;(&quot;currentActivity&quot;);</code><br>其实就是在或者获取 UnityPlayerActivity 单例<br>com.unity3d.player.UnityPlayer 是classes.jar 中的一个类</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202212241431374.png" alt="在这里插入图片描述"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202212241431394.png" alt="在这里插入图片描述"></p><p>调用android方法最好是在ui线程中 即: runOnUiThread</p></li></ol><p>我的csdn文章有具体操作:<a target="_blank" rel="noopener" href="https://blog.csdn.net/K20132014/article/details/109159008">(Unity与Android通信交互_Zero_LJ的博客-CSDN博客_unity android 交互</a></p><h2 id="Android调用Unity"><a href="#Android调用Unity" class="headerlink" title="Android调用Unity"></a>Android调用Unity</h2><p>Android中调用Unity代码,就是给Unity发消息,Unity针对不同的消息处理逻辑</p><p>在Java代码中使用<code>UnityPlayer.UnitySendMessage(string str1,string str2,string arg)</code>方法</p><p>该方法有三个参数:</p><ul><li>参数1是Unity场景GameObject名称</li><li>参数2是该GameObject上面的方法</li><li>第三个是该方法的参数 可以为null</li></ul><h2 id="使用AndroidJavaProxy进行交互"><a href="#使用AndroidJavaProxy进行交互" class="headerlink" title="使用AndroidJavaProxy进行交互"></a>使用AndroidJavaProxy进行交互</h2><p><code>UnityPlayer.UnitySendMessage(string str1,string str2,string arg)</code>性能及其不好,采用AndroidJavaProxy</p><p>AndroidJavaProxy需要在java和C#建立桥接</p><p><strong>java代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明包名</span></span><br><span class="line"><span class="keyword">package</span> com.zeroultra.connecter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NativeAndroidProxy</span> &#123;</span><br><span class="line">    <span class="comment">//定义桥接方法名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SendToUnity</span><span class="params">(String cmd,String msg)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>C#代码</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Android代理</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;code&gt;</span>声明方法只要和Java中的interface保持一致即可,可以是私有方法<span class="doctag">&lt;/code&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NativeAndroidProxy</span> : <span class="title">AndroidJavaProxy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 当接收消息</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; OnReceiveMsg;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 声明代理 传入具体名(com.zeroultra.connecter.NativeAndroidProxy)</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NativeAndroidProxy</span>(<span class="params"><span class="built_in">string</span> proxyName</span>) : <span class="title">base</span>(<span class="params">proxyName</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span>  发送消息到unity 可以私有方法 和java代码保持一致</span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SendToUnity</span>(<span class="params"><span class="built_in">string</span> cmd, <span class="built_in">string</span> msg</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        OnReceiveMsg?.Invoke(cmd, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后C#层声明代理传入Java层</p><p><strong>java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zeroultra.connecter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="comment">//引入包名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAndroid</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SendToUnity</span><span class="params">(NativeAndroidProxy proxy)</span></span><br><span class="line">    &#123;</span><br><span class="line">        bridge.SendToUnity(<span class="string">&quot;android&quot;</span>,<span class="string">&quot;hello窝窝窝&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span>:<span class="title">Monobehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//声明代理</span></span><br><span class="line">        NativeAndroidProxy proxy=<span class="keyword">new</span> NativeAndroidProxy();</span><br><span class="line">        <span class="comment">//监听事件</span></span><br><span class="line">        proxy.OnReceiveMsg+=(cmd,msg)=&gt;&#123;&#125;;</span><br><span class="line">        <span class="comment">//声明对象</span></span><br><span class="line">        <span class="keyword">using</span> (AndroidJavaObject jo = <span class="keyword">new</span> AndroidJavaObject(<span class="string">&quot;com.zeroultra.connecter.TestAndroid&quot;</span>))</span><br><span class="line">  &#123;</span><br><span class="line">            <span class="comment">//调用方法</span></span><br><span class="line">      jo.Call(<span class="string">&quot;SendToUnity&quot;</span>,proxy);</span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Unity直接调用android代码记录"><a href="#Unity直接调用android代码记录" class="headerlink" title="Unity直接调用android代码记录"></a>Unity直接调用android代码记录</h2><h4 id="Toast"><a href="#Toast" class="headerlink" title="Toast"></a>Toast</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ToastText</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    AndroidJavaClass UnityPlayer = <span class="keyword">new</span> AndroidJavaClass(<span class="string">&quot;com.unity3d.player.UnityPlayer&quot;</span>);</span><br><span class="line">    AndroidJavaObject currentActivity = UnityPlayer.GetStatic&lt;AndroidJavaObject&gt;(<span class="string">&quot;currentActivity&quot;</span>);</span><br><span class="line">    AndroidJavaClass Toast = <span class="keyword">new</span> AndroidJavaClass(<span class="string">&quot;android.widget.Toast&quot;</span>);</span><br><span class="line">    AndroidJavaObject context = currentActivity.Call&lt;AndroidJavaObject&gt;(<span class="string">&quot;getApplicationContext&quot;</span>);</span><br><span class="line">    currentActivity.Call(<span class="string">&quot;runOnUiThread&quot;</span>, <span class="keyword">new</span> AndroidJavaRunnable(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        AndroidJavaObject javaString = <span class="keyword">new</span> AndroidJavaObject(<span class="string">&quot;java.lang.String&quot;</span>, str.ToString());</span><br><span class="line">        Toast.CallStatic&lt;AndroidJavaObject&gt;(<span class="string">&quot;makeText&quot;</span>, context, javaString, Toast.GetStatic &lt; <span class="built_in">int</span>(<span class="string">&quot;LENGTH_SHORT&quot;</span>)).Call(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//appid为bundleIdentifier的值，如果是本应用，可用 Application.bundleIdentifier 来获取。</span></span><br><span class="line"><span class="comment">//如果应用正在研发，还没有投放到应用市场上，可用新浪微博的appid即“com.sina.weibo”来测试</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openAPPinMarket</span>(<span class="params"><span class="built_in">string</span> appid</span>)</span>&#123;</span><br><span class="line">         </span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> UNITY_ANDROID</span></span><br><span class="line">        <span class="comment">//init AndroidJavaClass</span></span><br><span class="line">        AndroidJavaClass UnityPlayer = <span class="keyword">new</span> AndroidJavaClass(<span class="string">&quot;com.unity3d.player.UnityPlayer&quot;</span>);;</span><br><span class="line">        AndroidJavaClass Intent = <span class="keyword">new</span> AndroidJavaClass (<span class="string">&quot;android.content.Intent&quot;</span>);</span><br><span class="line">        AndroidJavaClass Uri = <span class="keyword">new</span> AndroidJavaClass (<span class="string">&quot;android.net.Uri&quot;</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// get currentActivity</span></span><br><span class="line">        AndroidJavaObject currentActivity = UnityPlayer.GetStatic&lt;AndroidJavaObject&gt;(<span class="string">&quot;currentActivity&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        AndroidJavaObject jstr_content=<span class="keyword">new</span> AndroidJavaObject(<span class="string">&quot;java.lang.String&quot;</span>,<span class="string">&quot;market://details?id=&quot;</span>+appid);</span><br><span class="line"> </span><br><span class="line">        AndroidJavaObject intent = <span class="keyword">new</span> AndroidJavaObject (<span class="string">&quot;android.content.Intent&quot;</span>,Intent.GetStatic&lt;AndroidJavaObject&gt;(<span class="string">&quot;ACTION_VIEW&quot;</span>),Uri.CallStatic&lt;AndroidJavaObject&gt;(<span class="string">&quot;parse&quot;</span>,jstr_content));</span><br><span class="line"> </span><br><span class="line">        currentActivity.Call (<span class="string">&quot;startActivity&quot;</span>,intent);</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">AndroidJavaClass UnityPlayer = <span class="keyword">new</span> AndroidJavaClass(<span class="string">&quot;com.unity3d.player.UnityPlayer&quot;</span>);</span><br><span class="line">AndroidJavaObject currentActivity = UnityPlayer.GetStatic&lt;AndroidJavaObject&gt;(<span class="string">&quot;currentActivity&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">AndroidJavaClass Uri = <span class="keyword">new</span> AndroidJavaClass(<span class="string">&quot;android.net.Uri&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> newuri = Uri.CallStatic&lt;AndroidJavaObject&gt;(<span class="string">&quot;parse&quot;</span>, uri);</span><br><span class="line">    </span><br><span class="line">AndroidJavaClass intentClass = <span class="keyword">new</span> AndroidJavaClass(<span class="string">&quot;android.content.Intent&quot;</span>);</span><br><span class="line">AndroidJavaObject intentObject = <span class="keyword">new</span> AndroidJavaObject(<span class="string">&quot;android.content.Intent&quot;</span>);</span><br><span class="line">intentObject.Call&lt;AndroidJavaObject&gt;(<span class="string">&quot;setAction&quot;</span>, intentClass.GetStatic&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;ACTION_VIEW&quot;</span>));</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="comment">//AndroidJavaObject intentObject = new AndroidJavaObject(&quot;android.content.Intent&quot;, intentClass.GetStatic&lt;AndroidJavaObject&gt;(&quot;ACTION_VIEW&quot;));</span></span><br><span class="line">intentObject.Call&lt;AndroidJavaObject&gt;(<span class="string">&quot;setData&quot;</span>, newuri);</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    currentActivity.Call(<span class="string">&quot;startActivity&quot;</span>, intentObject);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">    Debug.LogError(<span class="string">&quot;未安装 &quot;</span> + e.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="Unity2021-2以上版本Android不能放res文件夹"><a href="#Unity2021-2以上版本Android不能放res文件夹" class="headerlink" title="Unity2021.2以上版本Android不能放res文件夹"></a>Unity2021.2以上版本Android不能放res文件夹</h3><hr><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202208251121729.png" alt="12"></p><p><a target="_blank" rel="noopener" href="https://docs.unity3d.com/2021.2/Documentation/Manual/UpgradeGuide20212.html">Unity - Manual: Upgrading to Unity 2021.2 (unity3d.com)</a></p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol><li><p>用AndroidStudio打包成arr,然后导入 参考:<a target="_blank" rel="noopener" href="https://blog.csdn.net/egostudio/article/details/125655477">AndroidStudio打包AAR供Unity使用流程</a></p></li><li><p>直接把文件命名成xxxx.androidlib,然后添加两个文件,一个<code>AndroidManifest.xml</code>和<code>project.properties</code><a target="_blank" rel="noopener" href="https://blog.csdn.net/yixuan2009/article/details/125418054">Unity2021.2版本打包报错</a></p></li></ol><p><code>AndroidManifest.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">package</span>=<span class="string">&quot;custom.android.res&quot;</span>  &lt;<span class="attr">--这里随便命名--</span>&gt;</span></span><br><span class="line">          android:versionCode=&quot;1&quot;</span><br><span class="line">          android:versionName=&quot;1.0&quot;&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>project.properties</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This file is automatically generated by Android Tools.</span></span><br><span class="line"><span class="comment"># Do not modify this file -- YOUR CHANGES WILL BE ERASED!</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This file must be checked in Version Control Systems.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># To customize properties used by the Ant build system edit</span></span><br><span class="line"><span class="comment"># &quot;ant.properties&quot;, and override values to adapt the script to your</span></span><br><span class="line"><span class="comment"># project structure.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):</span></span><br><span class="line"><span class="comment">#proguard.config=$&#123;sdk.dir&#125;/tools/proguard/proguard-android.txt:proguard-project.txt</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Project target.</span></span><br><span class="line"><span class="comment">#target=android-30</span></span><br><span class="line"><span class="attr">android.library</span>=<span class="string">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后把res文件和这两个放在一起就可以了</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202208251133061.png" alt="image-20220825113300010"></p><h3 id="打包dev没问题-打release出错"><a href="#打包dev没问题-打release出错" class="headerlink" title="打包dev没问题,打release出错"></a>打包dev没问题,打release出错</h3><hr><blockquote><ul><li><p>What went wrong: Execution failed for task ‘:launcher:lintVitalAnalyzeRelease’. &gt; Could not resolve all files for configuration ‘:launcher:releaseCompileClasspath’.    &gt; Failed to transform out.aar (project :unityLibrary) to match attributes {artif</p></li><li><p>Execution failed for task ‘:launcher:lintVitalAnalyzeRelease’.</p><blockquote><p>Could not resolve all files for configuration ‘:launcher:releaseCompileClasspath’.</p></blockquote></li></ul></blockquote><p><code>SteamingAssets文件夹中不能出现中文</code>, 我就是因为里面有个视频是中文导致这个错误</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UnityEditor合集</title>
      <link href="/2022/08-09-UnityEditor%E5%90%88%E9%9B%86/"/>
      <url>/2022/08-09-UnityEditor%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="MenuItem"><a href="#MenuItem" class="headerlink" title="MenuItem"></a>MenuItem</h2><p><strong>MenuItem(string itemName, bool isValidateFunction, int priority)</strong>               </p><ul><li>“itemName：菜单名称路径</li><li>“isValidateFunction：默认为false，如果为true则是一个验证函数,方法返回值必须是bool类型 表示是否可以执行这个命令 </li><li>“priority：菜单项显示排序 如果相差间隔大于&#x3D;11 就会有一个下划线</li><li>“快捷键 %（ctrl）、# (shift)、&amp; (alt) _w(按下w, 单一字母)</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33337811/article/details/72852342">Unity Editor 基础篇（十一）：MenuItem属性_庸人自扰Eam的博客-CSDN博客_unity menuitem</a></p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhaoqingqing/p/14837474.html">Unity Editor自定义菜单排序(MenuItem Order) - 赵青青 - 博客园 (cnblogs.com)</a></p><h2 id="Unity-SerializedProperty和Target-区别"><a href="#Unity-SerializedProperty和Target-区别" class="headerlink" title="Unity SerializedProperty和Target 区别"></a>Unity SerializedProperty和Target 区别</h2><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>SerializedProperty</td><td>1.可以多选 <br />2.自动Undo<br />3.预制体重写<br />4.可以修改私有对象</td><td>比较麻烦</td></tr><tr><td>Target</td><td>简单好用,跟调用对象一样</td><td>不能修改私有变量 不能多选 不能undo 修改对象后，要使用EditorUtility.SetDirty(target) 将target标记为脏状态，否则修改状态不会被记</td></tr></tbody></table><p>示例代码:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">CustomEditor(typeof(InspectorExample))</span>]</span><br><span class="line">[<span class="meta">CanEditMultipleObjects</span>]        <span class="comment">//用于处理多选</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InspectorExampleEditor</span> : <span class="title">Editor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> SerializedProperty hpProp;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        hpProp = serializedObject.FindProperty(<span class="string">&quot;Hp&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnInspectorGUI</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1. 使用SerializedProperty 优点：自动处理多选、Undo、预制件重写</span></span><br><span class="line">        serializedObject.Update();</span><br><span class="line">        EditorGUILayout.IntSlider(hpProp, <span class="number">0</span>, <span class="number">100</span>, hpContent);</span><br><span class="line">        <span class="comment">//当没有多选不同值时就显示ProgressBar</span></span><br><span class="line">        <span class="keyword">if</span> (!hpProp.hasMultipleDifferentValues)     </span><br><span class="line">            ProgressBar(hpProp.intValue / <span class="number">100f</span>, <span class="string">&quot;HP&quot;</span>);</span><br><span class="line">        EditorGUILayout.IntSlider(mpProp, <span class="number">0</span>, <span class="number">100</span>, mpContent);</span><br><span class="line">        <span class="keyword">if</span> (!mpProp.hasMultipleDifferentValues)</span><br><span class="line">            ProgressBar(mpProp.intValue / <span class="number">100f</span>, <span class="string">&quot;MP&quot;</span>);</span><br><span class="line">        <span class="comment">//可以直接通过PropertyField绘制默认Field或自定义PropertyAttribte</span></span><br><span class="line">        EditorGUILayout.PropertyField(swordProp, swordContent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//应用SerializedProperty改变</span></span><br><span class="line">        serializedObject.ApplyModifiedProperties();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 直接修改对象身上的值  </span></span><br><span class="line">        EditorGUI.BeginChangeCheck();</span><br><span class="line">        InspectorExample iEx = (InspectorExample) target;</span><br><span class="line">        iEx.Attack = EditorGUILayout.IntSlider(attackContent, iEx.Attack, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="built_in">bool</span> allowSceneObject = !EditorUtility.IsPersistent(target);</span><br><span class="line">        iEx.Shield =</span><br><span class="line">            (GameObject) EditorGUILayout.ObjectField(<span class="string">&quot;Shield&quot;</span>, iEx.Shield, <span class="keyword">typeof</span>(GameObject), allowSceneObject);</span><br><span class="line">        <span class="keyword">if</span> (EditorGUI.EndChangeCheck())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//需要标记target为脏</span></span><br><span class="line">            EditorUtility.SetDirty(target);</span><br><span class="line">            <span class="comment">// EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene());</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="窗口扩展"><a href="#窗口扩展" class="headerlink" title="窗口扩展"></a>窗口扩展</h2><h3 id="Tools工具扩展"><a href="#Tools工具扩展" class="headerlink" title="Tools工具扩展"></a>Tools工具扩展</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEditor.EditorTools;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> ____DESC:      Tools(经常操作的工具)工具扩展 https://docs.unity.cn/cn/2020.3/ScriptReference/EditorTools.EditorTool.html</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EditorToolsExtender</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//[EditorTool(&quot;AA&quot;)]</span></span><br><span class="line">    <span class="comment">//class A : EditorTool</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    private void OnEnable()</span></span><br><span class="line">    <span class="comment">//    &#123;</span></span><br><span class="line">    <span class="comment">//        Debug.Log(&quot;aaa&quot;);</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//    public override void OnToolGUI(EditorWindow window)</span></span><br><span class="line">    <span class="comment">//    &#123;</span></span><br><span class="line">    <span class="comment">//        base.OnToolGUI(window);</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HierarchyWindow"><a href="#HierarchyWindow" class="headerlink" title="HierarchyWindow"></a>HierarchyWindow</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> ____DESC:      Hierarchy窗口 扩展器</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">[<span class="meta">InitializeOnLoad</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HierarchyWindowExtender</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//静态构造</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">HierarchyWindowExtender</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        EditorApplication.hierarchyWindowItemOnGUI += OnHierarchyGUI;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnHierarchyGUI</span>(<span class="params"><span class="built_in">int</span> instanceID, Rect selectionRect</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> size = <span class="number">18</span>;</span><br><span class="line">        Rect rect = <span class="keyword">new</span> Rect(selectionRect.x + selectionRect.width - size * <span class="number">1.2f</span>, selectionRect.y, size+<span class="number">10</span>, size);</span><br><span class="line">        <span class="keyword">if</span> ((EditorUtility.InstanceIDToObject(instanceID) <span class="keyword">is</span> GameObject))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//if ((EditorUtility.InstanceIDToObject(instanceID) as GameObject).TryGetComponent&lt;TriggerEvent&gt;(out TriggerEvent go))</span></span><br><span class="line">            <span class="comment">//&#123;</span></span><br><span class="line">            <span class="comment">//    if (go.isTriggerToDialogDubbing)</span></span><br><span class="line">            <span class="comment">//        GUI.Label(rect, dialogTexture);</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">            <span class="comment">//显示SpriteRenderer的sortingOrder</span></span><br><span class="line">            <span class="keyword">if</span> ((EditorUtility.InstanceIDToObject(instanceID) <span class="keyword">as</span> GameObject).TryGetComponent&lt;UnityEngine.SpriteRenderer&gt;(<span class="keyword">out</span> UnityEngine.SpriteRenderer sp))</span><br><span class="line">            &#123;</span><br><span class="line">                GUI.color = Color.green;</span><br><span class="line">                GUI.Label(rect, sp.sortingOrder.ToString());</span><br><span class="line">                GUI.color = Color.white;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//else if ((EditorUtility.InstanceIDToObject(instanceID) as GameObject).TryGetComponent&lt;MeshRenderer&gt;(out MeshRenderer mr))</span></span><br><span class="line">            <span class="comment">//&#123;</span></span><br><span class="line">            <span class="comment">//    GUI.color = Color.green;</span></span><br><span class="line">            <span class="comment">//    GUI.Label(rect, mr.sortingOrder.ToString());</span></span><br><span class="line">            <span class="comment">//    GUI.color = Color.white;</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="InspectorWindwow"><a href="#InspectorWindwow" class="headerlink" title="InspectorWindwow"></a>InspectorWindwow</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> ____DESC:      Inspector 窗口扩展</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InspectorWindwowExtender</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//[InitializeOnLoadMethod]</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ButtonTodo</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// Editor.finishedDefaultHeaderGUI += Editor_finishedDefaultHeaderGUI;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Editor_finishedDefaultHeaderGUI</span>(<span class="params">Editor obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//GameObject go = obj.target as GameObject;</span></span><br><span class="line">        <span class="comment">//if (go)</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">        <span class="comment">//    if (go.TryGetComponent&lt;SkeletonAnimation&gt;(out var spine))</span></span><br><span class="line">        <span class="comment">//    &#123;</span></span><br><span class="line">        <span class="comment">//        if (GUILayout.Button(&quot;更换Spine材质为2d 光类型&quot;))</span></span><br><span class="line">        <span class="comment">//        &#123;</span></span><br><span class="line">        <span class="comment">//            var mr = spine.GetComponent&lt;MeshRenderer&gt;();</span></span><br><span class="line">        <span class="comment">//            mr.sharedMaterial.shader = Shader.Find(&quot;Universal Render Pipeline/2D/Spine/Sprite&quot;);</span></span><br><span class="line">        <span class="comment">//            mr.shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.Off;</span></span><br><span class="line">        <span class="comment">//            mr.lightProbeUsage = UnityEngine.Rendering.LightProbeUsage.Off;</span></span><br><span class="line">        <span class="comment">//            mr.reflectionProbeUsage = UnityEngine.Rendering.ReflectionProbeUsage.Off;</span></span><br><span class="line">        <span class="comment">//            spine.addNormals = true;</span></span><br><span class="line">        <span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//    &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ProjectWindow"><a href="#ProjectWindow" class="headerlink" title="ProjectWindow"></a>ProjectWindow</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> ____DESC:      文件描述</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">[<span class="meta">InitializeOnLoad</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProjectWindowExtender</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">ProjectWindowExtender</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">//EditorApplication.projectWindowItemOnGUI += OnGUI;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnGUI</span>(<span class="params"><span class="built_in">string</span> guid, Rect selectionRect</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//if (Event.current.type != EventType.ContextClick) return;</span></span><br><span class="line">        <span class="comment">//Event.current.Use();</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>/ return;</span></span><br><span class="line">        <span class="comment">//var genericMenu = new GenericMenu();</span></span><br><span class="line">        <span class="comment">//genericMenu.AddItem(new GUIContent(&quot;MenuItem1&quot;), false, null);</span></span><br><span class="line">        <span class="comment">//genericMenu.AddItem(new GUIContent(&quot;MenuItem2&quot;), false, null);</span></span><br><span class="line">        <span class="comment">//genericMenu.ShowAsContext();</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="SceneWindow"><a href="#SceneWindow" class="headerlink" title="SceneWindow"></a>SceneWindow</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> ____DESC:      Scene窗口扩展</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SceneWindowExtender</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">InitializeOnLoadMethod</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Init</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//SceneView.duringSceneGui -= SceneView_duringSceneGui;</span></span><br><span class="line">        <span class="comment">// SceneView.duringSceneGui += SceneView_duringSceneGui;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SceneView_duringSceneGui</span>(<span class="params">SceneView obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*eg:</span></span><br><span class="line"><span class="comment">        *Handles场景视图中的自定义 3D GUI 控件和绘制操作</span></span><br><span class="line"><span class="comment">        *Handles.BeginGUI();</span></span><br><span class="line"><span class="comment">        *GUILayout.Button(&quot;aa&quot;,GUILayout.Width(50));</span></span><br><span class="line"><span class="comment">        *Handles.EndGUI();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他记录"><a href="#其他记录" class="headerlink" title="其他记录"></a>其他记录</h2><p><code>ProjectWindowUtil</code></p><p><code>EndNameEditAction</code>当完成文件命名 需要创建类继承它</p><p><code>SettingsService</code> 打开命令路径<br> <code>SettingsService.OpenProjectSettings(&quot;Project/Player&quot;);</code>&#x2F;&#x2F;打开PlayerSetging窗口界面<br> <code>EditorBuildSettings</code>获取编辑器场景设置<br> <code>EditorUtility</code>编辑器工具 打开文件 显示对话框<br> <code>EditorApplication.ExecuteMenuItem</code> 编辑器执行某个菜单命令 </p><p><code>IHasCustomMenu</code> 继承了这个接口 给编辑器”…”添加菜单</p><ul><li><p>EditorGUILayout.GetControlRect(false, EditorGUIUtility.singleLineHeight) </p></li><li><p>GUILayoutUtility.GetRect</p><p>可获取当前绘制的区域</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rect = EditorGUILayout.GetControlRect(<span class="literal">false</span>, EditorGUIUtility.singleLineHeight);</span><br><span class="line">EditorGUI.ProgressBar(rect, <span class="number">0.5f</span>, <span class="string">&quot;progress&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>EditorStyles.label.CalcSize(new GUIContent(go.name))</p><p>获取当前label的尺寸</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Editor </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Editor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AppScheme技术</title>
      <link href="/2022/07-28-AppScheme%E6%8A%80%E6%9C%AF/"/>
      <url>/2022/07-28-AppScheme%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Scheme"><a href="#什么是Scheme" class="headerlink" title="什么是Scheme"></a>什么是Scheme</h1><p>scheme是一种页面内跳转协议，是一种非常好的实现机制，通过定义自己的scheme协议，可以非常方便跳转app中的各个页面</p><ul><li>1.通过小程序，利用Scheme协议打开原生app</li><li>2.H5页面点击锚点，根据锚点具体跳转路径APP端跳转具体的页面</li><li>3.APP端收到服务器端下发的PUSH通知栏消息，根据消息的点击跳转路径跳转相关页面</li><li>4.APP根据URL跳转到另外一个APP指定页面</li><li>5.通过短信息中的url打开原生app</li></ul><h1 id="Unity"><a href="#Unity" class="headerlink" title="Unity"></a>Unity</h1><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>使用<code>Application.OpenURL();</code>填入对应参数即可</p><h4 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h4><p>别的app 打开unity 会响应<code>Application.deepLinkActivated</code>  </p><p><a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2020.3/ScriptReference/Application-deepLinkActivated.html">Application-deepLinkActivated - Unity 脚本 API</a></p><h1 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h1><p>可以看看之前的文章</p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/K20132014/article/details/78391638">Android导出aar插件供Unity使用以及通过android scheme启动unityApp_Zero_LJ的博客-CSDN博客</a></p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cancantrbl/p/15325341.html">利用URLScheme实现Unity跳转到其他app - cancantrbl - 博客园 (cnblogs.com)</a></p><h1 id="IOS"><a href="#IOS" class="headerlink" title="IOS"></a>IOS</h1><p>暂时不知</p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cancantrbl/p/15325341.html">利用URLScheme实现Unity跳转到其他app - cancantrbl - 博客园 (cnblogs.com)</a></p><h1 id="各大AppScheme收集"><a href="#各大AppScheme收集" class="headerlink" title="各大AppScheme收集"></a>各大AppScheme收集</h1><p>更新 <a target="_blank" rel="noopener" href="https://gist.github.com/JamesHopbourn/046bc341e7debfd0c86e3b388d983c53">含参数的 URL Scheme 收集.md (github.com)</a></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hzhnzmyz/article/details/119149058">https://blog.csdn.net/hzhnzmyz/article/details/119149058</a></p><p><a target="_blank" rel="noopener" href="https://xydida.com/2020/10/1/notes/APP-URL-Scheme/">一些常用APP的URL Scheme | Hui Wang’s Blog (xydida.com)</a></p><p>IOS <a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv12371050">iOS快捷指令URL Scheme 之 系统操作V1.0(更新于2021年7月28日) - 哔哩哔哩 (bilibili.com)</a></p><p><a target="_blank" rel="noopener" href="https://sspai.com/post/81278#!">打开iOS新世界的大门 | 有趣的URL Scheme - 少数派 (sspai.com)</a></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/589344817">ios快捷指令网站大全 - 知乎 (zhihu.com)</a></p><h4 id="QQ"><a href="#QQ" class="headerlink" title="QQ"></a>QQ</h4><table><thead><tr><th>名称</th><th>scheme</th></tr></thead><tbody><tr><td>打开qq</td><td>mqq:&#x2F;&#x2F;</td></tr><tr><td>打开QQ群</td><td>mqqapi:&#x2F;&#x2F;card&#x2F;show_pslcard?src_type&#x3D;internal&amp;version&#x3D;1&amp;card_type&#x3D;group&amp;uin&#x3D;QQ群号</td></tr><tr><td>打开联系人</td><td>mqqapi:&#x2F;&#x2F;card&#x2F;show_pslcard?src_type&#x3D;internal&amp;version&#x3D;1&amp;uin&#x3D;QQ号码</td></tr><tr><td>QQ邮箱</td><td>qqmail:&#x2F;&#x2F;</td></tr><tr><td>加好友</td><td>mqqapi:&#x2F;&#x2F;card&#x2F;show_pslcard?src_type&#x3D;internal&amp;version&#x3D;1&amp;uin&#x3D;{QQ号}</td></tr><tr><td>TIM</td><td>tim:&#x2F;&#x2F;    (其他好像和qq也是一样的)</td></tr><tr><td>tim 扫一扫</td><td>tim:&#x2F;&#x2F;qrcode&#x2F;scan_qrcode?version&#x3D;1&amp;src_type&#x3D;app</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h4 id="微信"><a href="#微信" class="headerlink" title="微信"></a>微信</h4><table><thead><tr><th>打开微信</th><th>weixin:&#x2F;&#x2F;</th></tr></thead><tbody><tr><td>扫一扫</td><td>weixin:&#x2F;&#x2F;scanqrcode  好像没用 听说是微信把很多scheme 都封了</td></tr><tr><td>企业微信</td><td>wxwork:&#x2F;&#x2F;</td></tr><tr><td></td><td></td></tr></tbody></table><h4 id="BiliBili"><a href="#BiliBili" class="headerlink" title="BiliBili"></a>BiliBili</h4><table><thead><tr><th>打开</th><th>bilibili:&#x2F;&#x2F;</th><th></th></tr></thead><tbody><tr><td>打开主页</td><td>bilibili:&#x2F;&#x2F;home</td><td></td></tr><tr><td>搜索视频</td><td>bilibili:&#x2F;&#x2F;search?keyword&#x3D;视频名称  可以以直接填写av bv号</td><td></td></tr><tr><td>视频播放页面</td><td>bilibili:&#x2F;&#x2F;video&#x2F;av  or  bv</td><td></td></tr><tr><td>扫一扫</td><td>bilibili:&#x2F;&#x2F;qrcode</td><td></td></tr><tr><td>个人中心</td><td>bilibili:&#x2F;&#x2F;user_center</td><td></td></tr><tr><td>UID用户页面</td><td>bilibili:&#x2F;&#x2F;space&#x2F;uid</td><td></td></tr><tr><td>打开直播间</td><td>bilibili:&#x2F;&#x2F;live&#x2F;id</td><td></td></tr><tr><td>我的收藏</td><td>bilibili:&#x2F;&#x2F;main&#x2F;favorite</td><td></td></tr><tr><td>番剧</td><td>bilibili:&#x2F;&#x2F;bangumi&#x2F;season&#x2F;seansonid</td><td></td></tr></tbody></table><h4 id="支付宝"><a href="#支付宝" class="headerlink" title="支付宝"></a>支付宝</h4><table><thead><tr><th>付款码</th><th>alipay:&#x2F;&#x2F;platformapi&#x2F;startapp?appId&#x3D;20000056</th><th></th></tr></thead><tbody><tr><td>扫一扫</td><td>alipay:&#x2F;&#x2F;platformapi&#x2F;startapp?appId&#x3D;10000007</td><td></td></tr><tr><td>乘车码</td><td>alipay:&#x2F;&#x2F;platformapi&#x2F;startapp?appId&#x3D;200011235</td><td></td></tr><tr><td>红包</td><td>alipays:&#x2F;&#x2F;platformapi&#x2F;startapp?appId&#x3D;88886666</td><td></td></tr><tr><td>收款</td><td>alipays:&#x2F;&#x2F;platformapi&#x2F;startapp?appId&#x3D;20000123</td><td></td></tr><tr><td>转账</td><td>alipays:&#x2F;&#x2F;platformapi&#x2F;startapp?appId&#x3D;20000221</td><td></td></tr><tr><td>手机充值</td><td>alipays:&#x2F;&#x2F;platformapi&#x2F;startapp?appId&#x3D;10000003</td><td></td></tr><tr><td>生活缴费</td><td>alipays:&#x2F;&#x2F;platformapi&#x2F;startapp?appId&#x3D;20000193</td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h4 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h4><table><thead><tr><th>电话</th><th>tel:&#x2F;&#x2F;手机号</th></tr></thead><tbody><tr><td>短信</td><td>sms:&#x2F;&#x2F;手机号</td></tr><tr><td>备忘录</td><td>mobilenotes:&#x2F;&#x2F;</td></tr><tr><td>设置</td><td>prefs:root&#x3D;SETTING</td></tr><tr><td>E-Mail</td><td>MESSAGE:&#x2F;&#x2F;</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h4 id="微博"><a href="#微博" class="headerlink" title="微博"></a>微博</h4><table><thead><tr><th>微博搜索</th><th>sinaweibo:&#x2F;&#x2F;searchall?q&#x3D;[prompt]</th></tr></thead><tbody><tr><td>扫一扫</td><td>sinaweibo:&#x2F;&#x2F;qrcode</td></tr><tr><td>发微博</td><td>sinaweibo:&#x2F;&#x2F;share?content&#x3D;[prompt:微博内容]</td></tr><tr><td>指定用户个人资料页</td><td>sinaweibo:&#x2F;&#x2F;userinfo?uid&#x3D;uid  (怎么找uid 微博找到用户主页 然后分析 后面数字就是uid)</td></tr><tr><td>新浪微博国际版</td><td>weibointernational:&#x2F;&#x2F;  后面的host好像都是通用的</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h4 id="Lofter"><a href="#Lofter" class="headerlink" title="Lofter"></a>Lofter</h4><table><thead><tr><th>打开Lofter</th><th>lofter:&#x2F;&#x2F;</th></tr></thead><tbody><tr><td>打开设置</td><td>lofter:&#x2F;&#x2F;set&#x2F;main</td></tr><tr><td>打开设置偏好设置</td><td>lofter:&#x2F;&#x2F;set&#x2F;main&#x2F;preference   通过解包APK查看</td></tr><tr><td>打开某个人的主页面</td><td>lofter:&#x2F;&#x2F;[id].lofter.com</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scheme </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity中的Asset</title>
      <link href="/2022/04-12-2022-4-12-Unity%E4%B8%AD%E7%9A%84Asset/"/>
      <url>/2022/04-12-2022-4-12-Unity%E4%B8%AD%E7%9A%84Asset/</url>
      
        <content type="html"><![CDATA[<p>本文主要讲解unity中的资源以及其存在方式序列化等等,内容皆来自下面文章和个人的一点总结</p><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Wv41167i2?share_source=copy_web">官方直播 Unity Asset的一生</a></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/411946807">【Unity】Asset简介 - 知乎</a></p><p><a target="_blank" rel="noopener" href="https://blog.uwa4d.com/archives/1577.html">Unity 5.x AssetBundle零冗余解决方案  | 侑虎科技</a></p><p><a target="_blank" rel="noopener" href="https://aihailan.com/archives/4218">Unity引擎资源管理机制介绍 - 海澜个人技术笔记</a></p><hr><h3 id="资源导入"><a href="#资源导入" class="headerlink" title="资源导入"></a>资源导入</h3><p>相关资源导入之后untiy会将资源数据转换成其认可的数据,记录再<code>AssetDatabase</code>里面,也就是Library中</p><blockquote><h2 id="Library文件夹的内容"><a href="#Library文件夹的内容" class="headerlink" title="Library文件夹的内容"></a>Library文件夹的内容</h2><h3 id="Source-Assets-和-Artifacts"><a href="#Source-Assets-和-Artifacts" class="headerlink" title="Source Assets 和 Artifacts"></a><strong>Source Assets 和 Artifacts</strong></h3><p>Unity在 <strong>Library 文件夹</strong> 中维护了两个数据库文件，它们统称为 <strong>资产数据库（Asset Database）</strong>。这两个数据库分别记录了有关 Source Assets 的信息，以及 Artifacts 的信息（即导入结果的相关数据）。</p><h3 id="Source-Asset-数据库（Source-Asset-Database）"><a href="#Source-Asset-数据库（Source-Asset-Database）" class="headerlink" title="Source Asset 数据库（Source Asset Database）"></a><strong>Source Asset 数据库（Source Asset Database）</strong></h3><p>Source Asset 数据库包含 Source Assets 的元信息。Unity 使用这些信息来判断文件是否发生了修改，从而决定是否需要重新导入文件。这些信息包括以下内容：</p><ul><li>文件的最后修改日期</li><li>文件内容的哈希值</li><li>全局唯一标识符（GUID）</li><li>其他元信息</li></ul><p><img src="https://aihailan.com/wp-content/uploads/2024/12/image-1733839339308.png" alt="file"></p><h3 id="Artifact-数据库（Artifact-Database）"><a href="#Artifact-数据库（Artifact-Database）" class="headerlink" title="Artifact 数据库（Artifact Database）"></a><strong>Artifact 数据库（Artifact Database）</strong></h3><p>Artifacts 是导入过程的结果。Artifact 数据库记录了每个 Source Asset 的导入结果信息。每个 Artifact 包含以下内容：</p><ul><li>导入的依赖关系信息</li><li>Artifact 的元信息</li><li>Artifact 文件的列表</li></ul><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202502141655920.png" alt="file"></p><ul><li><strong>注意事项</strong><br> 数据库文件位于项目的 <strong>Library 文件夹</strong> 中，因此应将其排除在版本控制系统之外。这些文件的具体路径如下：</li><li><strong>Source Asset 数据库</strong>：<code>Library\SourceAssetDB</code></li><li><strong>Artifact 数据库</strong>：<code>Library\ArtifactDB</code></li></ul><p><strong>注：</strong>对应数据库的大小区分也很大</p><p>除了上面提到的两个数据库，Library文件夹还存储 Unity 引擎生成的其它缓存</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202502141655911.png" alt="file"><br><img src="https://aihailan.com/wp-content/uploads/2024/12/image-1733840833930.png" alt="file"></p></blockquote><h3 id="Scene"><a href="#Scene" class="headerlink" title="Scene"></a>Scene</h3><p>场景相同的物体,最好是用Prefab,这样场景的描述文件要小得多,prefab指向的都是同一个内存,占用小</p><hr><h3 id="Meta、FileID、GUID、InstanceID"><a href="#Meta、FileID、GUID、InstanceID" class="headerlink" title="Meta、FileID、GUID、InstanceID"></a>Meta、FileID、GUID、InstanceID</h3><h4 id="Meta文件"><a href="#Meta文件" class="headerlink" title="Meta文件"></a>Meta文件</h4><p>Meta文件在资源导入的时候就自动产生,其最重要的就是有个GUID,保证资源的唯一性,unity根据这个guid来找到资源</p><p>(如果要保持资源的正确引用,在拷贝资源的时候连同meta)</p><p>除了guid这个,它还包含了资源的导入设置,例如图片的meta里面就记录了图片的TextureImporter设置</p><h4 id="FileID"><a href="#FileID" class="headerlink" title="FileID"></a>FileID</h4><p>FileID其实叫<code>LocalID</code>更好,它<code>表示这个本身Object的标识ID</code>,我们分为两种讨论</p><h5 id="资源的FileID"><a href="#资源的FileID" class="headerlink" title="资源的FileID"></a>资源的FileID</h5><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202502141755078.png" alt="image-20250214175509850"> </p><p>对于同一类型资源他们的FileID是一样的,例如Texture都是280000,Script都是11500000,这些都是Unity预定义的(具体值得定义没查到相关文档)</p><p>对于图集(一个贴图下有很多子精灵)这种,主贴图还是280000,子图精灵的fileID是系统生成的</p><h5 id="Object的FileID"><a href="#Object的FileID" class="headerlink" title="Object的FileID"></a>Object的FileID</h5><p>Object的FileID,这里的Object值得是(Prefab,Scene,或者模型,场景中的GameObject),他们的特征很明显,都是一个对象上有多个component,这个时候的FileID就是记录组件的id,看个prefab的例子</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202502141827861.png" alt="image-20250214182658063"> </p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202502141927487.png" alt="image-20250214183144678"> </p><p>这个Prefab就两个组件Transform和MonoScript,此时这个gameobject就记录两个fileID分别指向对应的组件id</p><p>这里说明一下 <code>!u!114 &amp;8880607289944865690</code>这个格式</p><ul><li>!u! 不管,应该是代表unity</li><li>接着的id是unity内置的<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/ClassIDReference.html">classid</a> 例如114下面肯定就是自定义mono脚本</li><li>后面的就是这个组件的fileID</li></ul><p>通过这些完整组成了一个prefab(其他也类似)</p><p>然后我们再看下这个Mono脚本</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NewMonoBehaviour1</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Texture2D texture2D1;</span><br><span class="line">    <span class="keyword">public</span> Texture2D texture2D2;</span><br><span class="line">    <span class="keyword">public</span> Sprite sprite1;</span><br><span class="line">    <span class="keyword">public</span> Sprite sprite2;</span><br><span class="line">    <span class="keyword">public</span> TextAsset textAsset1;</span><br><span class="line">    <span class="keyword">public</span> TextAsset textAsset2;</span><br><span class="line">    <span class="keyword">public</span> GameObject gameObject1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里texture2d1和texture2d2他们的guid不同代表他们指向了不同的图片文件</p><p>sprite1和sprite2他们的guid相同但是fileID不同,代表是一个图集下的两个子精灵</p><h4 id="InstanceID"><a href="#InstanceID" class="headerlink" title="InstanceID"></a>InstanceID</h4><blockquote><p>Instance ID 是 Unity 在运行时为已加载到内存中的对象分配的临时唯一标识，只在当前运行会话中有效。</p><p>Unity 在编辑器或游戏运行时将资源（如 GameObject、组件等）加载到内存后，这些对象都需要一个唯一编号便于引擎管理与访问。Instance ID 仅在进程存活期间有效，一旦编辑器重启或游戏停止，这些 ID 即失效，不同于固定存储于项目中的 GUID 和 Local ID。</p></blockquote><p><code>记住,InstanceID不能用来做持久化数据,他是变化的</code></p><h4 id="总结与对比"><a href="#总结与对比" class="headerlink" title="总结与对比"></a>总结与对比</h4><table><thead><tr><th>属性</th><th>GUID</th><th>Local ID</th><th>Instance ID</th></tr></thead><tbody><tr><td><strong>唯一性</strong></td><td>全局唯一</td><td>文件内唯一</td><td>运行时唯一</td></tr><tr><td><strong>存储范围</strong></td><td>项目范围</td><td>单个资源文件中</td><td>内存中</td></tr><tr><td><strong>存储位置</strong></td><td><code>.meta</code> 文件</td><td>场景或 Prefab 文件</td><td>不存储</td></tr><tr><td><strong>用途</strong></td><td>跨文件引用资源</td><td>文件内资源定位</td><td>内存中引用</td></tr></tbody></table><hr><h3 id="AssetBundle"><a href="#AssetBundle" class="headerlink" title="AssetBundle"></a>AssetBundle</h3><ol><li>结构 总的来说，一个AB包括2个部分：<code>包头</code>和<code>数据段</code></li></ol><blockquote><p><strong>包头</strong>：包含有关AssetBundle 的信息，比如标识符、压缩类型和内容清单（manifest：manifest是一个用对象名字做key的查找表），每个条目都提供一个字节索引，该索引指示在AssetBundle的数据段中可以找到给定对象的位置。<br>在大多数平台，这个查找表是用平衡搜索树实现的。（除了Windows和OSX派生的平台（包括IOS平台）是用红黑树实现）。因此，构建这个清单的时间消耗会随着ab内的资源数量的增加而线性增加。</p><p><strong>数据段</strong>：通过序列化AB内的资源的原生数据。<br>- 如果用<strong>LZMA</strong>压缩，将压缩<strong>所有</strong>序列化资产的完整字节数组；<br>- 如果是<strong>LZ4</strong>压缩，每个资源都是<strong>分开压缩</strong>的；<br>- 如果没有压缩，就都保存原生字节流。</p></blockquote><ol start="2"><li><p><code>Scene</code>，它是一个单独的AssetBundle，因为它和其他的Asset的处理方式是不一样的，所以Asset和Scene是不能打到一起的，要分开打。</p></li><li><p><code>加载一个AssetBundle的时候</code>，它的头会立刻加载进内存，这个也是我们在Profiler里面经常看到的<code>SerializedFile</code>。剩下的内容，也就是Bundle里面的Asset，它是<code>按需加载</code>的。也就是说如果我们不去加载这个Asset，它是不会从包体里被加载到内存中的。但是有一个例外，就是默认的<a href="https://link.zhihu.com/?target=https://docs.unity.cn/2021.1/Documentation/Manual/AssetBundles-Cache.html">LZMA</a>的压缩，这种压缩格式用一个数据流代表整个AssetBundle，因此要读取里面任意一个Asset的时候需要解压整个数据流。</p></li><li><p><code>打包参数 DisableWriteTypeTree</code></p><p>用来做兼容,如果unity版本不同用它可以达到兼容效果,使文件变得更小，加载起来也更快一点</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162216521.png" alt="没有设置DisableWriteTypeTree"> </p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162216522.png"></p></li></ol><p>可以看到关闭之后一个简单的cube的AB包小了很多</p><p>在Profiler中,AB的头也会缩小</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162216523.png" alt="没有设置DisableWriteTypeTree"> </p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162216524.png"> </p><p><code>方案:在打Release包的时候打包参数添加DisableWriteTypeTree,能缩小包体和内存大小</code></p><p><code>编辑器的时候不能添加该参数,否则会报错</code></p><ol start="5"><li><code>打包策略</code></li></ol><ul><li>大小尽量在1-10m之类,大小加载的都是头文件,造成头重脚轻的情况,太大对下载可能有问题</li></ul><ol start="6"><li><code>AssetBundle的识别</code></li></ol><p>当我们前后两次打出AssetBundle的时候，如何判断哪些AssetBundle是有差异的，哪些AssetBundle是没有发生变化的呢？</p><p><code>很多人会通过计算两次打出来AssetBundle的md5来判断是否发生变化，实际上这种方式是不推荐的</code>。因为在Unity打包的过程中，有一些因素是不稳定的，可能导致你两次打包之后的AssetBundle，虽然你里面的东西没有变，但是打出来的Binary不是严格一致的，从而md5也是不一样的。所以不建议算打出来之后的AssetBundle。那怎么算呢？我们可以算Library里的文件的md5，或者是原文件以及对应的meta文件的md5，用这些算出来的hash做为AssetBundle的变化依据是可以的</p><h3 id="Asset的卸载"><a href="#Asset的卸载" class="headerlink" title="Asset的卸载"></a>Asset的卸载</h3><h4 id="1-UnloadUnusedAssets"><a href="#1-UnloadUnusedAssets" class="headerlink" title="1.UnloadUnusedAssets"></a>1.UnloadUnusedAssets</h4><p>它可以卸载掉那些没用的Asset，把它从内存中清除掉。它也是个Operation，它和加载一样，也是归PreloadManager处理的，它必须独成的，不能并行。因为Unity在一次Load Operation开始的阶段就已经确定了哪些Asset要被Load，所以在Load的过程中又发生了Unload这样的操作，那就会导致有些确定了使用且已经被Load的Asset被卸载掉了，就会导致最后的出错。</p><p>所以Unity现在的设计是一个<code>同步的过程，所以这个过程会造成卡顿</code>。<code>Unity在切换Scene的时候会自动调用一次UnloadUnusedAssets</code>，如果是通过Scene来管理的话就没太大的必要关心造成的卡顿了。如果不是，那就需要自己找些合适的时机去调用一下。</p><h4 id="2-AssetBundle-Unload"><a href="#2-AssetBundle-Unload" class="headerlink" title="2.AssetBundle.Unload"></a>2.AssetBundle.Unload</h4><p>它又分true和false，但是无论哪一个都和上面的不一样，它不是一个Operation，也就是不归PreloadManager管。它会遍历当前加载过的东西，然后去把它删掉。</p><p>如果是true那就是把AssetBundle和它加载出来的Asset全都一起干掉。这个在不合适的时机就有可能发生Runtime的错误。如果是false，那么只是把AssetBundle给丢掉，Asset是不会被扔掉的。那么当你第二次去加载同一个AssetBundle的时候，在内存中就会有两份Asset，因为当AssetBundle被卸载的时候，它和对应的Asset的关系就被切割掉了。所以AssetBundle不知道之前的Asset是不是还在内存中，是不是从自己这加载出来的。所以使用AssetBundle.Unload就很考验游戏的规划。</p><p>Unity为什么不做成Reference？因为Unity内部对于这些Asset实际上是没有Reference的，很多时候是通过遍历去查找，实际上不存在大家想象的ReferenceCount，它和C#其实是不太一样的。</p><p>[<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/ClassIDReference.html]">https://docs.unity3d.com/Manual/ClassIDReference.html]</a>: </p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Asset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity C# News</title>
      <link href="/2022/02-25-2022-2-25-UnityCSharpNews/"/>
      <url>/2022/02-25-2022-2-25-UnityCSharpNews/</url>
      
        <content type="html"><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C#"></a>C#</h1><table><thead><tr><th>C#版本</th><th>.NET版本</th><th>发布日期</th><th>特性</th></tr></thead><tbody><tr><td>C# 1.0</td><td>.NET Framework 1.0</td><td>2002-02-13</td><td>委托、事件</td></tr><tr><td>C# 1.1</td><td>.NET Framework 1.1</td><td>2003-04-24</td><td>APM（异步编程模型）</td></tr><tr><td>C# 2.0</td><td>.NET Framework 2.0</td><td>2005-11-07</td><td>泛型、匿名方法、迭代器、可空类型</td></tr><tr><td>C# 3.0</td><td>.NET Framework 3.0</td><td>2007-11-06</td><td>隐式类型</td></tr><tr><td></td><td>.NET Framework 3.5</td><td>2007-11-19</td><td>对象集合初始化、自动实现属性、匿名类型、扩展方法、查询表达式、Lambda表达式、 表达式树、分部类和方法、Linq</td></tr><tr><td>C# 4.0</td><td>.NET Framework 4.0</td><td>2010-04-12</td><td>动态绑定、命名和可选参数、泛型的协变和逆变、互操作性</td></tr><tr><td>C# 5.0</td><td>.NET Framework 4.5</td><td>2012-08-15</td><td>异步和等待(async和await)、调用方信息(Caller Information)</td></tr><tr><td>C# 6.0</td><td>.NET Framework 4.6</td><td>2015-07-20</td><td>静态导入、<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-version-history#c-version-60">C# 6 中的新增功能</a></td></tr><tr><td></td><td>.NET Core 1.0</td><td>2016-06-27</td><td></td></tr><tr><td>C# 7.0</td><td>.NET Framework 4.6.2</td><td>2016-08-02</td><td>元组、<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-version-history#c-version-70">C# 7.0 中的新增功能</a></td></tr><tr><td>C# 7.1</td><td>.NET Framework 4.7</td><td>2017-04-05</td><td></td></tr><tr><td></td><td>.NET Core 2.0</td><td>2016-08-14</td><td><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/core/whats-new/dotnet-core-2-0">.NET Core 2.0 的新增功能</a></td></tr><tr><td>C# 7.2</td><td>.NET Framework 4.7.1</td><td>2017-10-17</td><td></td></tr><tr><td>C# 7.3</td><td>.NET Framework 4.7.2</td><td>2018-04-30</td><td></td></tr><tr><td></td><td>.NET Core 2.1</td><td>2018-05-30</td><td><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/core/whats-new/dotnet-core-2-1">.NET Core 2.1 的新增功能</a></td></tr><tr><td></td><td>.NET Core 2.2</td><td>2018-12-04</td><td><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/core/whats-new/dotnet-core-2-2">.NET Core 2.2 的新增功能</a></td></tr><tr><td>C# 8.0</td><td>.NET Framework 4.8</td><td>2019-04-18</td><td><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-8">C# 8.0 中的新增功能</a></td></tr><tr><td></td><td>.NET Core 3.0</td><td>2019-09-23</td><td><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/core/whats-new/dotnet-core-3-0">.NET Core 3.0 的新增功能</a></td></tr><tr><td></td><td>.NET Core 3.1</td><td>2019-12-03</td><td><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/core/whats-new/dotnet-core-3-1">.NET Core 3.1 的新增功能</a></td></tr><tr><td>C# 9.0</td><td>.NET 5</td><td>2020-09-04</td><td><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-9">C# 9.0 中的新增功能</a></td></tr><tr><td></td><td>.NET 5</td><td>2020-10-13</td><td><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/core/dotnet-five">What’s new in .NET 5</a></td></tr><tr><td>C# 10.0</td><td>.NET 6</td><td>2021-11-09</td><td><a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/dotnet/welcome-to-csharp-10">欢迎使用 C# 10</a> <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-10">C# 10.0 中的新增功能</a></td></tr><tr><td>C# 11</td><td>.NET 7</td><td></td><td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-11">C# 11 中的新增功能 - C# 指南 - C# </a></td></tr><tr><td>C# 12</td><td>.NET 8</td><td></td><td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-12">C# 12 中的新增功能 - C# 指南 - C#</a></td></tr></tbody></table><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/MingsonZheng/p/11273700.html">C#版本与.NET版本对应关系以及各版本的特性 </a></p><h1 id="Unity"><a href="#Unity" class="headerlink" title="Unity"></a>Unity</h1><p><a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2022.1/Manual/CSharpCompiler.html">C# 编译器 - Unity 手册</a></p><h2 id="各个版本支持情况"><a href="#各个版本支持情况" class="headerlink" title="各个版本支持情况"></a>各个版本支持情况</h2><h3 id="Unity2020-3LTS"><a href="#Unity2020-3LTS" class="headerlink" title="Unity2020.3LTS"></a>Unity2020.3LTS</h3><p>支持C# 8.0</p><table><thead><tr><th><strong>.NET Standard</strong></th><th>受支持</th><th>受支持</th></tr></thead><tbody><tr><td><strong>.NET Framework</strong></td><td>受限</td><td>受支持</td></tr><tr><td><strong>.NET Core</strong></td><td>不受支持</td><td>不受支持</td></tr></tbody></table><p>不受支持的功能</p><ul><li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-8#default-interface-methods">默认接口方法</a></li><li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/ranges-indexes">索引和范围</a></li><li>异步流</li><li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/implementing-disposeasync">异步释放</a></li></ul><hr><h3 id="Unity2021-3LTS"><a href="#Unity2021-3LTS" class="headerlink" title="Unity2021.3LTS"></a>Unity2021.3LTS</h3><p>支持C#9.0</p><table><thead><tr><th><strong>.NET Standard (any version)</strong></th><th>受支持</th><th>受支持</th></tr></thead><tbody><tr><td><strong>.NET Framework (any version)</strong></td><td>Limited support</td><td>受支持</td></tr><tr><td><strong>.NET Core (any version)</strong></td><td>不受支持</td><td>不受支持</td></tr></tbody></table><p>不受支持的功能</p><ul><li>Suppress emitting localsinit flag</li><li>Covariant return types</li><li>Module Initializers</li><li>Extensible calling conventions for unmanaged function pointers</li><li>Init only setters</li></ul><hr><h3 id="Unity2022-3LTS"><a href="#Unity2022-3LTS" class="headerlink" title="Unity2022.3LTS"></a>Unity2022.3LTS</h3><table><thead><tr><th align="left">Managed plug-in compilation target</th><th align="left">API Compatibility Level:</th><th align="left"></th></tr></thead><tbody><tr><td align="left"></td><td align="left"><strong>.NET Standard 2.1</strong></td><td align="left"><strong>.NET 4.x</strong></td></tr><tr><td align="left"><strong>.NET Standard (any version)</strong></td><td align="left">受支持</td><td align="left">受支持</td></tr><tr><td align="left"><strong>.NET Framework (any version)</strong></td><td align="left">Limited support</td><td align="left">受支持</td></tr><tr><td align="left"><strong>.NET Core (any version)</strong></td><td align="left">不受支持</td><td align="left">不受支持</td></tr></tbody></table><p>C# 9.0</p><ul><li>Suppress emitting localsinit flag</li><li>Covariant return types</li><li>Module Initializers</li><li>Extensible calling conventions for unmanaged function pointers</li><li>Init only setters</li></ul><hr><h3 id="改进了Foreach"><a href="#改进了Foreach" class="headerlink" title="改进了Foreach"></a>改进了Foreach</h3><p>参考:</p><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/30334270/answer/49858731">作为Unity3D的脚本而言，c#中for是否真的比foreach效率更高？ - 知乎 (zhihu.com)</a></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/22708768">“Unity与Foreach”这章，终于要翻过去了 - 知乎 (zhihu.com)</a></p><p>主要是<strong>5.5.0b4</strong>之前Mono的Bug,导致在foreach中有装箱过程</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202204291838127.png" alt="preview"></p><p>改进之后</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202204291838671.png" alt="img"></p><h2 id="2022年6月Unity宣布将使用-Net-Core-CLR"><a href="#2022年6月Unity宣布将使用-Net-Core-CLR" class="headerlink" title="2022年6月Unity宣布将使用.Net(Core)CLR"></a>2022年6月Unity宣布将使用.Net(Core)CLR</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/T3e3kj6RCS8fnqutdTj5IA?vid=1688851236501785&deviceid=b106309a-5557-46f0-be27-251c9194eab9&version=4.0.20.6020&platform=win">.NET和Unity的未来，让用户编写高性能代码，并带来长期的稳定性与兼容性 (qq.com)</a></p><h2 id="Unity宣布2023LTS更名为Unity6-并收取安装费"><a href="#Unity宣布2023LTS更名为Unity6-并收取安装费" class="headerlink" title="Unity宣布2023LTS更名为Unity6,并收取安装费"></a>Unity宣布2023LTS更名为Unity6,并收取安装费</h2><p><a target="_blank" rel="noopener" href="https://developer.unity.cn/projects/650025a7edbc2ad788ccc1ea">Unity 收费模式和配套服务更新 - 技术专栏 - Unity官方开发者社区</a></p><p>2023年9月12日推出的安装收费政策引起行业地震</p><blockquote><p><strong>自 2024 年 1 月 1 日起，我们将根据游戏的安装量引入新的 Unity Runtime 费用</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202402281935551.png" alt="d068fb28-05c1-4b9b-b9db-0d4dffa472c6___2023_09_14_15.33.22"></p><p>此后几天Unity紧急修改了协议</p><p><a target="_blank" rel="noopener" href="https://developer.unity.cn/projects/650025a7edbc2ad788ccc1ea">Unity 收费模式和配套服务更新 - 技术专栏 - Unity官方开发者社区</a></p><p><a target="_blank" rel="noopener" href="https://developer.unity.cn/projects/6502cb70edbc2ae4d76aa346">Unity 收费模式和配套服务更新-补充声明 - 技术专栏 - Unity官方开发者社区</a></p><blockquote><p><strong>Unity Personal</strong> 订阅计划仍将保持免费，并且使用 Unity Personal 构建的游戏也不需要支付 Runtime 费用。我们还将把 Unity Personal 订阅计划的收入限制从 10 万美元提高到 20 万美元，并且将取消使用 Made with Unity 启动画面的要求。</p><p>过去 12 个月收入低于 100 万美元的游戏都无需缴纳此项费用。</p><p>对于使用 <strong>Unity Pro</strong> 和 <strong>Unity Enterprise</strong> 的创作者，我们也将根据你们的反馈更改这项政策。</p><p><strong>Runtime 费用政策仅从 2024 年及以后发布的下一个 Unity 长期支持（LTS）版本开始适用。</strong>您当前发布的游戏和正在进行的项目将不包括在内，除非您选择将它们升级到这个新的 Unity 版本。</p><p><strong>我们将确保您可以继续使用适用于您当前 Unity 编辑器版本的条款</strong>，不论您将继续使用这个版本多久。</p><p>对于需要支付 Runtime 费用的游戏，我们将为您提供两个选项：<strong>2.5% 的收入分成</strong>，或者根据每月参与游戏的新用户数量所计算的金额。这两个数字都是根据您已有的数据<strong>自行报告</strong>的。这样您就可以始终选择两者中金额更低的选项支付费用。</p></blockquote><h2 id="2024年1月2日-Unity中国版-团结引擎正式开发下载"><a href="#2024年1月2日-Unity中国版-团结引擎正式开发下载" class="headerlink" title="2024年1月2日,Unity中国版(团结引擎正式开发下载)"></a>2024年1月2日,Unity中国版(团结引擎正式开发下载)</h2><p><a target="_blank" rel="noopener" href="https://developer.unity.cn/projects/65938cdfedbc2afd89198efb">团结引擎创世版正式开放下载 - 技术专栏 - Unity官方开发者社区</a></p><p>团结引擎主要特点是可以方便开发微信小游戏和车载APP</p><h2 id="2024年9月12日-新的CEO宣布取消Runtime收费费用"><a href="#2024年9月12日-新的CEO宣布取消Runtime收费费用" class="headerlink" title="2024年9月12日 新的CEO宣布取消Runtime收费费用"></a>2024年9月12日 新的CEO宣布取消Runtime收费费用</h2><p><a target="_blank" rel="noopener" href="https://unity.com/cn/blog/unity-is-canceling-the-runtime-fee">Unity 将取消 Runtime 费用</a></p><p><a target="_blank" rel="noopener" href="https://unity.com/cn/products/pricing-updates#plans-update">Unity 定价更新和 Runtime 费用的取消 | Unity</a></p><blockquote><p>在与我们的社区、客户和合作伙伴深入沟通后，我们决定取消游戏客户的 Runtime 费用，即刻生效。非游戏领域的工业客户不会受到这一调整的影响。</p><p>在过去的 20 年中，我们与才华横溢的设计师、开发者、艺术家、工程师、发行商和平台携手合作，致力于打造一个人人都能为所有人制作优秀游戏的世界。我们将此称之为“游戏开发大众化”，这一理念至今仍是我们的核心使命。</p><p>然而，我们不能在与客户产生冲突的情况下追求这一使命；它的核心必须是建立在信任基础上的伙伴关系。在过去的三个月里，我有机会与许多人进行交流，听到了你们一再表达的愿望：希望 Unity 能够保持强大，并理解价格上涨是推动游戏行业发展的必要条件。但涨价并不需要以一种标新立异和有争议的新形式出现。我们希望以合理的价格和正确的方式提供价值，让您继续放心地与 Unity 长期合作。我们相信，通过建立良好的合作伙伴关系，并持续提供优质的软件和服务，我们将能共同达成更多成就。</p><p>因此，我们将恢复对所有游戏客户（包括今年晚些时候使用最新推出的、稳定性优异的 <a target="_blank" rel="noopener" href="https://unity.com/cn/releases/unity-6">Unity 6</a> 的用户）实施现有的按席位计费的订阅模式。</p><p>具体变化如下：</p><ul><li><strong>Unity Personal：</strong>正如去年所宣布的，Unity Personal仍将保持免费，我们将把目前的收入和资金上限从 10 万美元提高到 20 万美元。这意味着更多的用户可以免费使用 Unity。当 Unity 6 在今年晚些时候发布时，使用 Unity Personal 制作的游戏将可以选择是否显示“Made with Unity”启动画面。</li><li><strong>Unity Pro 和 Unity Enterprise：</strong>我们将调整订阅价格和年收入门槛，2025 年 1 月 1 日开始生效。这些变更将适用于所有新的和现有的 Unity Pro 和 Enterprise 客户，并在客户在此日期后购买、升级或续订订阅时生效。</li><li><strong>Unity Pro：</strong>Unity Pro 的订阅价格将上调 8%，调整后的价格为每个席位每年 2200 美元。年收入和资金超过 20 万美元的客户需要使用 Unity Pro。</li><li><strong>Unity Enterprise：</strong>Unity Enterprise 的订阅价格将上调 25%。年收入超过 2500 万美元的客户需要使用 Unity Enterprise。可能还需要满足最低订阅要求。由于这一类大客户具有独特需求，并且使用了我们多种产品和服务，我们将在接下来的几天内与每位客户联系，讨论定制化方案。</li></ul><p>从现在开始，我们计划恢复传统的年度价格调整周期，未来价格调整将仅在年度基础上进行。我们的承诺是，如果我们更改编辑器软件条款并影响到您，您可以继续使用适用于您当前软件版本的条款，不论您将继续使用这个版本多久。去年在我们的 <a target="_blank" rel="noopener" href="https://github.com/Unity-Technologies/TermsOfService">GitHub 代码库</a> 和 <a target="_blank" rel="noopener" href="https://unity.com/legal/terms-of-service/software">unity.com&#x2F;legal</a> 上更新了这一承诺。有关我们 2025 年定价调整的详细信息，您可以在<a target="_blank" rel="noopener" href="https://unity.com/cn/products/pricing-updates">此处</a>了解。</p><p>取消游戏的 Runtime 费用并实施这些定价调整，将使我们能够继续投入资源，改进每个人的游戏开发体验，同时也成为更好的合作伙伴。感谢大家的信任与持续支持。我们期待未来与大家继续合作，共同打造更多精彩的游戏。</p><p>– Matt</p></blockquote><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202411081405617.png" alt="image-20241108140458808"></p><h2 id="2025年2月12日-中国境内下载不了Unity6了"><a href="#2025年2月12日-中国境内下载不了Unity6了" class="headerlink" title="2025年2月12日 中国境内下载不了Unity6了"></a>2025年2月12日 中国境内下载不了Unity6了</h2><p>unity6在2024年出的,cn也是能下载,然而今天却下载不了了,上com也会重定向到cn,只能开梯子的global模式才行,怕不是又要变天</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202502122206521.png" alt="image-20250212220558369"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202502122206244.png" alt="image-20250212220646514"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202502122207823.png" alt="image-20250212220657693"></p><h3 id="2025年2月25日更新"><a href="#2025年2月25日更新" class="headerlink" title="2025年2月25日更新"></a>2025年2月25日更新</h3><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202502251813168.png" alt="image-20250225181327611"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202502251823991.png" alt="image-20250225182333942"></p><blockquote><p>自己下载6后  国内ip甚至开始限制不给unity6个人版许可证 一直申请不到授权  刚开始还以为是网络问题   翻墙授权  后面还会封unity账号 尼玛  unity中国下载的hub  默认下载的团结引擎 心中真是一千个草泥马飞过 那傻毕团结引擎  使用费15w  发微信小游戏20w  发鸿蒙20w  去水印20w 个人版发游戏  全程带水印  还无法去除     更二笔的是  团结引擎的.meta文件做了加密     unity工程一旦导入团结后   就再也转不回去unity</p></blockquote><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1HVAZecEA3/?spm_id_from=333.337.search-card.all.click&vd_source=510fe0b8a81e870b3ba755d4b1bb905d">【Lee哥】团结引擎引众怒！谁还敢用你来做游戏？天价收费+强制水印 | 游戏杂谈 | 游戏开发_哔哩哔哩_bilibili</a></p><h2 id="2025年4月8日-Unity中国正式明确下架Unity6且后面只会推团结引擎"><a href="#2025年4月8日-Unity中国正式明确下架Unity6且后面只会推团结引擎" class="headerlink" title="2025年4月8日 Unity中国正式明确下架Unity6且后面只会推团结引擎"></a>2025年4月8日 Unity中国正式明确下架Unity6且后面只会推团结引擎</h2><p><a target="_blank" rel="noopener" href="https://developer.unity.cn/projects/67ee5a4bedbc2a001e9ec5e3">情况说明 - 技术专栏 - Unity官方开发者社区</a></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202504091318411.png" alt="QQ20250409-131702"></p><h2 id="2025年4月9日-官方更新了团结引擎收费政策"><a href="#2025年4月9日-官方更新了团结引擎收费政策" class="headerlink" title="2025年4月9日 官方更新了团结引擎收费政策"></a>2025年4月9日 官方更新了团结引擎收费政策</h2><p><a target="_blank" rel="noopener" href="https://developer.unity.cn/projects/67f4fa33edbc2a001ec2d485">团结引擎定价政策更新公告 - 技术专栏 - Unity官方开发者社区</a></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202504091323764.png" alt="QQ20250409-132058"></p><p>要是早点这么说 说一些原因不得不成立unity中国 然后推团结引擎 也不会引发这么多众怒</p><p>不过这个政策的更新其实还是未说明,是否可以使用国际版. 他的意思只是表明不在维护2022以上的unity版本,也不会提供下载，目前只是提供团结引擎的支持</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Audio In Unity</title>
      <link href="/2022/01-12-2022-1-12-Audio-In-Unity/"/>
      <url>/2022/01-12-2022-1-12-Audio-In-Unity/</url>
      
        <content type="html"><![CDATA[<h1 id="Audio-In-Unity"><a href="#Audio-In-Unity" class="headerlink" title="Audio In Unity"></a>Audio In Unity</h1><h3 id="Unity中支持的音频格式"><a href="#Unity中支持的音频格式" class="headerlink" title="Unity中支持的音频格式"></a>Unity中支持的音频格式</h3><table><thead><tr><th>MPEG layer 3</th><th>.mp3</th></tr></thead><tbody><tr><td>Ogg Vorbis</td><td>.ogg</td></tr><tr><td>Microsoft Wave</td><td>.wav</td></tr><tr><td>音频交换文件格式</td><td>.aiff &#x2F; .aif</td></tr><tr><td>Ultimate Soundtracker 模块</td><td>.mod</td></tr><tr><td>Impulse Tracker 模块</td><td>.it</td></tr><tr><td>Scream Tracker 模块</td><td>.s3m</td></tr><tr><td>FastTracker 2 模块</td><td>.xm</td></tr></tbody></table><ul><li>WAV：微软公司开发的一种声音文件格式，简单的编&#x2F;解码、普遍的认同&#x2F;支持以及无损耗存储，目前Windows上最流行的声音文件格式，资源大，不推荐</li><li>MP3：是MPEG标准中的音频部分，大小只有WAV文件的1&#x2F;10，是一种有损压缩数字音频格式，失真小，适合音质要求高的文件，例如BGM</li><li>OGG：是一种新的音频压缩格式，类似MP3的音乐格式，它是完全免费、开放和没有专利限制的。压缩比高，适合人声、音效等</li></ul><h3 id="Unity-Audio设置"><a href="#Unity-Audio设置" class="headerlink" title="Unity Audio设置"></a>Unity Audio设置</h3><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202204291837816.png" alt="image-20220113152429032"></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/357031530">Unity音频优化实践 - 知乎 (zhihu.com)</a></p><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv8598101/">ProjectSetting-音频 - 哔哩哔哩 (bilibili.com)</a></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_30432179/article/details/98021374">音频系统（一）_weixin_30432179的博客-CSDN博客</a></p><h3 id="导入设置"><a href="#导入设置" class="headerlink" title="导入设置"></a>导入设置</h3><h4 id="LoadType"><a href="#LoadType" class="headerlink" title="LoadType"></a>LoadType</h4><table><thead><tr><th>Load Type</th><th>类型</th><th>特点</th></tr></thead><tbody><tr><td>Decompress On Load</td><td>加载时解压缩</td><td>解压完整的数据进内存,<strong>需要的内存最多</strong>，适合小音频，不要对大型文件使用，会消耗最高的内存。在加载时解压缩 Vorbis 编码的声音所使用的内存量是保持压缩状态时内存使用量的 10 倍（ADPCM 编码约为 3.5 倍）</td></tr><tr><td>Compressed In Memory</td><td>压缩在内存中</td><td>压缩后的音频剪辑存储在RAM中，播放时将解压缩，CPU消耗比较大（尤其是对于Ogg &#x2F; Vorbis压缩文件），适合对较大的文件。<strong>较大的声音（保持解压的状态）</strong></td></tr><tr><td>Streaming</td><td>即时解码</td><td>播放音频的时候流式加载，好处是文件不占用内存，坏处是加载的时候对IO、CPU都会有开销。即使没有加载任何音频数据，每个音频片段也会有大约200KB的过载</td></tr></tbody></table><p><a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/current/Manual/class-AudioClip.html">音频剪辑 - Unity 手册</a></p><p><strong>Preload Audio Data:预加载音频数据</strong></p><blockquote><p>如果启用，音频剪辑将在场景加载时预先加载。如果未设置该标志，音频数据将加载到第一个 <a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/current/Manual/class-AudioSource.html">AudioSource</a>.Play()&#x2F;<a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/current/Manual/class-AudioSource.html">AudioSource</a>.PlayOneShot()，或者它可以通过加载AudioSource.LoadAudioData()，并通过再次卸载的AudioSource .UnloadAudioData()。</p><p>预加载音效数据，这个是在进入场景的时候进行预加载的，会占用内存，我们项目一般对大于10秒的文件都不进行预加载，除非有特殊情况。知道这个文件在这个场景内肯定会用到，需要提前进行预加载。其他文件都勾选预加载。</p></blockquote><h4 id="Compression-Format"><a href="#Compression-Format" class="headerlink" title="Compression Format"></a>Compression Format</h4><table><thead><tr><th><strong>Compression Format</strong></th><th>在运行时将用于声音的特定格式。请注意，可用选项取决于当前选定的构建目标。</th><th></th></tr></thead><tbody><tr><td></td><td><strong>PCM(Pulse-Code Modulation)</strong></td><td>此选项提供高质量，代价是文件内存变大，适合内存小的声音效果。</td></tr><tr><td></td><td><strong>ADPCM</strong></td><td>此格式适用于大量噪音和需要大量播放的声音（例如脚步声、撞击声、武器声音）。较之于 PCM，压缩能力提高 3.5 倍，但 CPU 使用率远低于 MP3&#x2F;Vorbis 格式，因此成为上述声音类别的最佳压缩方案。</td></tr><tr><td></td><td><strong>Vorbis&#x2F;MP3</strong></td><td>压缩使文件减小，但与 PCM 音频相比，质量降低。可通过 Quality 滑动条来配置压缩量。此格式最适合中等长度的音效和音乐。</td></tr></tbody></table><h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202204291837604.png" alt="20180815204948831"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202204291837797.jpeg" alt="20180815205002197"></p><p>总结:</p><ol><li><p>音频导出都是44100HZ,进入Unity可以使用22050HZ,质量(Quality )一般不调节,会模糊,具体可以让音频师听.</p></li><li><p><del>导出可以直接使用<code>OGG</code>格式,MP3格式在对于Loop循环播放的时候会有中断现象</del></p></li><li><p>原始使用wav格式,导入到unity会直接压缩</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202204291837827.png" alt="image-20220113142102271"></p></li><li><p>压缩格式选择</p><p>除非高要求使用<code>PCM</code>,否则都是用<code>Vorbis</code>(手机上对这个支持好)</p><p>之前2021版本之前说 MP3比vorbis格式好</p><p><a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2020.3/Manual/iphone-GettingStarted.html">iOS 开发入门 - Unity 手册</a></p><blockquote><h3 id="音频压缩"><a href="#音频压缩" class="headerlink" title="音频压缩"></a>音频压缩</h3><p>Unity 支持导入各种源格式的声音文件。但是，在导入这些文件时（音轨文件除外），它们始终会重新编码为构建目标格式。默认情况下，此格式为 Vorbis，但如果需要，可以根据平台改用其他格式（ADPCM、MP3 等）。与 Vorbis 播放相比，MP3 播放在 iPhone 上的性能稍好一些。</p></blockquote><p>后面在2022之后又说Vorbis更好些</p><p><a target="_blank" rel="noopener" href="https://docs.unity3d.com/2022.3/Documentation/Manual/ios-requirements-and-compatibility.html">Unity - Manual: iOS requirements and compatibility (unity3d.com)</a></p><blockquote><h2 id="Audio-compression"><a href="#Audio-compression" class="headerlink" title="Audio compression"></a>Audio compression</h2><p>Unity supports importing a variety of source format sound files. However, when importing the sound files (except tracker files), they’re always re-encoded to the build target format. By default, these files are in <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Vorbis">Vorbis</a> format, but you can override them to other formats (such as ADPCM, MP3) for each platform, if required. Vorbis playback provides better compression and quality for iOS compared to MP3 playback.</p></blockquote></li><li><p>加载格式选择</p><ul><li>小音频 0-2s 使用 <code>Decompress On Load</code></li><li>中等音频 &gt;2-10s 使用 <code>Compressed In Memory</code></li><li>大音频 使用 <code>Steaming</code></li></ul></li><li><p>一旦声音不使用,直接<code>删除AudioSource</code>组件是最好的方式</p></li><li><p>一般文件都启用<code>Preload Audio Data</code>预加载 大文件不用(<code>如果设置成Steaming Unity自动默认不勾选</code>) 由于播放延迟和性能消耗，不建议在播放的瞬间加载。应该控制加载在播放之前的某些方便的时间使用AudioClip对象的LoadAudioData()方法加载。也可以用AudioClip对象的UnloadAudioData()方法手动控制声音文件的内存释放。如果<code>Preload Audio Data</code>不勾选 默认在使用<code>Play</code>方法后加载</p></li></ol><h3 id="遇到的问题以及解决方案"><a href="#遇到的问题以及解决方案" class="headerlink" title="遇到的问题以及解决方案"></a>遇到的问题以及解决方案</h3><ol><li>循环声音有中断现象 把MP3声音改成OGG格式</li><li><del>播放声音有延迟 <code>Edit → Project Settings → Audio</code> → 设置DSP Buffer size为<strong>Best latency</strong>（设置 dsp 缓冲区大小以优化延迟或性能，设置一个不合适的值会导致安卓设备的电流音)[unity 音效延迟</del>](<a target="_blank" rel="noopener" href="https://blog.csdn.net/dfgjava/article/details/47105503">https://blog.csdn.net/dfgjava/article/details/47105503</a>) 不要使用这个 经验证部分手机会出现音频无法播放或者音速变慢或音调奇怪现象</li></ol><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a target="_blank" rel="noopener" href="https://blog.uwa4d.com/archives/UWA_Pipeline17.html">3分钟就能掌握的视频&#x2F;音频优化技巧！ - UWA Blog (uwa4d.com)</a></p><p><a target="_blank" rel="noopener" href="https://learn.u3d.cn/tutorial/mobile-game-optimization#61164434984fa8002175f3bc">移动游戏优化指南 - Unity中文课堂 (u3d.cn)</a></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/299799873">【内存优化】Unity音频资源优化 - 知乎 (zhihu.com)</a></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/353294079?ivk_sa=1024320u">Unity音效文件Audio Clip 导入设置 - 知乎 (zhihu.com)</a></p><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0a065da7e106">浅谈Unity中Android、iOS音频延迟 - 简书 (jianshu.com)</a></p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/RainPaint/p/13156683.html">音频(一)_音频认知(3.音频采样) - RainPainter雨画 - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Asset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Audio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity上架GooglePlay 未完待续...</title>
      <link href="/2022/01-11-2022-1-11-Unity%E4%B8%8A%E6%9E%B6GooglePlay/"/>
      <url>/2022/01-11-2022-1-11-Unity%E4%B8%8A%E6%9E%B6GooglePlay/</url>
      
        <content type="html"><![CDATA[<h1 id="前期设置"><a href="#前期设置" class="headerlink" title="前期设置"></a>前期设置</h1><ol><li><h4 id="科学上网-谷歌账户-成为Google开发者"><a href="#科学上网-谷歌账户-成为Google开发者" class="headerlink" title="科学上网 谷歌账户 成为Google开发者"></a>科学上网 谷歌账户 成为Google开发者</h4><p><a target="_blank" rel="noopener" href="https://play.google.com/intl/zh-CN/console/about/">Google Play 管理中心 | Google Play 管理中心</a></p></li><li><h4 id="JDK-安装"><a href="#JDK-安装" class="headerlink" title="JDK 安装"></a>JDK 安装</h4></li><li><h4 id="SDK-按照-务必添加"><a href="#SDK-按照-务必添加" class="headerlink" title="SDK 按照 务必添加"></a>SDK 按照 务必添加</h4><ul><li>Android Support Repository</li><li>Google Play Services</li><li>Google Repository</li></ul><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zgjllf1011/article/details/79282429">unity接入googleplay</a></p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Ronaldo-HD/p/9287621.html">Android 环境搭建与Android SDK目录介绍 - Charles-MQ - 博客园 (cnblogs.com)</a></p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kangjianwei101/p/5621238.html">Android SDK Manager和AVD Manager使用 - 康建伟 - 博客园 (cnblogs.com)</a></p></li><li><h4 id="Unity中设置"><a href="#Unity中设置" class="headerlink" title="Unity中设置"></a>Unity中设置</h4><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202204291836189.png" alt="image-20220111161520587"></p><p>只有<code>IL2CPP</code>才有64位</p><p>关于<code>ARMv7 ARM64</code></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202204291836553.png" alt="image-20220112183114981"></p><p>​<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e7b104c6b5f1">arm64、armv7、armv7s是指什么？ - 简书 (jianshu.com)</a></p><p>​<a target="_blank" rel="noopener" href="https://developer.android.google.cn/distribute/best-practices/develop/64-bit?hl=zh-cn#native-code">支持 64 位架构  | Google Play  | Android Developers</a></p></li><li><h4 id="设置keystone"><a href="#设置keystone" class="headerlink" title="设置keystone"></a>设置keystone</h4><p>用Unity自带工具就可以,切记打包出来的APK和<code>keystore</code>签名确保一致</p><p><code>keytool -list  -v -keystore aa/bb/md.keystore</code>  </p><p>CMD控制台查看签名信息</p><p>打包后apk,解压,找到<code>META-INF\CERT.RSA</code> 文件,输入命令:</p><p><code>keytool -printcert -file xxx\META-INF\CERT.RSA</code></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/willba/article/details/79476904">Android 对apk进行重签名和查看签名(window 和mac)及生成签名</a></p></li><li><h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zgjllf1011/article/details/79282429">unity接入googleplay</a></p><p><a target="_blank" rel="noopener" href="https://shuaici.blog.csdn.net/article/details/113779439">aab 大小限制</a></p><p><a target="_blank" rel="noopener" href="https://android-developers.googleblog.com/2020/11/new-android-app-bundle-and-target-api.html">Android 开发人员博客：2021 年新的 Android 应用捆绑包和目标 API 级别要求 (googleblog.com)</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Untiy </tag>
            
            <tag> GooglePlay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2021/10-28-2021-0-28-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2021/10-28-2021-0-28-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>一、存储地址<br>链式存储：储存单位的地址不一定是连续的<br>顺序存储：储存单位的地址必须是连续的</p><p>二、存储空间利用率与分配<br>链式存储：利用率低，动态分配<br>顺序存储：利用率高，静态分配</p><p>三、修改内容速度<br>链式存储：修改速度快<br>顺序存储：修改速度慢</p><p>三、查询内容速度<br>链式存储：查询速度慢<br>顺序存储：查询速度快</p><h3 id="Stack-堆栈"><a href="#Stack-堆栈" class="headerlink" title="Stack(堆栈)"></a>Stack(堆栈)</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">StackTest</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//stack 栈是一种先进后出的数据结构</span></span><br><span class="line">        <span class="comment">//比喻成汉诺塔叠块 最先放入的只能最后拿出来</span></span><br><span class="line">        Stack&lt;<span class="built_in">int</span>&gt; stack = <span class="keyword">new</span> Stack&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">region</span> 增 O(1) push 入栈 </span></span><br><span class="line">        stack.Push(<span class="number">1</span>);</span><br><span class="line">        stack.Push(<span class="number">2</span>);</span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">region</span> 删 O(1) pop出栈  每次出最上面的一个</span></span><br><span class="line">        stack.Pop();</span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">region</span> 改</span></span><br><span class="line">        <span class="comment">//清空 无法插入</span></span><br><span class="line">        stack.Clear();</span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">region</span> 查</span></span><br><span class="line">        <span class="comment">//查 O(1) peek 只查看不出栈 O(1)</span></span><br><span class="line">        stack.Peek();</span><br><span class="line">        <span class="comment">//查 O(n)</span></span><br><span class="line">        stack.Contains(<span class="number">111</span>);</span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">region</span> 遍历</span></span><br><span class="line">        <span class="comment">//遍历从栈顶开始遍历也就是压入的最后一个元素开始  foreach x.ToArray</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> stack)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> nums = stack.ToArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环弹栈</span></span><br><span class="line">        <span class="keyword">while</span> (stack.Count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            stack.Pop();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Queue-队列"><a href="#Queue-队列" class="headerlink" title="Queue(队列)"></a>Queue(队列)</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">QueueTest</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//队列是一种先进先出的数据结构</span></span><br><span class="line">        <span class="comment">//比喻成  人排队 先到先得( 先出来 )</span></span><br><span class="line">        Queue&lt;<span class="built_in">int</span>&gt; queue = <span class="keyword">new</span> Queue&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">region</span> 增 O(1)</span></span><br><span class="line">        queue.Enqueue(<span class="number">1</span>);</span><br><span class="line">        queue.Enqueue(<span class="number">2</span>);</span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">region</span> 删除 O(1)</span></span><br><span class="line">        queue.Dequeue();</span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">region</span> 改</span></span><br><span class="line">        queue.Clear();</span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">region</span> 查</span></span><br><span class="line">        queue.Peek();<span class="comment">//O(1) 查看最上面一个 不出队列</span></span><br><span class="line"></span><br><span class="line">        queue.Contains(<span class="number">11</span>); <span class="comment">//O(n) </span></span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">region</span> 遍历</span></span><br><span class="line">        <span class="comment">//遍历的第一个元素就是第一个压入的元素</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> queue)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> nums = queue.ToArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="LinkedList-双链表"><a href="#LinkedList-双链表" class="headerlink" title="LinkedList(双链表)"></a>LinkedList(双链表)</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">LinkedListTest</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//双向链表  链式存贮  修改快  查询慢 读少写多</span></span><br><span class="line">    LinkedList&lt;<span class="built_in">int</span>&gt; linkedlist = <span class="keyword">new</span> LinkedList&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 增  O(1)</span></span><br><span class="line">    linkedlist.AddFirst(<span class="number">1</span>);</span><br><span class="line">    linkedlist.AddLast(<span class="number">10</span>);</span><br><span class="line">    linkedlist.AddAfter(linkedlist.First,<span class="number">5</span>); <span class="comment">//在第一个节点后面插入一个10</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 删除 O(1)</span></span><br><span class="line">    linkedlist.RemoveFirst();</span><br><span class="line">    linkedlist.RemoveLast();</span><br><span class="line">    linkedlist.Remove(<span class="number">5</span>);  <span class="comment">//移除值是O(n)</span></span><br><span class="line">    linkedlist.Remove(linkedlist.First);<span class="comment">//移除节点是 O(1)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 改</span></span><br><span class="line">    linkedlist.First.Value = <span class="number">100</span>; <span class="comment">//直接改值</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 查</span></span><br><span class="line">    <span class="keyword">var</span> first = linkedlist.First;</span><br><span class="line">    <span class="keyword">var</span> last = linkedlist.Last;</span><br><span class="line">    linkedlist.Find(<span class="number">10</span>);  <span class="comment">//O(n)</span></span><br><span class="line">    linkedlist.Contains(<span class="number">10</span>);<span class="comment">//O(n)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#知识总结</title>
      <link href="/2021/10-28-2021-0-28-CShape/"/>
      <url>/2021/10-28-2021-0-28-CShape/</url>
      
        <content type="html"><![CDATA[<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ul><li><p>泛型类 </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明泛型类 T 表示一个占位 也可以声明多个</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TTest</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    TTest&lt;<span class="built_in">int</span>&gt; testint = <span class="keyword">new</span> TTest&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">    testint.<span class="keyword">value</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    TTest&lt;<span class="built_in">string</span>&gt; teststr = <span class="keyword">new</span> TTest&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">    teststr.<span class="keyword">value</span> = <span class="string">&quot;aa&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>泛型方法</p>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>&lt;<span class="title">T</span>&gt;(<span class="params">T t</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>泛型接口</p></li><li><p>泛型约束</p><p><code>where</code></p><p>有6种</p><ol><li><code>where T :  struct</code>类型参数必须是值类型。可以指定除 Nullable 以外的任何值类型。</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TTest</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span>: <span class="title">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    TTest&lt;<span class="built_in">int</span>&gt; testint = <span class="keyword">new</span> TTest&lt;<span class="built_in">int</span>&gt;();  <span class="comment">//ok</span></span><br><span class="line">    testint.<span class="keyword">value</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    TTest&lt;<span class="built_in">object</span>&gt; teststr = <span class="keyword">new</span> TTest&lt;<span class="built_in">object</span>&gt;();  <span class="comment">//不通过</span></span><br><span class="line">    teststr.<span class="keyword">value</span> = <span class="string">&quot;aa&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p><code>where T :Class</code>类型参数必须是引用类型，包括任何类、接口、委托或数组类型 </p><p>……</p></li><li><p><code>where T: new()</code>类型参数必须具有无参数的公共构造函数。当与其他约束一起使用时，new() 约束必须最后指定。</p></li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TTest</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span>: <span class="title">new</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">T1</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">//默认有一个无参的构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">T2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//声明了别的构造函数 默认的无参构造函数就没了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">T2</span>(<span class="params"><span class="built_in">int</span> a</span>)</span></span><br><span class="line">    &#123; </span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    TTest&lt;T1&gt; test1 = <span class="keyword">new</span> TTest&lt;T1&gt;();</span><br><span class="line"></span><br><span class="line">    TTest&lt;T2&gt; test2 = <span class="keyword">new</span> TTest&lt;T2&gt;(); <span class="comment">//错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><code>where T: 基类名 </code>类型参数必须是指定的基类或派生自指定的基类。</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TTest</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span>: <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">T1</span>:<span class="title">MonoBehaviour</span></span><br><span class="line">&#123; </span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">T2</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    TTest&lt;T1&gt; test1 = <span class="keyword">new</span> TTest&lt;T1&gt;();</span><br><span class="line"></span><br><span class="line">    TTest&lt;T2&gt; test2 = <span class="keyword">new</span> TTest&lt;T2&gt;(); <span class="comment">//错误 不是派生子MonoBehaviour</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><p><code>where T  接口名</code> 类型参数必须是指定的接口或实现指定的接口。可以指定多个接口约束。约束接口也可以是泛型的。</p></li><li><p><code>where T U</code>  为 T 提供的类型参数必须是为 U 提供的参数或派生自为 U 提供的参数。这称为裸类型约束.</p></li></ol>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TTest</span>&lt;<span class="title">T</span>,<span class="title">U</span>&gt; <span class="keyword">where</span> <span class="title">T</span>: <span class="title">U</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> T <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">T1</span>:<span class="title">MonoBehaviour</span></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">T2</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">TTest&lt;T1,MonoBehaviour&gt; test1 = <span class="keyword">new</span> TTest&lt;T1,MonoBehaviour&gt;();</span><br><span class="line"></span><br><span class="line">TTest&lt;T2,MonoBehaviour&gt; test2 = <span class="keyword">new</span> TTest&lt;T2, MonoBehaviour&gt;(); <span class="comment">//错误 不是派生子MonoBehaviour</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><table><thead><tr><th>BindingFlags</th><th>枚举类型</th></tr></thead><tbody><tr><td>BindingFlags.IgnoreCase</td><td>表示忽略 name 的大小写，不应考虑成员名的大小写</td></tr><tr><td>BindingFlags.DeclaredOnly</td><td>只应考虑在所提供类型的层次结构级别上声明的成员。不考虑继承成员。</td></tr><tr><td>BindingFlags.Instance</td><td>只搜索实例成员</td></tr><tr><td>BindingFlags.Static</td><td>只搜索静态成员</td></tr><tr><td>BindingFlags.Public</td><td>只搜索公共成员</td></tr><tr><td>BindingFlags.NonPublic</td><td>只搜索非公共成员</td></tr><tr><td>BindingFlags.FlattenHierarchy</td><td>应返回层次结构上的公共静态成员和受保护的静态成员。不返回继承类中的私有静态成员。静态成员包括字段、方法、事件和属性。不返回嵌套类型。</td></tr><tr><td>BindingFlags.InvokeMethod</td><td>表示调用方法，而不调用构造函数或类型初始值设定项。对 SetField 或 SetProperty 无效。</td></tr><tr><td>BindingFlags.CreateInstance</td><td>表示调用构造函数。忽略 name。对其他调用标志无效。</td></tr><tr><td>BindingFlags.GetField</td><td>表示获取字段值</td></tr><tr><td>BindingFlags.SetField</td><td>表示设置字段值。</td></tr><tr><td>BindingFlags.GetProperty</td><td>表示获取属性。</td></tr><tr><td>BindingFlags.SetProperty</td><td>表示设置属性。</td></tr></tbody></table><p>BindingFlags.Public|BindingFlags.Instance 默认查找public、instance内容<br>BindingFlags.NonPublic|BindingFlags.Instance 查找nonpublic、instance内容<br><code>BindingFlags.Instance和BindingFlags.Static二者必须有一项或者都有</code>。如果你的类是instance，就选instance，反之选static。如果两者都不选，是找不到任何方法的</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> TestType;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyTest myTest = <span class="keyword">new</span> MyTest(); <span class="comment">//实例对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取类信息</span></span><br><span class="line">        Type type1 = <span class="keyword">typeof</span>(MyTest);</span><br><span class="line">        Type type2 = (<span class="keyword">new</span> MyTest()).GetType();</span><br><span class="line">        Type type3 = Type.GetType(<span class="string">&quot;TestType.MyTest&quot;</span>); <span class="comment">//命名空间+类名</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">region</span> 获取类型的属性</span></span><br><span class="line">        Debug.Log(type1.Name);</span><br><span class="line">        Debug.Log(type1.IsAbstract);<span class="comment">//指示该类型是否是抽象类型</span></span><br><span class="line">        Debug.Log(type1.IsClass);   <span class="comment">//是否是类 </span></span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">region</span> 获取类中信息</span></span><br><span class="line">        <span class="comment">/* GetConstructor(), GetConstructors():返回ConstructorInfo类型, 用于取得该类的构造函数的信息</span></span><br><span class="line"><span class="comment">            GetEvent(), GetEvents():返回EventInfo类型,用于取得该类的事件的信息</span></span><br><span class="line"><span class="comment">            GetField(), GetFields():返回FieldInfo类型,用于取得该类的字段(成员变量)的信息</span></span><br><span class="line"><span class="comment">            GetInterface(), GetInterfaces():返回InterfaceInfo类型,用于取得该类实现的接口的信息</span></span><br><span class="line"><span class="comment">            GetMember(), GetMembers():返回MemberInfo类型,用于取得该类的所有成员的信息</span></span><br><span class="line"><span class="comment">            GetMethod(), GetMethods():返回MethodInfo类型,用于取得该类的方法的信息</span></span><br><span class="line"><span class="comment">            type1.GetEnumName :返回枚举</span></span><br><span class="line"><span class="comment">            GetProperty(), GetProperties():返回PropertyInfo类型,用于取得该类的属性的信息可以调用这些成员,其方式是调用Type的InvokeMember()方法,或者调用MethodInfo, PropertyInfo和其他类的Invoke()方法。*/</span></span><br><span class="line"></span><br><span class="line">        MemberInfo[] members = type1.GetMembers(); <span class="comment">//获取所有成员</span></span><br><span class="line">        type1.GetConstructors();  <span class="comment">//获取所有构造函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取无参数构造函数</span></span><br><span class="line">        ConstructorInfo constructorInfo = type1.GetConstructor(<span class="keyword">new</span> Type[<span class="number">0</span>]); <span class="comment">//要传入一个tpye数组 如果没有参数就是0</span></span><br><span class="line">        <span class="comment">//调用构造函数 实例化一个对象</span></span><br><span class="line">        <span class="keyword">var</span> obj = constructorInfo.Invoke(<span class="literal">null</span>); <span class="comment">//没有参数写null</span></span><br><span class="line">        MyTest myt = obj <span class="keyword">as</span> MyTest;</span><br><span class="line">        Debug.Log(<span class="string">$&quot;---<span class="subst">&#123;myt.publicnum2&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取有参数的构造函数</span></span><br><span class="line">        ConstructorInfo constructorInfo2 = type1.GetConstructor(<span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(<span class="built_in">string</span>), <span class="keyword">typeof</span>(<span class="built_in">int</span>) &#125;); <span class="comment">//要传入一个tpye数组 参数为对应构造函数的参数</span></span><br><span class="line">        <span class="keyword">var</span> obj2 = constructorInfo2.Invoke(<span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="string">&quot;aaa&quot;</span>, <span class="number">2</span> &#125;) <span class="keyword">as</span> MyTest; <span class="comment">//传入对应实参</span></span><br><span class="line">        Debug.Log(<span class="string">$&quot;---<span class="subst">&#123;obj2.publicnum2&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取成员变量</span></span><br><span class="line">        type1.GetFields();</span><br><span class="line">        <span class="keyword">var</span> num = type1.GetField(<span class="string">&quot;num2&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> num1 = type1.GetField(<span class="string">&quot;num1&quot;</span>, BindingFlags.Instance | BindingFlags.NonPublic); <span class="comment">//反射私有成员变量</span></span><br><span class="line">        Debug.Log(num1.GetValue(myTest)); <span class="comment">//必须要设置获取对象 </span></span><br><span class="line">        num1.SetValue(myTest, <span class="number">22</span>);  <span class="comment">//设置值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取成员方法</span></span><br><span class="line">        type1.GetMethods();</span><br><span class="line">        MethodInfo methodInfo = type1.GetMethod(<span class="string">&quot;DoDebug&quot;</span>, <span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(<span class="built_in">int</span>) &#125;);</span><br><span class="line">        methodInfo.Invoke(myTest, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="number">123</span> &#125;);</span><br><span class="line">        <span class="comment">//如果是静态方法,第一个方法传入null  methodInfo.Invoke(null, new object[] &#123; 123 &#125;);</span></span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">region</span> Activator</span></span><br><span class="line">        <span class="comment">//Activator帮助我们快捷创建对象 快捷创建一个 无参数构造函数</span></span><br><span class="line">        MyTest myTest1 = Activator.CreateInstance(<span class="keyword">typeof</span>(MyTest)) <span class="keyword">as</span> MyTest;</span><br><span class="line">        <span class="comment">//有参数 直接后面传入对应参数</span></span><br><span class="line">         myTest1 = Activator.CreateInstance(<span class="keyword">typeof</span>(MyTest),<span class="string">&quot;str&quot;</span>,<span class="number">10</span>) <span class="keyword">as</span> MyTest;</span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">         <span class="meta">#<span class="keyword">region</span> Assembly</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">TestType</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyTest</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">string</span> constStr = <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> staticNum = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> publicnum2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> publicstr = <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> num1 = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> PropertyNum3 &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyTest</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyTest</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">$&quot;<span class="subst">&#123;<span class="keyword">nameof</span>(MyTest)&#125;</span> 构造函数打印参数: <span class="subst">&#123;i&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyTest</span>(<span class="params"><span class="built_in">string</span> str, <span class="built_in">int</span> i</span>) : <span class="title">this</span>(<span class="params">i</span>) <span class="comment">//this:调用该构造函数时候 先调用上一个构造函数</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">$&quot;<span class="subst">&#123;<span class="keyword">nameof</span>(MyTest)&#125;</span> 构造函数打印参数: <span class="subst">&#123;i&#125;</span> _<span class="subst">&#123;str&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoDebug</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">$&quot;<span class="subst">&#123;<span class="keyword">nameof</span>(MyTest)&#125;</span> DoDebug方法打印参数: <span class="subst">&#123;i&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/41282759">C#反射机制 - 知乎 (zhihu.com)</a></p><h3 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h3><ol><li>变量声明周期</li></ol><p>用<code>&#123;&#125;</code>包裹的变量 对于<code>值类型</code> 执行完 就会清空栈里面的值类型数据  对于<code>引用类型</code>会断开与堆中链接 等待下次GC回收</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> a=<span class="number">10</span>;  <span class="comment">//执行完毕会立即回收清除</span></span><br><span class="line">    <span class="built_in">string</span> str=<span class="string">&quot;aa&quot;</span>; <span class="comment">//栈上清除了 堆上还存在等待GC</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> a=<span class="number">10</span>; <span class="comment">//这里在栈中会一直出栈 又新的压入栈 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>值类型在内存中</p><p>值类型分配在内存栈中</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> TestStruct</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> a;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">object</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TestStruct tc=<span class="keyword">new</span> TestStruct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上一段代码 Struct 在内存中</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202204291836778.png" alt="image-20211028142635452"></p></li><li><p>引用类型在内存中</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span> obj=<span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">    <span class="keyword">public</span> TestStruct ts=<span class="keyword">new</span> TestStruct();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TestClass tc=<span class="keyword">new</span> TestClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202204291843060.png" alt="image-20211028143344536"></p><p><code>数组</code>也是引用类型</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> []nums=<span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">object</span>[]objs=<span class="keyword">new</span> <span class="built_in">object</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202204291836643.png" alt="image-20211028144044738"></p></li><li><p>struct 在继承接口进行里氏转换的时候会装修拆箱</p><p><code>原因是因为接口是引用类型</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IStruct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> Value &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> TestStruct: IStruct</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Value &#123;</span><br><span class="line">        <span class="keyword">get</span>;<span class="keyword">set</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">TestStruct ts1 = <span class="keyword">new</span> TestStruct();</span><br><span class="line">ts1.Value = <span class="number">10</span>;</span><br><span class="line">TestStruct ts2 = ts1;</span><br><span class="line">ts2.Value = <span class="number">100</span>;</span><br><span class="line">Debug.Log(<span class="string">$&quot;ts1:<span class="subst">&#123;ts1.Value&#125;</span> ts2:<span class="subst">&#123;ts2.Value&#125;</span>&quot;</span>);  <span class="comment">//10   100</span></span><br><span class="line"></span><br><span class="line">IStruct Its1 = ts1;</span><br><span class="line">Its1.Value = <span class="number">10</span>;</span><br><span class="line">IStruct Its2 = Its1;</span><br><span class="line">Its2.Value = <span class="number">100</span>;</span><br><span class="line">Debug.Log(<span class="string">$&quot;ts1:<span class="subst">&#123;Its1.Value&#125;</span> ts2:<span class="subst">&#123;Its2.Value&#125;</span>&quot;</span>);  <span class="comment">//100  100</span></span><br></pre></td></tr></table></figure><p>​</p></li></ol><p></p><h3 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h3><ol><li>异步编程不能加快<code>目标代码</code>的运行效率</li><li>异步方法不等于多线程</li><li>异步方法一般返回值是<code>Task&lt;T&gt;</code>或<code>Task</code>,方法名以<code>Async</code>结尾</li><li>调用异步方法一般在前面加上<code>await</code> 用于取得放回值</li><li>异步方法具有<code>传染性</code>,一个方法中如果要用<code>await</code>,则这个方法必须要用<code>async</code>修饰</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Start();</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(Thread.CurrentThread.ManagedThreadId);<span class="comment">//1</span></span><br><span class="line">            <span class="built_in">string</span> s = <span class="keyword">await</span> TestRead();</span><br><span class="line">            <span class="built_in">string</span> s2 = <span class="keyword">await</span> TestRead2();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">TestRead</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//用await获取结果</span></span><br><span class="line">            <span class="built_in">string</span> str = <span class="keyword">await</span> File.ReadAllTextAsync(<span class="string">@&quot;c:/temp/1.txt&quot;</span>);</span><br><span class="line">            <span class="comment">//一般不用</span></span><br><span class="line">            <span class="comment">//var task = File.ReadAllTextAsync(@&quot;c:/temp/1.txt&quot;);</span></span><br><span class="line">            <span class="comment">//string s = task.Result; </span></span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不用await 包装</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">TestRead2</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> File.ReadAllTextAsync(<span class="string">@&quot;c:/temp/1.txt&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>死锁情况:<a target="_blank" rel="noopener" href="http://blog.walterlv.com/post/deadlock-in-task-wait.html">使用 Task.Wait()？立刻死锁（deadlock） - walterlv</a></p><blockquote><p>明确了会造成死锁的条件和不会造成死锁的条件后，我们只需要做到以下几点即可避免死锁了：</p><ol><li>在 UI 线程，如果使用了 <code>async</code>&#x2F;<code>await</code>，就尽量不要再使用 <code>Task.Wait()</code>&#x2F;<code>Task.Result</code> 了，就一直异步一条路走到黑好了（微软称其为 Async All the Way）。</li><li>如果可能，尽量在异步任务后添加 <code>.ConfigureAwait(false)</code>；这样，异步任务后面继续执行的代码就不会回到原 UI 线程了，而是直接从线程池中再取出一个线程执行；这样，即便 UI 线程后续可能有别的原因造成阻塞，也不会产生死锁了。</li></ol></blockquote><p>第一段代码,基于.net core 3.1 windows窗口程序</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         Start();</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">     &#123;</span><br><span class="line">         Console.WriteLine(Thread.CurrentThread.ManagedThreadId);<span class="comment">//1</span></span><br><span class="line">         Test();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Test</span>()</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">await</span> Task.Delay(TimeSpan.FromSeconds(<span class="number">1f</span>));</span><br><span class="line">         Console.WriteLine(Thread.CurrentThread.ManagedThreadId);<span class="comment">//可能1,2,3,4</span></span><br><span class="line">        </span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>第二段,Untiy中编写的</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">      Debug.Log(Thread.CurrentThread.ManagedThreadId);<span class="comment">//1</span></span><br><span class="line">      Test();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Test</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">await</span> Task.Delay(TimeSpan.FromSeconds(<span class="number">1f</span>));</span><br><span class="line">      Debug.Log(Thread.CurrentThread.ManagedThreadId);<span class="comment">//1 和上面一样</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>为什么会有这两种情况</p><p>是因为Unity在框架中实现了一个<code>UnitySynchronizationContext</code>的类,该类继承<code>SynchronizationContext</code></p><p><code>ConfigureAwait</code> </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;id1:&quot;</span> + Thread.CurrentThread.ManagedThreadId); <span class="comment">//1</span></span><br><span class="line">        <span class="keyword">await</span> Test();</span><br><span class="line">        Debug.Log(<span class="string">&quot;id3:&quot;</span> + Thread.CurrentThread.ManagedThreadId);<span class="comment">//1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> Task.Run(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;id2:&quot;</span> + Thread.CurrentThread.ManagedThreadId); <span class="comment">//其他 线程</span></span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                sb.Append(<span class="string">&quot;xxxxxxxxxxxxx&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            File.WriteAllText(<span class="string">@&quot;C:\Users\Administrator\Desktop\1.txt&quot;</span>, sb.ToString());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;id1:&quot;</span> + Thread.CurrentThread.ManagedThreadId); <span class="comment">//1</span></span><br><span class="line">        <span class="keyword">await</span> Test().ConfigureAwait(<span class="literal">false</span>);</span><br><span class="line">        Debug.Log(<span class="string">&quot;id3:&quot;</span> + Thread.CurrentThread.ManagedThreadId);<span class="comment">//其他 线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> Task.Run(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;id2:&quot;</span> + Thread.CurrentThread.ManagedThreadId); <span class="comment">//其他 线程</span></span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                sb.Append(<span class="string">&quot;xxxxxxxxxxxxx&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            File.WriteAllText(<span class="string">@&quot;C:\Users\Administrator\Desktop\1.txt&quot;</span>, sb.ToString());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>await 后面需要接的类型是 <code>TaskAwaiter(INotifyCompletion)</code> 可等待对象,也就是说要实现<code>await</code>后面必须要返回一个可等待对象实例</p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33064771/article/details/115834815"> Unity 中的 async-await 咋用_东北砍王的栖息地-CSDN博客</a></p><p><code>什么是TaskCompletionSource</code></p><p>TaskCompletionSource是一个可以用来创建Task并且手动进行管理的类,我们可以手动设置结束(setResult()),或者取消(SetCancel()),或者设置异常,是一个包装类.</p><p>TaskCompletionSource<T>这是一种受你控制创建Task的方式。你可以使Task在任何你想要的时候完成，你也可以在任何地方给它一个异常让它失败。</p><p>他并不是真的启动了一个新的线程,这要看开发者是怎么处理的</p><p><code>什么是synchronizationContext</code></p><p>同步上下文,利用此对象可以实现线程间数据的同步、异步访问。包含一个<code>Send</code> 和一个<code>Post</code></p><p><code>send</code>是一个同步方法 实际就是调用了 回调</p><p><code>Post</code>是一个异步,会从其他线程中去调用,然后返回到当前线程中</p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity Live2D</title>
      <link href="/2021/09-18-2021-9-18-Unity-Live2D/"/>
      <url>/2021/09-18-2021-9-18-Unity-Live2D/</url>
      
        <content type="html"><![CDATA[<h2 id="Live2D"><a href="#Live2D" class="headerlink" title="Live2D"></a>Live2D</h2><ul><li>官网地址:<a target="_blank" rel="noopener" href="https://www.live2d.com/zh-CHS/">Live2D Cubism【官网】</a></li><li>文件类型说明<br><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202204291834215.png" alt="image-20210830110456795"></li></ul><h3 id="1-关于Original-Workflow"><a href="#1-关于Original-Workflow" class="headerlink" title="1.关于Original Workflow"></a>1.关于Original Workflow</h3><p>Live2D导入流程 自动为文件创建Prefab,添加对应脚本,一般设置为第一个选项</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202204291835786.png" alt="image-20210830103028866"></p><h3 id="2-文件导入"><a href="#2-文件导入" class="headerlink" title="2. 文件导入"></a>2. 文件导入</h3><p>直接将导出的文件拖入拖入unity,就会生成prefab,然后拖到场景中.可能遇到的问题:</p><ul><li><p>拖入场景中不显示,随意改变一下参数即可</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202204291835940.png" alt="image-20210830103619143"></p></li><li><p>模型渲染顺序错误,修改渲染方式</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202204291835844.png" alt="image-20210830103903775"></p></li><li><p>文件导入后,提示<code>Parameters</code>错误,选择文件夹,重新<code>Reimport</code></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202204291835416.png" alt="image-20210830104224872"></p></li></ul><h3 id="3-基础的操作"><a href="#3-基础的操作" class="headerlink" title="3. 基础的操作"></a>3. 基础的操作</h3><p><a target="_blank" rel="noopener" href="https://docs.live2d.com/zh-CHS/cubism-sdk-tutorials/getting-started/">载入SDK | SDK 教程 | Live2D Manuals &amp; Tutorials</a></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/kysaloyer/article/details/112571269">Unity Live2D CubismSdk4进阶文档_kysaloyer的博客-CSDN博客</a></p><ul><li>点击部位检测</li></ul><p>​<a target="_blank" rel="noopener" href="https://docs.live2d.com/zh-CHS/cubism-sdk-tutorials/hittest/">重叠检测设置 | SDK 教程 | Live2D Manuals &amp; Tutorials</a></p><ul><li>自动眨眼设置</li></ul><p>​<a target="_blank" rel="noopener" href="https://docs.live2d.com/zh-CHS/cubism-sdk-tutorials/eyeblink/">自动眨眼设置 | SDK 教程 | Live2D Manuals &amp; Tutorials</a></p><ul><li>眼自动跟踪设置Cubism Look Controller,查看代码可以自定义,target.Getposition</li></ul><p>​<a target="_blank" rel="noopener" href="https://docs.live2d.com/zh-CHS/cubism-sdk-tutorials/lookat/">视线跟踪设置 | SDK 教程 | Live2D Manuals &amp; Tutorials</a></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202204291835480.png" alt="image-20210830104854240"></p><ul><li>唇形同步,<code>CubismmouthController</code> BlendMode必须设置为<code>Override</code></li></ul><p>​<a target="_blank" rel="noopener" href="https://docs.live2d.com/zh-CHS/cubism-sdk-tutorials/lipsync/">口形同步设置 | SDK 教程 | Live2D Manuals &amp; Tutorials</a></p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202204291835647.png" alt="image-20210830105045712"></p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Live2D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Coroutine In Unity</title>
      <link href="/2020/06-08-2020-6-08-Coroutine-In-Unity/"/>
      <url>/2020/06-08-2020-6-08-Coroutine-In-Unity/</url>
      
        <content type="html"><![CDATA[<p>看了很多关于Unity 协程的文章,自己来总结一下.</p><h1 id="Unity-中的什么周期"><a href="#Unity-中的什么周期" class="headerlink" title="Unity 中的什么周期"></a>Unity 中的什么周期</h1><p>链接:<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/ExecutionOrder.html">https://docs.unity3d.com/Manual/ExecutionOrder.html</a></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162207905.svg"></p><p>上图其实可以看到,<code>yield waitforEndOfFrame</code>是在帧结束的时候,<code>WaitForFixedUpdate</code>是在所有物理更新结束之后,其他的都在<strong>update</strong>之后,<strong>LateUpdate</strong>之前更新.</p><h1 id="Unity协程的本质"><a href="#Unity协程的本质" class="headerlink" title="Unity协程的本质"></a>Unity协程的本质</h1><p>Unity中协程并不是线程,只是Unity中的另一条逻辑,规定了相应的时间段然后响应某些事件.协程内部其实是一个<code>迭代器</code>. 如上面的生命周期,<strong>每一帧</strong>都会检测协程是否满足迭代器中<code>MoveNext</code>的条件,当满足的时候 就回去执行下一个条件,当没后面没有 那么就协程结束.例如下面的代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> IEnumerator <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;Coroutine...&quot;</span>); </span><br><span class="line">             <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;  <span class="comment">//我这yield return 放到后面</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Update...&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>打印结果</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162207906.JPG"></p><p>可以看到一开始是协程优先,然后是update,可是后面总是update更新后才执行协程.</p><p>不管我们使用<code>WaitForSeconds</code> <code>WaitForSecondsRealtime</code>或者其他都是在每一帧中进行检查,如果满足迭代器中的<code>MoveNext()</code>就会向下执行.</p><p>我们再看看<code>WaitForSeconds</code> (其他也类似)其实这个类只是记住了一个时间点,通过ILSpy,我们可以看到其代码实现很简单</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162207907.JPG"></p><p>内部维护了一个时间节点,用于在每一帧检测当前时间点与开始的时间点是否是规定的时间差,那么在执行MoveNext</p><p>引用一下别人的话</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162207908.jpg"></p><p>提示下:YieldInstruction是一个类 不是一个接口</p><blockquote><p>协程必须使用<code>StartCoroutine</code>,来启动,通过这个函数,创建了<code>Coroutine</code>对，该对象保存了<code>yield return</code>展开后的IEnumerator对象指针、<code>MoveNext</code>和<code>Current</code>的函数指针、结束后应当唤醒的协程的指针、指向调用者<code>Monobehaviour</code>的指针等等，并将该对象<code>coroutine</code>保存到该<code>Monobehaviour</code>的活跃协程列表中。然后立即调用了<code>coroutine.Run()</code>。<code>coroutine.Run()</code>首先尝试调用<code>InvokeMoveNext</code>，若发现当前协程执行完成，则会尝试调用应当唤醒的协程，否则才真正执行<code>MoveNext</code>，获得返回值<code>monoWait</code>。</p><hr><p>根据返回值<code>monoWait</code>的类型，进行不同的处理。通常是传递不同的参数给<code>CallDelayed</code>函数。对于返回值是<code>Coroutine</code>类型（c#那边用了协程嵌套），会将这个返回值的结束后应唤醒的协程的指针指向当前的<code>coroutine</code>。笔者这里发现了一种不太常见的用法：当返回值为<code>IEnumerator</code>类型（c#那边没有用StartCoroutine去开启嵌套协程，而是直接在yield return 后调用）时，Unity会自动为其创建一个<code>Coroutine</code>对象并初始化，效果同样。</p><hr><p><code>CallDelayed</code>函数传入了运行协程对象的方法、qingli协程对象的方法、清理条件等。函数内部创建了一个<code>Callback</code>对象，加到了全局的<code>DelayedCallManager</code>的列表中。游戏主循环会在每一帧调用<code>DelayedCallManager.Update</code>，在满足一定条件时（比如对应的Monobehaviour对象还没被销毁等）调用<code>Callback</code>对象的方法。</p></blockquote><p>所以,事情其实也就变的简单了,通过StartCoroutine来启动一个协程,提交到Unity内部更新机制中,每一帧来检测是否满足设定的条件,执行迭代器中的MoveNext</p><blockquote><p>When you make a call to <code>StartCoroutine(IEnumerator)</code> you are handing the resulting IEnumerator to the underlying unity engine.</p><p><code>StartCoroutine()</code> builds a <code>Coroutine</code> object, runs the first step of the IEnumerator and gets the first yielded value. That will be one of a few things, either “break”, some <code>YieldInstruction</code> like <code>&quot;Coroutine&quot;, &quot;WaitForSeconds&quot;, &quot;WaitForEndOfFrame&quot;, &quot;WWW&quot;</code>, or something else unity doesn’t know about. The Coroutine is stored somewhere for the engine to look at later.</p><p>… At various points in the frame, Unity goes through the stored Coroutines and checks the Current value in their IEnumerators.</p><hr><p><strong>WWW</strong><br>- after Updates happen for all game objects; check the isDone flag. If true, call the IEnumerator’s MoveNext() function;</p><p><strong>WaitForSeconds</strong><br>- after Updates happen for all game objects; check if the time has elapsed, if it has, call MoveNext();</p><p><strong>null or some unknown value</strong><br>- after Updates happen for all game objects; Call MoveNext()</p><p><strong>WaitForEndOfFrame</strong><br>- after Render happens for all cameras; Call MoveNext</p><p>MoveNext returns false if the last thing yielded was “break” of the end of the function that returned the IEnumerator was reach. If this is the case, unity removes the IEnumerator from the coroutines list.</p></blockquote><h1 id="协程中的优化"><a href="#协程中的优化" class="headerlink" title="协程中的优化"></a>协程中的优化</h1><p>协程其实不会很占用资源 GC,只是平时要注意写法,如果是如下的写法 那么就很坑了</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> IEnumerator <span class="title">Start</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          Debug.Log(<span class="string">&quot;Coroutine...&quot;</span>);</span><br><span class="line">          <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">0.5f</span></span>)</span>;</span><br><span class="line">         </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上面 我每次都是要去new 一个waitforSecond,那么就会慢慢产生很多的GC</p><p>看下这几个文章</p><ol><li><p>C# 协程 WaitForSeconds产生GC（Garbage Collection）问题 <a target="_blank" rel="noopener" href="https://blog.csdn.net/u010019717/article/details/44948903">https://blog.csdn.net/u010019717/article/details/44948903</a></p></li><li><p>关于Unity Corotine协程的优化 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34106090/article/details/88834260">https://blog.csdn.net/qq_34106090/article/details/88834260</a></p></li><li><p>[Unity 协程运行时的监控和优化] <a target="_blank" rel="noopener" href="https://blog.uwa4d.com/archives/USparkle_Coroutine.html">https://blog.uwa4d.com/archives/USparkle_Coroutine.html</a></p></li></ol><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li>Unity核心原理（1）生命周期 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/55287195">https://zhuanlan.zhihu.com/p/55287195</a></li><li>Coroutine，你究竟干了什么    <a target="_blank" rel="noopener" href="https://blog.csdn.net/tkokof1/article/details/11842673">https://blog.csdn.net/tkokof1/article/details/11842673</a></li><li>C#迭代器——由foreach说开去 <a target="_blank" rel="noopener" href="https://blog.csdn.net/u013477973/article/details/65635737">https://blog.csdn.net/u013477973/article/details/65635737</a></li><li>C#基础知识—迭代器与Foreach语句 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/3xiaolonglong/p/9608281.html">https://www.cnblogs.com/3xiaolonglong/p/9608281.html</a></li><li>Unity中关于Coroutine与Async的使用问题   <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/86779d2ebeaa">https://www.jianshu.com/p/86779d2ebeaa</a></li><li>Unity 协程原理逆向解析 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/115172019">https://zhuanlan.zhihu.com/p/115172019</a></li><li>浅析unity&#x2F;xlua中的协程实现 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/47573713">https://zhuanlan.zhihu.com/p/47573713</a></li><li>深入剖析Unity协程 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/82798132">https://zhuanlan.zhihu.com/p/82798132</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Font In Unity</title>
      <link href="/2020/05-08-2020-5-08-Font-In-Unity/"/>
      <url>/2020/05-08-2020-5-08-Font-In-Unity/</url>
      
        <content type="html"><![CDATA[<p>使用unity的时候经常会用到较多的字体,本篇文章讲一下unity如何自定义字体以及在使用字体时的优化</p><h2 id="如何使用Unity自定义字体"><a href="#如何使用Unity自定义字体" class="headerlink" title="如何使用Unity自定义字体"></a>如何使用Unity自定义字体</h2><p>​unity其实一直就有一个custom font功能,网上也能找到很多博客</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162206744.jpg"></p><p>然后设置相关参数</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162206745.jpg"></p><p>具体可以看看unity的官方文档和另一个文章</p><p><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/class-Font.html">https://docs.unity3d.com/Manual/class-Font.html</a></p><p><a target="_blank" rel="noopener" href="http://www.manew.com/thread-110484-1-1.html">http://www.manew.com/thread-110484-1-1.html</a></p><p>例如我们在制作数字(0-9)字体的时候就需要 一张数字图片,然后设置<code>Character Rects</code>,文档中说的很清楚,<code>Index</code>就是指的当前字的 ASCII码的索引(十进制),例如0&#x3D;48    1&#x3D;49…..</p><p>如果我们想设置更多的文字,也是可以的,因为Unity支持Unicode,但是我们需要一些步骤,<code>将文字-&gt;16进制-&gt;十进制</code></p><p>这里有个在线的转换工具:<a target="_blank" rel="noopener" href="http://www.ab126.com/goju/1711.html">http://www.ab126.com/goju/1711.html</a></p><p>关于编码可以查看这篇文章:<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html</a></p><p>代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> content = <span class="string">&quot;你好&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; content.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> bytes = Encoding.Unicode.GetBytes(content[i].ToString());</span><br><span class="line">        <span class="keyword">var</span> stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; bytes.Length; j += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//x2是十六进制 两位如果没有用 0补充</span></span><br><span class="line">            stringBuilder.AppendFormat(<span class="string">&quot;&#123;0:x2&#125;&#123;1:x2&#125;&quot;</span>, bytes[j + <span class="number">1</span>], bytes[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        Debug.Log(stringBuilder.ToString());</span><br><span class="line">        <span class="comment">//你-&gt;4f60</span></span><br><span class="line">        <span class="comment">//好-&gt;597d</span></span><br><span class="line">        <span class="built_in">int</span> index = Convert.ToInt32(stringBuilder.ToString(), <span class="number">16</span>);</span><br><span class="line">        Debug.Log(index);</span><br><span class="line">        <span class="comment">//你-&gt;20320</span></span><br><span class="line">        <span class="comment">//好-&gt;22909</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后我们把字体的”你”的Index设置成20320即可</p><p>这里我做了一个工具:<a target="_blank" rel="noopener" href="https://github.com/ZeroUltra/Custom-Font">https://github.com/ZeroUltra/Custom-Font</a></p><h2 id="Unity中的字体优化"><a href="#Unity中的字体优化" class="headerlink" title="Unity中的字体优化"></a>Unity中的字体优化</h2><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162206746.png"></p><p>字体都包含一个材质一个贴图  我们使用的大多都是动态字体( 动态字体，如果所输入的文字在字体中找不到相应的编码，就会自动从系统默认字体中找到该字体),有个很大的问题就是,动态字体会自己调节贴图大小来更换图集,在程序运行过程中,动态赋值text文本字体,贴图没有文字默认是64*64大小,但是当文字越来越多的时候就会把贴图撑大。<br><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162206747.png"></p><p> 我在text中输入了很多文字之后<br><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162206748.png"></p><p>另外,如果文字的<code>Font Style</code> 不同 在材质贴图中也会多加一份<br><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162206749.png"><br><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162206750.png"></p><p>也会根据<code>字体大小</code> 多追加一份<br><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162206751.png"></p><p>所以综上:我们可以拟定两个方案：</p><ol><li>如果已经知道图集包含的特定字,通过裁剪文字将文字内容固定,裁剪文字将会降低内存大小  裁剪文字有很多种方法,比如 <code>BMFont</code>自己制作 <code>FontSubsetGUI</code>裁剪文字 另外Unity 也有自带的字体裁剪,这里说明一下</li></ol><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162206752.png"></p><p>导入字体库选择Custom Set,然后</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162206753.png"></p><p>我只让改字体库包含 “你好”两个字,那么在Text 文本上 将不会显示其他的文字</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162206754.png"></p><p>也会降低内存<br><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162206755.png"><br><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162206756.png"></p><p>如果想要的文字一个个输入有些麻烦 这里有个帮助类.可以快速添加需要的文字</p><p>  <a target="_blank" rel="noopener" href="http://1vr.cn/?p=607&cpage=1#comment-89612">http://1vr.cn/?p=607&amp;cpage=1#comment-89612</a>        </p><p>  <a href="/2020/05-08-Unity%E4%B8%AD%E7%9A%84%E5%AD%97%E4%BD%93/UnicodeTextImporter.cs">脚本</a></p><h2 id="字体的一些tips"><a href="#字体的一些tips" class="headerlink" title="字体的一些tips"></a>字体的一些tips</h2><ul><li>推荐使用TextMeshPro!!!</li><li>使用UGUI Text RichText会让面数倍增   </li><li>尽量不要使用UI Shadow和Outline</li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Asset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Font </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Texture In Unity</title>
      <link href="/2020/04-21-2020-4-21-Texture-In-Unity/"/>
      <url>/2020/04-21-2020-4-21-Texture-In-Unity/</url>
      
        <content type="html"><![CDATA[<p>这篇文章主要讲一下Unity中的贴图数据操作和内存计算方式以及相关优化</p><h1 id="Unity中Texture中各种关系以及Apply-方法"><a href="#Unity中Texture中各种关系以及Apply-方法" class="headerlink" title="Unity中Texture中各种关系以及Apply()方法"></a>Unity中Texture中各种关系以及Apply()方法</h1><p>先抛出一个我无意间浏览到的一个博主写的关于<code>Texture</code> <code>Texture2D</code>  <code>RendererTexture</code> 之间的关系.</p><p>链接:<a target="_blank" rel="noopener" href="http://fargesportfolio.com/unity-texture-texture2d-rendertexture/">http://fargesportfolio.com/unity-texture-texture2d-rendertexture/</a></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162206492.PNG"></p><p>这里说一下 <code>Texture2D</code>的<code>Apply</code>操作,当我们使用<code>SetPixel``SetPixels</code> <code>ReadPixels</code>定要调用Apply方法,不然显示的还是原来的图,这里有个链接具体看下:<a target="_blank" rel="noopener" href="https://blog.csdn.net/carefreeq/article/details/52635524">https://blog.csdn.net/carefreeq/article/details/52635524</a></p><blockquote><p><strong>赋值完后为什么要Apply</strong></p><p>因为在贴图更改像素时并不是直接对显存进行更改，而是在另外一个内存空间中更改，这时候GPU还会实时读取旧的贴图位置。</p><p>当Apply后，CPU会告诉GPU你要换个地方读贴图了</p></blockquote><p>所以图片存在内存中,CPU指向这个图片地址,GPU根据CPU拿过来的地址来显示,如果更改了图片数据,没用调用Apply. 那么GPU没用接收到CPU发来的指令就不会更改这个图的显示.下面的代码,当我没调用Apply的操作时,显示的还是原图,当我调用之后显示的就是纯红色了</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">BtnClick</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Texture2D tex = <span class="keyword">new</span> Texture2D(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    tex.LoadImage(File.ReadAllBytes(desktopPath + <span class="string">&quot;/111.jpg&quot;</span>));</span><br><span class="line">    Color[] colors = tex.GetPixels();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; colors.Length; i++)</span><br><span class="line">        colors[i] = Color.red;</span><br><span class="line"></span><br><span class="line">    tex.SetPixels(colors);</span><br><span class="line">    <span class="comment">//tex.Apply();  这里更改</span></span><br><span class="line">    rawImg.texture = tex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Apply是一个很昂贵的操作,所以官方建议我们在使用这个方法之前,尽可能把数据操作完毕!</p><h1 id="Unity中Texture内存计算方式"><a href="#Unity中Texture内存计算方式" class="headerlink" title="Unity中Texture内存计算方式"></a>Unity中Texture内存计算方式</h1><p>任何贴图(Unity可识别的格式)导入到Unity中都有Unity自己的图片计算方法.而且可能一张100K大小的图片导入Unity就是好几M,同样一张图png和jpg两个格式假如一个100k一个50k,但是导入Unity中都是2M.那么Unity的计算格式是怎么样的呢?</p><p>我做了一个1024*1024的图片导入到Unity中,不勾选<code>Generate Min Maps</code>,然后设置格式RGBA32那么此时的格式大小</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162206494.PNG"></p><p>这里可以看到图片大小是4M,其计算方法–&gt;这里格式设置的是<code>RGBA32 bit</code>,这个格式意思就是<strong>每一个像素用了32个bit去填充</strong>,而我们都知道一个byte等于8个bit,所以这里每个像素都占用了4个byte,而1m&#x3D;1024kb,所以:</p><blockquote><p>总的像素大小&#x3D;1024x1024(宽度x高度)</p><p>那么总大小&#x3D;总像素x每个像素大小&#x3D;1024x1024x4&#x3D;4M</p></blockquote><p>如果我们将图片换成RGB24,那么大小应该是;</p><blockquote><p>​1024x1024x3&#x3D;3M</p></blockquote><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162206495.JPG"></p><p>所以在Unity中图片的内存大小是根据其格式定义的,具体要看每个像素占用的字节大小.</p><h1 id="Texture2D中的RawData"><a href="#Texture2D中的RawData" class="headerlink" title="Texture2D中的RawData"></a>Texture2D中的RawData</h1><p>Unity中有<code>tex.LoadRawTextureData()</code>和<code>tex.GetRawTextureData()</code>两个方法,Get是获取图片的原始数据Load是从原始数据中加载.</p><p>这在我项目中要频繁加载外部纹理(用完就处理掉)需要更快的加载纹理,这个方法加载速度要比IO读取和UnityWebRequest快很多</p><p>要获取图片的RawData,就必须导入让Unity识别一遍,所以在开始就可以对纹理进行处理,先用IO读取获取到Texture2D(这里new Texture2D可以不用设置宽高)</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Texture2D tex = <span class="keyword">new</span> Texture2D(<span class="number">0</span>, <span class="number">0</span>,TextureFormat.RBGA32,<span class="literal">false</span>);</span><br><span class="line">tex.LoadImage(File.ReadAllBytes(<span class="string">&quot;xxxx/1.png&quot;</span>));</span><br></pre></td></tr></table></figure><p>这个时候我们已经得到了一个Unity Texture2D,接着我们使用代码获取RawData,然后保存</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">byte</span>[] bs = tex.GetRawTextureData();</span><br><span class="line">File.WriteAllBytes(<span class="string">&quot;xxxx/1.png.bytes&quot;</span>, bs);</span><br></pre></td></tr></table></figure><p>保存这个二进制文件之后,可以发现文件大小就是此图片在Unity看到的大小(在这用上面的图格式是RGBA32,那么这个二进制文件就是4M)</p><p>这里需要注意一点的是,当我们使用<code>LoadRawTextureData</code>的时候,<strong>必须要指定原始图片的Width,Height和TextureFormat(minchan可以不管)</strong>,如下</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Texture2D tex2 = <span class="keyword">new</span> Texture2D(<span class="number">1920</span>, <span class="number">1080</span>, TextureFormat.RBGA32, <span class="literal">false</span>);</span><br><span class="line">tex.LoadRawTextureData(File.ReadAllBytes(<span class="string">&quot;xxxx/1.png.bytes&quot;</span>));</span><br></pre></td></tr></table></figure><p>所以你在保存RawData的时候,应该<strong>记录一下图片的一些属性</strong>,可以把数据写到文件名,然后用字符串操作得到相应数据,我这里使用了二进制保存.</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">WriteTexture2DToRawData</span>(<span class="params">Texture2D texture, <span class="built_in">string</span> filePath</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">byte</span>[] bs = texture.GetRawTextureData();</span><br><span class="line">        <span class="keyword">using</span> (BinaryWriter bw = <span class="keyword">new</span> BinaryWriter(File.OpenWrite(filePath)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提前把前三个写入</span></span><br><span class="line">            bw.Write(texture.width);</span><br><span class="line">            bw.Write(texture.height);</span><br><span class="line">            bw.Write((<span class="built_in">int</span>)texture.format);</span><br><span class="line">            <span class="comment">//bw.Write(texture.streamingMipmaps);</span></span><br><span class="line">            <span class="comment">//------</span></span><br><span class="line">            bw.Write(bs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后在读取的时候</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Texture2D <span class="title">LoadTexture2DFromRawData</span>(<span class="params"><span class="built_in">string</span> rawdataPath</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">using</span> (BinaryReader br = <span class="keyword">new</span> BinaryReader(File.OpenRead(rawdataPath)))</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">//先读取前三个宽 高 格式</span></span><br><span class="line">         <span class="built_in">int</span> w = br.ReadInt32();</span><br><span class="line">         <span class="built_in">int</span> h = br.ReadInt32();</span><br><span class="line">         <span class="built_in">int</span> format = br.ReadInt32();</span><br><span class="line"></span><br><span class="line">         <span class="comment">//在读取剩下的texture raw data</span></span><br><span class="line">         <span class="comment">//此时的br.BaseStream.Position=12</span></span><br><span class="line">         <span class="built_in">byte</span>[] bs = br.ReadBytes((<span class="built_in">int</span>)(br.BaseStream.Length - br.BaseStream.Position));</span><br><span class="line">         TextureFormat textureFormat = (TextureFormat)format;</span><br><span class="line">         Texture2D texture = <span class="keyword">new</span> Texture2D(w, h, textureFormat, <span class="literal">false</span>);</span><br><span class="line">         texture.LoadRawTextureData(bs);</span><br><span class="line">         texture.Apply();</span><br><span class="line">         <span class="keyword">return</span> texture;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>OK</p><h2 id="2020年5月15日22点11分更新补充"><a href="#2020年5月15日22点11分更新补充" class="headerlink" title="2020年5月15日22点11分更新补充"></a>2020年5月15日22点11分更新补充</h2><p><strong>问题:当把图片写入成二进制文件的时候实在是太大了</strong></p><p><strong>解决方案:把byte压缩</strong></p><p>查了资料,C# 中已经有了相关类(We are so lucky 😍)</p><p>压缩类:<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.compression.gzipstream?view=netcore-3.1">https://docs.microsoft.com/zh-cn/dotnet/api/system.io.compression.gzipstream?view=netcore-3.1</a></p><p>开源地址:<a target="_blank" rel="noopener" href="https://github.com/microsoft/referencesource/tree/master/System/sys/system/IO/compression">https://github.com/microsoft/referencesource/tree/master/System/sys/system/IO/compression</a></p><p>压缩有<code>Gzip</code>压缩(压缩快,但是稍大)和<code>Brotli</code>(压缩慢些,但是压缩后文件小)</p><p>新建一个Byte[]压缩类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">using System.IO;</span><br><span class="line">using System.IO.Compression;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 压缩和解压缩 本类使用的是Gzip压缩</span><br><span class="line">/// https://docs.microsoft.com/zh-cn/dotnet/api/system.io.compression.gzipstream.-ctor?view=netcore-3.1</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">public class CompressDecompressUtil</span><br><span class="line">&#123;</span><br><span class="line">    #region 压缩字节</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 压缩byte[](采用的GZip压缩 还有种是Brotli压缩)</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;rawBytes&quot;&gt;原始byte[]数据&lt;/param&gt;</span><br><span class="line">    /// &lt;returns&gt;压缩后的bytes[]&lt;/returns&gt;</span><br><span class="line">    public static byte[] CompressBytes(byte[] rawBytes)</span><br><span class="line">    &#123;</span><br><span class="line">        //声明一个MemoryStream流用来存放压缩后的byte[]</span><br><span class="line">        using (MemoryStream compressStream = new MemoryStream())</span><br><span class="line">        &#123;</span><br><span class="line">            //创建一个GZipStream 用来压缩</span><br><span class="line">            using (var conpressionGzipStream = new GZipStream(compressStream, CompressionMode.Compress))</span><br><span class="line">            &#123;</span><br><span class="line">                conpressionGzipStream.Write(rawBytes, 0, rawBytes.Length);</span><br><span class="line">                //或者</span><br><span class="line">                // gzipStream.CopyTo(compressStream);</span><br><span class="line">            &#125;</span><br><span class="line">            return compressStream.ToArray();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 解压缩字节</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;compressBytes&quot;&gt;经过Gzip压缩后的byte[]&lt;/param&gt;</span><br><span class="line">    /// &lt;returns&gt;返回原始的byte[]&lt;/returns&gt;</span><br><span class="line">    public static byte[] DecompressFormBytes(byte[] compressBytes)</span><br><span class="line">    &#123;</span><br><span class="line">        //声明一个compressStream表示原来的压缩流</span><br><span class="line">        using (var compressStream = new MemoryStream(compressBytes))</span><br><span class="line">        &#123;</span><br><span class="line">            //从原来的压缩流 解压出 原始数据</span><br><span class="line">            using (GZipStream decompressiongzipStream = new GZipStream(compressStream, CompressionMode.Decompress))</span><br><span class="line">            &#123;</span><br><span class="line">                using (var resultStream = new MemoryStream())</span><br><span class="line">                &#123;</span><br><span class="line">                    //用read比较麻烦</span><br><span class="line">                    decompressiongzipStream.CopyTo(resultStream);</span><br><span class="line">                    return resultStream.ToArray();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    #endregion</span><br><span class="line"></span><br><span class="line">    //todo</span><br><span class="line"></span><br><span class="line">    #region 压缩文件</span><br><span class="line"></span><br><span class="line">    #endregion</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后上面的读取 和写入方法稍微修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">   /// 从二进制文件中加载图片</span><br><span class="line">   /// 如果使用了Gzip压缩,文件后缀必须有&quot;.gz&quot;</span><br><span class="line">   /// 配合WriteTexture2DToRawData方法来使用</span><br><span class="line">   /// &lt;/summary&gt;</span><br><span class="line">   /// &lt;param name=&quot;rawdataPath&quot;&gt;图片rawdate路径&lt;/param&gt;</span><br><span class="line">   /// &lt;param name=&quot;useGzipDecompress&quot;&gt;是否使用gzip解压缩,如果使用了gzip压缩的话&lt;/param&gt;</span><br><span class="line">   /// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">   public static Texture2D LoadTexture2DFromRawData(string rawdataPath, bool useGzipDecompress)</span><br><span class="line">   &#123;</span><br><span class="line">       using (BinaryReader br = new BinaryReader(File.OpenRead(rawdataPath)))</span><br><span class="line">       &#123;</span><br><span class="line">           //先读取前三个宽 高 格式</span><br><span class="line">           int w = br.ReadInt32();</span><br><span class="line">           int h = br.ReadInt32();</span><br><span class="line">           int format = br.ReadInt32();</span><br><span class="line"></span><br><span class="line">           //在读取剩下的texture raw data</span><br><span class="line">           //此时的br.BaseStream.Position=12</span><br><span class="line">           byte[] bs = br.ReadBytes((int)(br.BaseStream.Length - br.BaseStream.Position));</span><br><span class="line">           //用&amp;&amp; 不用 &amp;</span><br><span class="line">           if (useGzipDecompress &amp;&amp; Path.GetExtension(rawdataPath) == &quot;.gz&quot;)</span><br><span class="line">           &#123;</span><br><span class="line">               bs = CompressDecompressUtil.DecompressFormBytes(bs);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           TextureFormat textureFormat = (TextureFormat)format;</span><br><span class="line">           Texture2D texture = new Texture2D(w, h, textureFormat, false);</span><br><span class="line">           texture.LoadRawTextureData(bs);</span><br><span class="line">           texture.Apply(false);</span><br><span class="line">           return texture;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   /// &lt;summary&gt;</span><br><span class="line">   /// 将图片保存到二进制文件,</span><br><span class="line">   /// &lt;/summary&gt;</span><br><span class="line">   /// &lt;param name=&quot;texture&quot;&gt;图片&lt;/param&gt;</span><br><span class="line">   /// &lt;param name=&quot;savePath&quot;&gt;保存路径(例如:xxx.png.bytes)&lt;/param&gt;</span><br><span class="line">   /// &lt;param name=&quot;useGzipCompress&quot;&gt;是否使用Gzip压缩&lt;/param&gt;</span><br><span class="line">   public static void WriteTexture2DToRawData(Texture2D texture, string savePath, bool useGzipCompress)</span><br><span class="line">   &#123;</span><br><span class="line">       byte[] bs = texture.GetRawTextureData();</span><br><span class="line">       if (useGzipCompress)</span><br><span class="line">       &#123;</span><br><span class="line">           bs = CompressDecompressUtil.CompressBytes(bs);</span><br><span class="line">           savePath += &quot;.gz&quot;; //加个后缀名</span><br><span class="line">       &#125;</span><br><span class="line">       using (BinaryWriter bw = new BinaryWriter(File.OpenWrite(savePath)))</span><br><span class="line">       &#123;</span><br><span class="line">           //前12个byte 用来保存图片的宽度 高度 和格式</span><br><span class="line">           //提前把前三个写入</span><br><span class="line">           bw.Write(texture.width);</span><br><span class="line">           bw.Write(texture.height);</span><br><span class="line">           bw.Write((int)texture.format);</span><br><span class="line">           //bw.Write(texture.streamingMipmaps);</span><br><span class="line">           //------</span><br><span class="line">           bw.Write(bs);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>食用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void Instance_OnKeyDown1()</span><br><span class="line">  &#123;</span><br><span class="line">      Texture2D tex2 = TextureUtility.LoadTexture2DFromIO(path + &quot;222.png&quot;);</span><br><span class="line">      TextureUtility.WriteTexture2DToRawData(tex2, path + &quot;222.png.bytes&quot;, true);</span><br><span class="line">      rawImage.texture = TextureUtility.LoadTexture2DFromRawData(path + &quot;222.png.bytes.gz&quot;,false);</span><br><span class="line">      Debug.Log(&quot;end&quot;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>我在画图中画了一个1024*1024纯红图片,如果没有压缩那么是4M,压缩后直接成5kb!!! 压缩算法 就不多解读了,具体可以查看源码。</p><h1 id="Texture-优化"><a href="#Texture-优化" class="headerlink" title="Texture 优化"></a>Texture 优化</h1><p>2020年11.16更新</p><p>移动端考虑图片压缩方式使用ASTC方式压缩了,在ios和android可以通用该压缩方式.</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162206496.jpg"></p><h2 id="ASTC-压缩"><a href="#ASTC-压缩" class="headerlink" title="ASTC 压缩"></a>ASTC 压缩</h2><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162206497.png"></p><p>后面是每个像素占据的bit,例如ASTC4*4 每个像素占据8bit&#x3D;1kb,对于1024x1024大小的图,在unity中压缩后大小就是1m</p><h3 id="适配机型"><a href="#适配机型" class="headerlink" title="适配机型"></a>适配机型</h3><ol><li><p><strong>IOS</strong></p><p>苹果从A8处理器开始支持 ASTC，iPhone6及iPad mini 4以上iOS设备支持，2014年的iPhone 5s及iPad mini 3以前的设备不支持。</p></li><li><p><strong>Android</strong></p><p>所有支持OpenGL ES 3.1和部分支持OpenGL ES 3.0的GPU</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162206498.jpg"></p></li></ol><p>就算部分机型不支持该压缩,也可以有fallback</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162206499.jpg"></p><h3 id="使用ASTC压缩比率选择"><a href="#使用ASTC压缩比率选择" class="headerlink" title="使用ASTC压缩比率选择"></a>使用ASTC压缩比率选择</h3><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162206500.jpg"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162206501.jpg"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162206502.jpg"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162206503.jpg"></p><p>​</p><p><strong>总结:</strong>  <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162206504.jpg"></p><ol><li>如果图片没有透明通道,再导入的时候应该设置不导入,不然会影响ASTC压缩</li><li>压缩还是要具体打包看图片质量</li></ol><h2 id="导入设置"><a href="#导入设置" class="headerlink" title="导入设置"></a>导入设置</h2><h3 id="正确设置没有透明通道图片的导入格式"><a href="#正确设置没有透明通道图片的导入格式" class="headerlink" title="正确设置没有透明通道图片的导入格式"></a>正确设置没有透明通道图片的导入格式</h3><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162206505.jpg"></p><h3 id="Alpha-Is-Transparency"><a href="#Alpha-Is-Transparency" class="headerlink" title="Alpha Is Transparency"></a>Alpha Is Transparency</h3><p>​解释为Alpha 是否是半透明, Unity只处理全透明,如果开启了此选项,就是有半透明效果,<code>如果图片没有透明通道可以关闭这个选项</code></p><p>​<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/340754532">聊聊 Unity 的 Alpha Is Transparency 有什么用 - 知乎 (zhihu.com)</a></p><h3 id="Texture中的过滤模式"><a href="#Texture中的过滤模式" class="headerlink" title="Texture中的过滤模式"></a>Texture中的过滤模式</h3><p><code>就是像素与像素之间过度</code></p><p>过滤模式会提供多种方案来使得纹理投影到物体表面的过程变得更为顺滑自然。一般来讲，Unity提供了三种模式：</p><p><code>Point（no filter）</code>——Point模式为不过滤的采样方式.<code>类似PS像素一块一块的</code>,的使用最近点采样的方法，当UV坐标没有刚好对应Texture上的一个采样点时，它会选择最近的一个采样点作为该坐标的采样值。当纹理没有拉伸变形时，这样速度是最快的，且效果理想。但如果拉伸变形了，会出现马赛克现象。</p><p><code>Bilinear</code>——双线性过滤模式。<code>两个像素点之间平衡,看起来更平滑</code>,简单来讲，它会对相邻的像素进行模糊化处理，使得像素之间的变化更为圆润平滑，不会有明显的锯齿感或者马赛克化。但这只涉及单个“平面”的操作，所以一旦涉及mipmap层级间的处理，双线性过滤就会有些“力不从心”，某些表现效果会大打折扣。</p><p><code>Trilinear</code>——三线性过滤模式。和Bilinear模式类似，但是额外优化了mipmap层级间的转换效果，它会在mip层级间进行模糊处理，弥补了Bilinear模式的不足。</p><p>这里我们延伸讲一下关于“mipmap”的概念。简单来讲为了更好地应对纹理贴图在不同距离和大小情况下的表现效果，以提升渲染的速度和降低图像锯齿化的影响，Unity会以纹理原尺寸为基础，预设几个等比例缩放的“复制品”，在实际使用中会根据情况加载对应的mipmap贴图，从而提升渲染性能，放大缩小的过程也因为mipmap层级的选择而更为快捷。</p><p>回到规则本身，Trilinear模式对表现效果的提升，是以GPU的额外开销为代价的。同等条件下，三线性过滤的GPU占用是最高的。所以如果对纹理的细致程度不那么敏感（比如像素类游戏），或者不涉及mipmapping的应用（比如2D游戏），那么就没有必要去选择Trilinear模式。</p><p>所以建议开发团队对本条规则检测下的纹理资源，依据项目实际需求进行相关的过滤模式的修改</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/158740249">ASTC纹理压缩格式详解</a></li><li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/269535734">纹理优化：不仅仅是一张图片那么简单</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Asset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Texture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UGUI自适应</title>
      <link href="/2020/02-13-2020-2-13-UGUI%E8%87%AA%E9%80%82%E5%BA%94/"/>
      <url>/2020/02-13-2020-2-13-UGUI%E8%87%AA%E9%80%82%E5%BA%94/</url>
      
        <content type="html"><![CDATA[<p>​这篇文章说一下Ugui的适配.</p><h1 id="Canvas-Scaler下面的三种适配模式"><a href="#Canvas-Scaler下面的三种适配模式" class="headerlink" title="Canvas Scaler下面的三种适配模式"></a>Canvas Scaler下面的三种适配模式</h1><p>​<img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162203489.png"></p><ul><li><code>Constant Pixel Size</code>就是固定像素模式 下面有个可以调节的scale factor 调节整个画布缩放</li><li><code>Scale with Screen Size</code>  随屏幕尺寸缩放,其实也就是缩放整个画布,本文重点介绍</li><li><code>Constant Physical Size</code> 恒定物理尺寸(暂不讨论)</li></ul><h2 id="Scale-With-Screen-Size-模式的UI适配"><a href="#Scale-With-Screen-Size-模式的UI适配" class="headerlink" title="Scale With Screen Size 模式的UI适配"></a>Scale With Screen Size 模式的UI适配</h2><p>当我们选择<code>Scale With Screen Size</code> 模式的时候,要求我们一个参考分辨率,下面缩放模式也有三种类型</p><p>​<img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162203490.png"></p><p>先介绍一下后面两种模式</p><h3 id="Expand模式与Shrink模式"><a href="#Expand模式与Shrink模式" class="headerlink" title="Expand模式与Shrink模式"></a>Expand模式与Shrink模式</h3><p>这两种模式是一个相反的模式,所以一起介绍</p><ul><li>Expand 模式就是扩大,也就是会向<code>长宽变化大</code>的为参考进行缩放</li><li>Shrink 缩小模式, 向<code>长宽变化小</code>的为参考进行缩放,</li></ul><p>有点绕口,我们结合实例来说</p><h4 id="Eg1"><a href="#Eg1" class="headerlink" title="Eg1:"></a>Eg1:</h4><p>​<img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162203491.png"></p><p>当我们选择参考分辨率为<code>800*600</code>   <code>Expand</code> 的时候</p><p>​<img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162203492.png"></p><p>可以看到画布缩放是xyz是1.25</p><p>当选择<code>Shrink</code>模式的时候</p><p>​<img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162203493.png"></p><p>可以看到变成了1.3333</p><p><strong>计算过程</strong></p><p>用参考分辨率与实际屏幕分辨率做对比</p><ol><li>计算长度变化:800(参考分辨率)&#x2F;1000(实际分辨率)&#x3D;0.8</li><li>计算宽度变化:600&#x2F;800&#x3D;0.75</li><li>对比变化比例 </li><li>当是<code>Expand</code> 模式取变化<code>较大</code>的,这里是<code>0.8</code>.然后用1&#x2F;0.8得到当前画布缩放大小1&#x2F;0.8&#x3D;1.25</li><li>当是<code>Shrink</code>模式取变化<code>较小</code>的,这里是<code>0.75</code>.然后用1&#x2F;0.75&#x3D;1.3333333</li></ol><h4 id="Eg2"><a href="#Eg2" class="headerlink" title="Eg2:"></a>Eg2:</h4><p>更改分辨率为<code>500*200</code>,</p><p>​<img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162203494.png"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162203495.png"></p><p><code>Expand</code>模式下是0.3333,<code>Shrink</code>模式下是0.625</p><p><strong>计算过程</strong></p><ol><li>计算长度变化:800(参考分辨率)&#x2F;500(实际分辨率)&#x3D;1.6</li><li>计算宽度变化:600&#x2F;200&#x3D;3</li><li>对比变化比例 </li><li>当是<code>Expand</code> 模式取变化<code>较大</code>的,这里是<code>1.6</code>.然后用1&#x2F;1.6&#x3D;0.625</li><li>当是<code>Shrink</code>模式取变化<code>较小</code>的,这里是<code>0.3</code>.然后用1&#x2F;3&#x3D;0.3333333</li></ol>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> UGUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> UGUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UGUI优化</title>
      <link href="/2020/02-04-2020-2-04-UGUI%E4%BC%98%E5%8C%96/"/>
      <url>/2020/02-04-2020-2-04-UGUI%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从Unity4.6版本加入UGUI以来,使用案例越多越多,相比NGUI,UGUI的效率要高的多</p><ul><li>Ugui的网格合并实在C++代码中执行的,Ngui是在C#中执行</li><li>Ugui网格合并是多线程,Ngui是在主线程</li><li>Ngui维护图片的Depth比较困难,而Ugui渲染顺序是依据Hierarchy中的顺序</li><li>重点是 Unity堆出众多的UI视图工具都是针对UGUI的,例如Frame Debugger,Profiler中的UI模块</li></ul><p>虽然不久之后应该会被其他的UI方案替代,但是现阶段最实用,最流行的UI方案还是Ugui.UI使用不当会造成各种问题,现在对Ugui进行下优化总结.</p><p>UGUI官方源码地址: <a target="_blank" rel="noopener" href="https://bitbucket.org/Unity-Technologies/ui/src/">https://bitbucket.org/Unity-Technologies/ui/src/</a></p><h1 id="针对Ugui优化的四个方向"><a href="#针对Ugui优化的四个方向" class="headerlink" title="针对Ugui优化的四个方向"></a>针对Ugui优化的四个方向</h1><ul><li>过多的GPU片段着色器使用率（如屏幕填充率过高）   </li><li>过多的CPU时间开销在重建一个画布上 (画布划分)</li><li>过多的画布网格重建次数   </li><li>过多的CPU时间开销在生成顶点上（通常是文本）</li></ul><h1 id="网格重建"><a href="#网格重建" class="headerlink" title="网格重建"></a>网格重建</h1><p>​UI中大多数的问题都是网格重建引起的</p><hr><p><strong>2020年4月19更新</strong></p><p>​放知乎一个看到了一个帖子：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/128546981">https://zhuanlan.zhihu.com/p/128546981</a></p><h2 id="什么是网格重建"><a href="#什么是网格重建" class="headerlink" title="什么是网格重建"></a>什么是网格重建</h2><p>​UGUI中以Canvas为单位,其下的UI原色会合成一个大Mesh,当我们改变UI元素(改变颜色,图片,大小等等)的时候都会引起网格Rebuild或ReBatch(UI重新批处理),每当有一个UI元素变化就会影响当前Canvas所有的UI元素引发网格重建.当UI过多的时候会造成重建时间过长 造成卡顿.</p><p>简而言之,就是Canvas会合成一个大的mesh,其地下的UI元素更改,会导致整个大mesh引发更改.</p><h2 id="哪些操作会引发网格重建"><a href="#哪些操作会引发网格重建" class="headerlink" title="哪些操作会引发网格重建?"></a>哪些操作会引发网格重建?</h2><ul><li>修改Image. rawImage中的贴图</li><li>更改RectTransform属性(会引发<code>OnRectTransformDimensionsChange</code>回调)  <strong>改变Position，Rotation，Scale不会调用</strong></li><li>UI的Enable&#x2F;DisEnable</li><li>Text的文字内容替换</li><li>更改UI顶点颜色(一般的color属性)</li></ul><p>附上一个可以查找引发网格重建元素的Script,可以查看那些执行了Rebuild,无法查看Rebatch(ReBatch在底层c++代码中) (来自雨松momo <a target="_blank" rel="noopener" href="http://www.xuanyusong.com/archives/4573?replytocom=633914">链接</a>)</p><p>参考:<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5a39cfa74232">UGUI笔记——UI Mesh Rebuild - 简书 (jianshu.com)</a></p><h2 id="关于网格重建的一些Tips"><a href="#关于网格重建的一些Tips" class="headerlink" title="关于网格重建的一些Tips"></a>关于网格重建的一些Tips</h2><p>​网格重建可能我们无法避免,但是我们可以通过一些操作来减少网格重建,网格重建包括ReBuild和ReBatch两部分,针对这两部分我们可以进行一些优化,值得一提的是Unity5.2以后批处理已经重写,运用到了多线程,这部分的消耗时间大大减少,具体可以参考这篇文章: <a target="_blank" rel="noopener" href="https://blog.csdn.net/cyf649669121/article/details/83142903">https://blog.csdn.net/cyf649669121/article/details/83142903</a> </p><p><strong>在UI源码中重建的标志就是设置了这个UI为<code>dirty</code>,例如<code>SetVerticesDirty</code> <code>SetLayoutDirty</code> <code>SetMaterialDirty</code> <code>SetAllDirty</code>等等</strong></p><ol><li><p>避免使用UI的<code>Active/DisActive</code>,因为基类Graphic 的在调用OnEable的时候 会执行 SetAllDirty 导致网格重建.</p><ul><li><p>对于整体Canvas的显隐：最好就是canvas的render mode是<code>Screen Space-Camera</code>,增加一个layer ,camera剔除这个layer渲染,控制显隐的时候就通过控制canvas的layer</p></li><li><p>对于整个个plane：可以添加<code>Canvas-Group</code>控制alpha来显隐</p></li><li><p>对于单个UI ：可以通过控制<code>scale=0</code>,或者在<code>Canvas</code>添加<code>Mask2DRect</code>,然后将单个UI移除Canvas之外.这两个操作应该都会Rebatch(因为引发了Positon和scale)，发现一个比较好的就是设置<code>CanvasRenderer</code>的alpha(设置CanvasRenderer的alpha&#x3D;0的时候同同时还要设置UI的raycast target&#x3D;fase,不然还会相应按钮点击)</p><p>另外知乎上一篇文章可以利用<code>CanvasRenderer</code>cull属性，即：<code>image.canvasRenderer.cull = true</code>   <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/30492759">https://zhuanlan.zhihu.com/p/30492759</a></p><p>再另外可以研究一下CanvasRenderer<code>EnableRectClipping</code>这个方法</p></li></ul></li></ol><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162159274.png"></p><ol start="2"><li><p>避免使用layout组件</p></li><li><p>修改UI元素可以修改材质TintColor</p><ul><li>修改的是Image组件上的Color属性，其原理是修改顶点色，因此是会引起网格的Rebuild的（即Canvas.BuildBatch操作，同时也会有Canvas.SendWillRenderCanvases的开销）。而通过修改顶点色来实现UI元素变色的好处在于，修改顶点色可以保证其材质不变，因此不会产生额外的Draw Call </li><li>在UI的默认Shader中存在一个Tint Color的变量，正常情况下，该值为常数(1,1,1)，且并不会被修改。如果是用脚本访问Image的Material，并修改其上的Tint Color属性时，对UI元素产生的网格信息并没有影响，因此就不会引起网格的Rebuild。但这样做因为修改了材质，所以会增加一个Draw Call</li></ul><p><strong>注意点:</strong></p><p>  在UI的默认Shader中存在一个Tint Color的变量，正常情况下，该值为常数(1,1,1)，且并不会被修改。如果是用脚本访问Image的Material，并修改其上的Tint Color属性时，对UI元素产生的网格信息并没有影响，因此就不会引起网格的Rebuild。但这样做因为修改了材质，所以会增加一个Draw Call。 这个没发现增加DC,但是Setpass Call 会增加一个,内存中材质也会增加几k,可以考虑使用MaterialPropertyBlock类 </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        image = GetComponent&lt;Image&gt;();</span><br><span class="line">        image.material = Instantiate(image.material) <span class="keyword">as</span> Material;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ChangeColor</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        image.material.SetColor(<span class="string">&quot;_Color&quot;</span>, color);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>Canvas动静分离,就是静态UI元素可以存放到单独的canvas,虽然多个canvas会打断批处理,但是对对于变化过多的UI这还是很有用的.静态canvas里面的UI 不会网格重建</p></li><li><p>谨慎使用Canvas的Pixel Perfect选项：该选项的开启会导致UI元素在发生位移时，其长宽会被进行微调（为了对齐像素），从而造成layout Rebuild。（比如ScrollRect滚动时，会使得Canvas.SendWillRenderCanvas消耗较高）</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162159561.png"></p></li></ol><p>持续更新….</p><h1 id="UI的批处理"><a href="#UI的批处理" class="headerlink" title="UI的批处理"></a>UI的批处理</h1><p>UI好的批处理可以明显降低DC,有利于界面流畅的切换,我们可以使用工具Frame Debug 来查看,也可以在proliler的UI模块中查看.</p><h2 id="UGUI批处理原则"><a href="#UGUI批处理原则" class="headerlink" title="UGUI批处理原则"></a>UGUI批处理原则</h2><p>UI渲染是从后向前渲染的,也就是在Hierarchy视图中从上往下</p><p><strong>合并原则:</strong><code>同一个深度,同一个贴图,同一个材质</code></p><p><strong>计算方法</strong>: 从直观的角度来解释计算层级号的算法，如果有一个UI元素，它所占的屏幕范围内（通常是矩形），如果没有任何UI在它的底下，那么它的层级号就是0（最底下）；如果有一个UI在其底下且该UI可以和它Batch，那它的层级号与底下的UI层级一样；如果有一个UI在其底下但是无法与它Batch，那它的层级号为底下的UI的层级+1；如果有多个UI都在其下面，那么按前两种方式遍历计算所有的层级号，其中最大的那个作为自己的层级号。</p><p>有了层级号之后，就要合并批次了，此时，Unity会将每一层的所有元素进行一个排序（按照材质、纹理等信息），合并掉可以Batch的元素成为一个批次，目前已知的排序规则是，Text组件会排在Image组件之前渲染，而同一类组件的情况下排序规则未知（好像并没什么规则）。经过以上排序，就可以得到一个有序的批次序列了。这时，Unity会再做一个优化，即如果相邻间的两个批次正好可以Batch的话就会进行Batch .</p><p> 有了层级号之后，就要合并批次了，此时，Unity会将每一层的所有元素进行一个排序（按照材质、纹理等信息），合并掉可以Batch的元素成为一个批次，目前已知的排序规则是，Text组件会排在Image组件之前渲染，而同一类组件的情况下排序规则未知（好像并没什么规则）。经过以上排序，就可以得到一个有序的批次序列了。这时，Unity会再做一个优化，即如果相邻间的两个批次正好可以Batch的话就会进行Batch .</p><p>可以合并这里先看看示例1：</p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162159235.png" /><br><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162200149.png"  /><br><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162200552.png" /><p>先看button底下没用别的UI 那么他的深度（层级）就是0，然后看button1和button一样，深度&#x3D;0，然后看text，text下面是button的img图片，由于<code>text贴图和button贴图不同，所以不能合批</code>，深度为1，两个text都是1。算好层级之后，将所以的UI放入渲染队列，两个text合批成一个dc，两个buton img合批成一个dc，一共两个</p><hr><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162200787.png"></p><p>很奇快同样的两个UI元素却又不同的DC,这里面就是UI的批处理原因</p><p>​先看button,底下无，深度&#x3D;0，再看text，text和button img<code>贴图不同</code>不能合批，所以text1&#x3D;1</p><p>​然后button1,底下有个text1,text1&#x3D;1,button1和text不能合批，所以button1&#x3D;2，最后button1下面的text2和button1也不能合批，text2&#x3D;3，所以都不能合批一共四个dc</p><p><strong>再来看看另一种</strong><br><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162200233.png"></p><p>这种情况只有两个dc</p><p>直观上看,button和button1虽然有重叠,但是他们的材质纹理都相同,所以他们可以合并,然后两个text合并,所以只有两个dc</p><p>再看个例子:<code>UI批处理只看网格重叠</code><br><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162200385.png"></p><p>计算过程:先看绿图下面有红图材质贴图都一样可以合并,红图下面有蓝图也可以合并,三个归为一个层级,我们记为0,这时候看text,虽然text的矩形框有覆盖关系,但是网格并没有,<code>UI批处理只看网格重叠</code></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162200098.png" style="zoom:80%;" />  <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162200606.png" style="zoom:80%;" /></p><p>所以这里Dc&#x3D;2</p><p>然后我们改变一下:<br><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162200325.png"></p><p>这个text就打断了批处理,所以蓝图无法和红绿图合批,所以蓝图一个dc,text一个dc,红绿一个dc一共三个DC</p><p>我们也可以在Profiler中查看原因<br><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162200458.png"></p><h3 id="一个特殊的例子"><a href="#一个特殊的例子" class="headerlink" title="一个特殊的例子"></a>一个特殊的例子</h3><p>如果image&#x3D;null，那么他的渲染顺序是大于text的，所以这就导致了一些问题，如下<br><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162200035.png" alt="image srouce为空的情况"></p><p>在实际渲染队列中，blue&#x3D;0，text&#x3D;1，green&#x3D;2，贴图都是null，首先渲染blue&#x3D;0，然后是green,可是green下面有个text，所以比text大1，text无法和blue合批所以是1，那么green&#x3D;2</p><p>但是我们想得到的是text单独渲染，green和blue合批。那么这时候只要给两个图片指认相同的贴图即可<br><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162201348.png" alt="image-20200217171702078"></p><p>由于image有贴图所以先渲染text&#x3D;0，然后是green&#x3D;1，blue应该也是0但是无法和text合批，所以+1，这时候blue和green深度都为1且其他都相同，所以可以合批，但是这给我们一个提示：<code>图片组件最好不要保持为null</code></p><h2 id="Mask组件"><a href="#Mask组件" class="headerlink" title="Mask组件"></a>Mask组件</h2><p><code>mask组件会打断合批，原因是材质不同</code><br><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162201603.png" alt="这是可以合批的"><br><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162201043.png" alt="mask打断合批"></p><p>mask使用的是模板缓存，还会增加2个dc（自身一个，依赖image组件又一个）</p><hr><ol><li><p><strong>mask之间有重叠会增加dc</strong><br> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162201549.png" alt="mask不叠加可以批处理"><br> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202209191929078.png"></p></li><li><p><strong>mask内部图片可以合批,但无法和外面图片合批</strong></p><p>这个很好理解,内部图片与外部图片材质不同,无法合批.但是内部图片都是用的用同一个材质,他们可以合批</p></li></ol><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162201448.png"><br><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162201930.png" alt="image-20200217181833768"></p><p>   …这里有个奇怪的现象,一开始运行发现有四个dc,然后把两个image隐藏又显示发现又只有3个dc了😪😪😪</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162201795.png"></p><p>   可能是另外两个mask没有裁剪什么吧,然后我让另外两个mask剪裁,发现可以了,很疑惑🤐🤐🤐🤐</p><ol start="3"><li><strong>重叠mask看不到的地方也会影响到深度计算,从而打断合批</strong><br> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162201352.png"></li></ol><h2 id="RectMask2D组件"><a href="#RectMask2D组件" class="headerlink" title="RectMask2D组件"></a>RectMask2D组件</h2><p>RectMask2D组件相对于mask组件的好处</p><ul><li>mask2d不会增加dc</li><li>mask2d不会影响深度计算,即mask2d看不到的地方不会参与计算,网格顶点都不会计算</li></ul><p>但是mask2d也有不足</p><ul><li>mask2d与mask2d内部无法合批<br><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162202036.png"></li></ul><p>如上图 每一个mask2d里面的image都会是一个dc</p><p>但是mask2d里面UI元素是可以合批的<br>​<img src="/image-20200217192538013.png"></p><p>mask2d和mask2d上面的元素是可以合并的<br><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162202449.png"></p><p>原本是4个dc,增加了一个image,变成了5个dc,虽然mask2d上面的UI元素和内部UI元素材质贴图都一致,但是因为mask2d的关系,无法导致合批。</p><h2 id="一些特殊的打断"><a href="#一些特殊的打断" class="headerlink" title="一些特殊的打断"></a>一些特殊的打断</h2><ul><li>UI的pos.Z不为0,会打断合批</li><li>Canvas与Canvas不会合批，但是UI的动静分离也还是有必要的</li><li>一些旋转也会打断合批,旋转Z不会打断合批(比较怪的现象)</li></ul><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162202308.png"></p><p>但是!!!!</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162202530.png"></p><p>很奇快了…</p><h1 id="填充率"><a href="#填充率" class="headerlink" title="填充率"></a>填充率</h1><p>  Fill Rate(填充率)是指显卡每帧每秒能够渲染的像素数(通俗点说就是图片越大需要绘制的像素越多). 在每帧绘制中，如果一个像素被反复绘制的次数越多，那么它占用的资源也必然更多  </p><p>简单来说就是overdraw,也就是我们要减少UI占用的像素，防止同一个像素被太多次绘制<br><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162202877.png"></p><p>中间突出的一部分就是被多次绘制</p><h2 id="一些减少填充率的操作"><a href="#一些减少填充率的操作" class="headerlink" title="一些减少填充率的操作"></a>一些减少填充率的操作</h2><ol><li><p>当需要用一个透明图片充当遮罩的时候，可以把这个设计一个<code>空图片</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Empty4Raycast</span> : <span class="title">Graphic</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnPopulateMesh</span>(<span class="params">VertexHelper toFill</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        toFill.Clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候看屏幕并没有绘制<br><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162202433.png"></p></li><li><p>对于某些图片不影响外观，可以设置image的fill center&#x3D;false<br><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162202672.png" alt="image-20200217201333663"></p></li><li><p>对于某些不规则图片</p><p>不规则图片也是占据整个矩形<br><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162202400.png"></p><p>打开Sprite Editor<br><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162202590.png"></p><p>但是这样增加了顶点，<br><strong>没有绝对的优化，只能根据你的项目需求来进行相关的优化</strong></p></li></ol><h1 id="UI的点击性能优化"><a href="#UI的点击性能优化" class="headerlink" title="UI的点击性能优化"></a>UI的点击性能优化</h1><p><em>更新于2020年4月19日21：32</em> 照搬于知乎</p><p>链接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/55566751">https://zhuanlan.zhihu.com/p/55566751</a></p><p>文章内容(csdn文章)说的很多，先慢慢一个个分析吧</p><ol><li>Unity中即使取消了RaycastTarget,还是会会进入raycast列表的计算。我们一般知道的优化方案是如果UI组件不交互就取消了RaycastTarget,但是还是会计算 然后排除，所以这里如果计算量大的话需要注意。</li><li>然后就是一些官方脚本内部的问题 可以尝试按照csdn博客文章修改</li></ol><h1 id="其他的一些Tips"><a href="#其他的一些Tips" class="headerlink" title="其他的一些Tips"></a>其他的一些Tips</h1><ol><li>少使用或者避免使用layout group组件</li><li>最好不要使用UI自带的特效（outline，shadow…）额外增加dc 顶点 ,Git上面有个特效<a target="_blank" rel="noopener" href="https://github.com/mob-sakai/UIEffect">UIEffect</a>   </li><li>Image为null或者alpha为0不能降低开销，Image为null还会会打断合批  </li><li>Canvas设置摄像机模式的时候一定要指认camara,  Camera.main实际是调用了FindObjectWithTag 很费</li><li>UI 图片旋转之后出现锯齿   解决办法:Canvas 模式设置成ScreenSpace-Camera模式</li><li>关闭不必要的<code>RaycastTarget</code> ，如果UI不需要交互 就关闭,这里附上一个用于检测是否关闭RaycastTarget 脚本，知乎上面的一个优化射线检测方案<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/55566751">https://zhuanlan.zhihu.com/p/55566751</a></li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_EDITOR</span></span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DebugUILine</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> Vector3[] fourCorners = <span class="keyword">new</span> Vector3[<span class="number">4</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnDrawGizmos</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (MaskableGraphic g <span class="keyword">in</span> GameObject.FindObjectsOfType&lt;MaskableGraphic&gt;())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (g.raycastTarget)</span><br><span class="line">            &#123;</span><br><span class="line">                RectTransform rectTransform = g.transform <span class="keyword">as</span> RectTransform;</span><br><span class="line">                rectTransform.GetWorldCorners(fourCorners);</span><br><span class="line">                Gizmos.color = Color.blue;</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">                    Gizmos.DrawLine(fourCorners[i], fourCorners[(i + <span class="number">1</span>) % <span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="写在最后的话"><a href="#写在最后的话" class="headerlink" title="写在最后的话"></a>写在最后的话</h1><p>​Ugui也用了很久，之前不知道UI会有这么多的坑，鉴于坑太多，Unity官方也不填坑，直接搞了一个UIwidgets和UIElements出来，不出意外未来UIelements会替代UGUI</p><p>​UIElemetns出来官方肯定会宣传，啊多么多么好，多么流畅，不用开发者担心xx问题，🤪</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接:"></a>参考链接:</h1><ol><li>UWA:UI模块优化直播视频:<a target="_blank" rel="noopener" href="https://v.qq.com/x/page/e0520qxtjox.html">https://v.qq.com/x/page/e0520qxtjox.html</a></li><li>知乎上一个(其实对上面做了简单的总结)：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/43111806">https://zhuanlan.zhihu.com/p/43111806</a></li><li>《小米超神》技术总监王啸予：重度MOBA的优化之路 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/38004837">https://zhuanlan.zhihu.com/p/38004837</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> UGUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> UGUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Video in Unity</title>
      <link href="/2020/01-28-2020-1-28-Video-in-Unity/"/>
      <url>/2020/01-28-2020-1-28-Video-in-Unity/</url>
      
        <content type="html"><![CDATA[<h1 id="视频概念"><a href="#视频概念" class="headerlink" title="视频概念"></a>视频概念</h1><p>(推荐一个视频解码器：<a target="_blank" rel="noopener" href="https://www.codecguide.com/download_kl.htm">下载 K-Lite 编解码器包 (codecguide.com)</a> 和一个编码器<a target="_blank" rel="noopener" href="https://github.com/HandBrake/HandBrake">HandBrake&#x2F;HandBrake: HandBrake’s main development repository</a></p><p>或者直接下载potPlayer和VLN软件也会自带一些解码器)</p><ul><li><strong>硬解码</strong>:通过硬件(GPU)来解码视频,优点是效率高,降低功耗,缺点支持格式少</li><li><strong>软解码</strong>:利用CPU来解码视频</li><li><strong>帧率</strong>:视频是由于一幅幅图组合而成,帧率越高,表现的越丝滑</li><li><strong>码率</strong>:也叫比特率,是一定时间内传输多少比特(bit)。计算方法：如一帧图大小是0.8kb，那么码率30帧就是0.8kbx8(一个byte有8bit)&#x3D;6.4kbx30&#x3D; 192 kb&#x2F;s</li><li><strong>encoder profile</strong></li></ul><table><thead><tr><th><strong>Profile</strong></th><th><strong>核心功能</strong></th><th><strong>兼容性</strong></th><th><strong>适合场景</strong></th><th><strong>Unity+AvPro 建议</strong></th></tr></thead><tbody><tr><td><strong>Baseline</strong></td><td>仅支持 I&#x2F;P 帧，无 B 帧，无高级算法</td><td>最广（支持所有设备）</td><td>实时通信（如视频会议）、低端设备</td><td>若需兼容 Android 4.0 以下，选此项</td></tr><tr><td><strong>Main</strong></td><td>增加 B 帧支持，基础 H.264 功能</td><td>广（支持 95% 以上设备）</td><td>标准清晰度视频（如 720p 电影）</td><td>移动端优先选择，平衡兼容性与效率</td></tr><tr><td><strong>High</strong></td><td>增加更多高级算法（如 CABAC 熵编码）</td><td>高（支持 90% 以上现代设备）</td><td>高清 &#x2F; 4K 视频、游戏过场动画</td><td><strong>推荐选项</strong>：兼顾兼容性与画质</td></tr><tr><td><strong>High 10</strong></td><td>支持 10 位色深（更广色域）</td><td>中（需较新设备）</td><td>HDR 视频、专业影视制作</td><td>仅当项目明确需要 10 位色深时使用</td></tr><tr><td><strong>High 4:2:2</strong></td><td>支持 4:2:2 色度采样（更高色彩精度）</td><td>低（仅专业设备）</td><td>广播级视频、调色需求高的内容</td><td>不推荐，Unity 很少需要如此高精度</td></tr><tr><td><strong>High 4:4:4</strong></td><td>支持 4:4:4 色度采样（无损色彩）</td><td>极低（仅高端设备）</td><td>无损视频传输、动画渲染</td><td>不推荐，体积极大且兼容性差</td></tr></tbody></table><ul><li><strong>encoder level</strong></li></ul><table><thead><tr><th><strong>Level</strong></th><th><strong>最大分辨率</strong></th><th><strong>最大帧率（fps）</strong></th><th><strong>最大比特率（Mbps）</strong></th><th><strong>典型应用场景</strong></th></tr></thead><tbody><tr><td>1.0</td><td>176×144 (QCIF)</td><td>15</td><td>0.064</td><td>监控摄像头、极低画质视频</td></tr><tr><td>3.0</td><td>720×576 (SD)</td><td>30</td><td>10</td><td>标清视频、手机短视频</td></tr><tr><td>4.0</td><td>1920×1080 (FHD)</td><td>30</td><td>20</td><td>1080p 视频、游戏内过场动画</td></tr><tr><td>4.1</td><td>1920×1080 (FHD)</td><td>60</td><td>24</td><td>1080p 60fps 视频、高动态游戏画面</td></tr><tr><td>5.0</td><td>3840×2160 (4K)</td><td>30</td><td>100</td><td>4K 视频、电影预告片</td></tr><tr><td>5.1</td><td>3840×2160 (4K)</td><td>60</td><td>135</td><td>4K 60fps 视频、专业影视制作</td></tr></tbody></table><p>​总结就是首选<strong>high profile 移动端 main, level在handbreake软件中选auto</strong></p><ul><li><strong>CRF</strong></li></ul><p>​还有就是CRF(或者叫RF)<strong>强烈建议选择</strong> <strong>固定质量 (Constant Quality &#x2F; CRF)</strong> 编码，而不是平均码率 (Average Bitrate &#x2F; ABR)</p><p>​CRF保证在不损质量情况下动态调节码率,保证视频质量一致性.对于简单的场景，它会使用较低的码率；对于复杂的场景，它会使用较高的码率。这通常会带</p><p>​来比固定码率更好的<strong>质量-文件大小平衡</strong>。通常分辨率越高的视频，可以适当提高 RF 值（即牺牲一点点质量），因为高分辨率的细节更多，轻微的质量损失不</p><p>​容易被察觉。反之，低分辨率的视频如果 RF 值太高，画面劣化会更明显</p><ul><li><p><strong>关键帧间隔</strong></p><p>如果要seek 拖动进度条就需要添加关键帧间隔 方便定位 </p><p>​<code>keyint=120</code> (对于60fps视频，每2秒一个关键帧)  keyint&#x3D;60 (对于30帧 每2秒一个关键帧)</p></li><li><p><strong>关闭B帧</strong></p><p>B帧（Bidirectional frames）可以提高压缩效率，但会增加解码的复杂性，在某些旧设备或性能受限的Unity播放器上可能导致卡顿或兼容性问题。<strong>关闭B帧有助于提高兼容性和播放流畅性。</strong>bframes&#x3D;0</p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202507301324958.png" alt="image-20250730132419243"></p></li></ul><h1 id="Unity中播放视频常见的三种方式"><a href="#Unity中播放视频常见的三种方式" class="headerlink" title="Unity中播放视频常见的三种方式"></a>Unity中播放视频常见的三种方式</h1><ul><li>VideoPlayer</li><li>AVPro插件</li><li><a target="_blank" rel="noopener" href="https://www.criware.cn/web/#/zh/home/index">CRIWARE中国官网网站</a></li></ul><h1 id="Unity视频视频格式问题"><a href="#Unity视频视频格式问题" class="headerlink" title="Unity视频视频格式问题"></a>Unity视频视频格式问题</h1><p>在unity中采用VideoPlayer播放视频会有很多日志警告</p><h3 id="Unexpected-timestamp-values-detected-This-can-occur-in-H-264-videos-not-encoded-with-the-baseline-profile…"><a href="#Unexpected-timestamp-values-detected-This-can-occur-in-H-264-videos-not-encoded-with-the-baseline-profile…" class="headerlink" title="Unexpected timestamp values detected. This can occur in H.264 videos not encoded with the baseline profile…"></a>Unexpected timestamp values detected. This can occur in H.264 videos not encoded with the baseline profile…</h3><p>​将视频进行baseline编码</p><p> <img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202405181839634.png" alt="image-20240518183940431"></p><p>参考:<a target="_blank" rel="noopener" href="https://forum.unity.com/threads/audiosampleprovider-buffer-overflow-xxx-frames-discarded.844042/"><a target="_blank" rel="noopener" href="https://forum.unity.com/threads/uwp-hololens-2-app-crash-after-some-seconds-when-reading-video.1405990/">Bug - UWP HoloLens 2 App Crash after some seconds when reading video - Unity Forum</a></a></p><blockquote><p>Is it only happening in the build and not on the Desktop? Can you try transcoding your file in baseline? I see it is <a href="mailto:&#72;&#x69;&#103;&#104;&#64;&#76;&#52;&#46;&#50;">&#72;&#x69;&#103;&#104;&#64;&#76;&#52;&#46;&#50;</a>. You can do that using FFmpeg or the software you used to encode your file.</p><p>Code (CSharp):</p><ol><li>ffmpeg -i input.mp4 -c:v libx264 -preset fast -profile:v baseline <strong>out</strong>.mp4</li></ol></blockquote><h3 id="First-video-frame-not-zero-2-0-083333s-Result-may-be-out-of-sync…"><a href="#First-video-frame-not-zero-2-0-083333s-Result-may-be-out-of-sync…" class="headerlink" title="First video frame not zero: 2 (0.083333s). Result may be out of sync…."></a>First video frame not zero: 2 (0.083333s). Result may be out of sync….</h3><p>​开始帧没对齐 用视频重新转一下就ok</p><h3 id="WindowsVideoMedia-error-unhandled-Color-Standard-0-falling-back-to-default-this-may-result-in-rendering-issues"><a href="#WindowsVideoMedia-error-unhandled-Color-Standard-0-falling-back-to-default-this-may-result-in-rendering-issues" class="headerlink" title="WindowsVideoMedia error unhandled Color Standard: 0 falling back to default this may result in rendering issues"></a>WindowsVideoMedia error unhandled Color Standard: 0 falling back to default this may result in rendering issues</h3><p>​参考:<a target="_blank" rel="noopener" href="https://forum.unity.com/threads/null-reference-exception-when-playing-video.1243489/">Video - Null Reference Exception when playing video - Unity Forum</a></p><p>​<a target="_blank" rel="noopener" href="https://forum.unity.com/threads/video-file-problem.1428865/">Question - Video file problem - Unity Forum</a></p><blockquote><p>Yeah, the “Unexpected timestamp values detected” warning tells you that we have to offset the video timestamps, and frame accuracy will be impacted negatively because it was not encoded using the baseline profile. For most users, it is not an issue. But if you care, you should encode your file using the baseline profile.</p><p>The “WindowsVideoMedia error unhandled color standard: 0” warn that the video file doesn’t specify its color standard and we took a guess and chose BT.709 as it is the most popular. In Unity, we support <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Rec._601">BT.601</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Rec._709">BT.709</a>, and <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Rec._2020">BT.2020</a>. Again for most users, it is not an issue. But if you care or see a color shift because your file is not BT.709, you should specify the color standard while encoding your video files.</p></blockquote><p> 将色彩空间修改成 <code>BT601 BT701 BT2020</code> 即可</p><p>​<img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202405181858722.png" alt="image-20240518185802207"></p><h3 id="AudioSampleProvider-buffer-overflow-XXX-frames-discarded"><a href="#AudioSampleProvider-buffer-overflow-XXX-frames-discarded" class="headerlink" title="AudioSampleProvider buffer overflow. XXX frames discarded"></a>AudioSampleProvider buffer overflow. XXX frames discarded</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wodownload2/article/details/124503621">AudioSampleProvider buffer overflow_skip on drop-CSDN博客</a></p><h1 id="播放透明视频"><a href="#播放透明视频" class="headerlink" title="播放透明视频"></a>播放透明视频</h1><p>在unity中呈现透明视频播放主要有一下几种方式:</p><ol><li>利用Unity自带的<code>VideoPlayer</code> 播放透明视频</li><li>利用<code>AVpro插件</code>播放格式为<code>Hap alpha</code>或者<code>Hap Q alpha</code> 的<code>.mov</code>或<code>.avi</code></li><li>利用<code>Avpro</code>播放通道分离的<code>.MP4</code> 视频</li><li>利用shader 分离进行透明分离(暂不讨论)</li></ol><p>本文最后会介绍一个自己做的小工具用于转换透明视频</p><h2 id="利用Unity自带的VideoPlayer组件播放透明视频"><a href="#利用Unity自带的VideoPlayer组件播放透明视频" class="headerlink" title="利用Unity自带的VideoPlayer组件播放透明视频"></a>利用Unity自带的VideoPlayer组件播放透明视频</h2><p>​unity在5.6版本增加了播放视频的的功能,对应的就是VideoPlayer组件. 在Unity中暂时支持两种透明格式的视频,<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/VideoTransparency.html">链接说明</a></p><ol><li><code>.webm</code> 是Google基于 以 Matroska（就是我们熟知的 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/MKV">MKV</a>）容器格式为基础开发的新容器格式，里面包括了 VP8 视频和 Ogg Vorbis 音轨 .</li><li><code>apple prores 4444</code> 视频格式,此格式不太熟,具体看官方说明 ,附上一个apple prores 4444 <a target="_blank" rel="noopener" href="https://support.apple.com/en-gb/HT202410">视频说明</a></li></ol><p>将导入的.webm视频放入unity中查看</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162157815.gif"></p><p>如上,那么这个视频就是支持透明通道了 接着只要按照寻常的方法用VideoPlayer组件对其进行播放即可</p><h3 id="制作webm视频"><a href="#制作webm视频" class="headerlink" title="制作webm视频"></a>制作webm视频</h3><p>一般在pr或者 Media Encoder 中制作视频导出的时候 没有是webm格式,这个时候就需要下载插件,<a target="_blank" rel="noopener" href="https://www.fnordware.com/WebM/">插件链接</a></p><p>导出的时候(搬图)</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162157975.png"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162158674.png"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162158843.png"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162158212.png"></p><p><strong>注意:</strong> 一般webm视频 我们不需要其他的一些操作就可以支持透明视频,在android平台上面 需要一些操作</p><p>在官方文档中也有说明：<a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2019.4/Manual/VideoSources-FileCompatibility.html">视频文件兼容性 - Unity 手册</a></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202310232206237.png" alt="img"></p><h3 id="Webm-与-VP8"><a href="#Webm-与-VP8" class="headerlink" title="Webm 与 VP8"></a>Webm 与 VP8</h3><blockquote><p>.webm 文件格式对规范进行了改进，因此可在与 VP8 视频编解码器结合使用时携带原生的 Alpha 信息。这意味着任何 Editor 平台都可以读取使用这种透明度格式的视频。由于 Unity 支持的大多数平台都使用软件实现方案来解码这些文件，因此不需要为这些平台进行转码。一个需要注意的例外情况是 Android。该平台的原生 VP8 支持中不包括透明度支持，这意味着必须启用转码，以便 Unity 使用其内部 Alpha 表示方法也就是我们要手动对其进行转码</p></blockquote><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162158097.jpg"></p><h2 id="利用Avpro-播放编码格式为Hap-alpha或者Hap-Q-alpha-的-mov或-avi"><a href="#利用Avpro-播放编码格式为Hap-alpha或者Hap-Q-alpha-的-mov或-avi" class="headerlink" title="利用Avpro 播放编码格式为Hap alpha或者Hap Q alpha 的.mov或.avi"></a>利用Avpro 播放编码格式为Hap alpha或者Hap Q alpha 的.mov或.avi</h2><p><code>hap codec</code>格式支持Windows和mac os x平台 ,并且有以下几处优点:</p><ul><li>CPU使用率极低</li><li>GPU解压缩</li><li>内存使用率低</li><li>支持非常高分辨率</li><li>支持alpha通道透明</li></ul><p>缺点:</p><ul><li>文件过大</li></ul><p>Avpro支持AVI 和MOV  但是更加推荐Mov.</p><p>hap codec 有至少四种编码<code> hap</code> <code>hap alpha</code> <code> hapq</code>(高质量) <code>hapq alpha </code></p><p>然后在 AvPro中选择 DirectShow</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162158134.jpg"></p><h3 id="导出mov文件"><a href="#导出mov文件" class="headerlink" title="导出mov文件"></a>导出mov文件</h3><p>Quick time Hap </p><p>导出hap alpha 格式的mov视频可以下载quick time  然后下载编码格式<a target="_blank" rel="noopener" href="https://github.com/disguise-one/hap-encoder-adobe-cc/releases">插件</a></p><p>导出的时候设置:</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162158359.png"></p><h3 id="直接在PR或者Media-Encoder中导出"><a href="#直接在PR或者Media-Encoder中导出" class="headerlink" title="直接在PR或者Media Encoder中导出"></a>直接在PR或者Media Encoder中导出</h3><p>如果觉得麻烦,可以直接在pr中导出hap alpha 编码格式,插件<a target="_blank" rel="noopener" href="https://github.com/disguise-one/hap-encoder-adobe-cc">下载链接</a></p><p>然后在pr 或者media encoder 中导出选择hap 编码格式为<code>hap alpha</code> 或者 <code>hap q alpha</code></p><h3 id="利用ffmpeg-转换"><a href="#利用ffmpeg-转换" class="headerlink" title="利用ffmpeg 转换"></a>利用ffmpeg 转换</h3><ul><li>ffmpeg -i input.mov -vcodec hap -format hap output-hap.mov</li><li>ffmpeg -i input.mov -vcodec hap -format hap_alpha output-hap.mov</li><li>ffmpeg -i input.mov -vcodec hap -format hap_q output-hap.mov</li></ul><p>注意:</p><ul><li>可以添加 <code>-chunks 4</code> 将解码添加到多线程中 加快视频解码过程</li><li>视频长宽必须是4的倍数</li></ul><h2 id="利用AVpro-播放通道分离的mp4视频"><a href="#利用AVpro-播放通道分离的mp4视频" class="headerlink" title="利用AVpro 播放通道分离的mp4视频"></a>利用AVpro 播放通道分离的mp4视频</h2><p>这算是一种通用方法了,几乎平台都支持,唯一的缺点就是会增加视频的分辨率 这将会导致一些播放硬件的不支持</p><p>在Avpro的demo场景<code>Demo_Transparency</code> 就有两个透明龙视频 一个是左右分离 一个是上下分离</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162158406.jpg"></p><p>可以在AE软件中直接制作 也可以直接 用ffmpeg 转换</p><p>在用ffmpeg转换中 导出的mov编码要是 rgb+a</p><h2 id="透明视频工具"><a href="#透明视频工具" class="headerlink" title="透明视频工具"></a>透明视频工具</h2><p>这是基于FFmpeg 写的视频转换工具 主要就是调用ffmpeg命令</p><p>工具我上传到了<a target="_blank" rel="noopener" href="https://github.com/ZeroUltra/UnityAlphaVideo">GitHub</a>  </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p> <a target="_blank" rel="noopener" href="https://blog.csdn.net/lvcoc/article/details/86303249">https://blog.csdn.net/lvcoc/article/details/86303249</a> </p><h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><p>2020年的春节注定是难忘的,新型冠状病毒从武汉爆发衍生到全国各地 ,为了隔离病毒,防止蔓延,大多数地方封城,封村.希望全国上下齐心协力战胜这次灾难!!!</p><p>​————— 在家躺尸n天的我</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Asset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity中的内存分配以及卸载</title>
      <link href="/2019/12-24-2019-2-24-Unity%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%BB%A5%E5%8F%8A%E5%8D%B8%E8%BD%BD/"/>
      <url>/2019/12-24-2019-2-24-Unity%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%BB%A5%E5%8F%8A%E5%8D%B8%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​遇到个项目需要从外部加载很多图片,外部图片不是规整的2的幂次方图,加载占用内存额外大,刚好看到雨松在unity content 上面关于unity 内存的文章 ,顺便记一下 (其实就是自己复述一遍,偷笑.gif)</p><ul><li><p><a target="_blank" rel="noopener" href="https://developer.unity.cn/projects/5d04a3d1edbc2a2d85d1acf2">Profiler深挖-Memory面板(5)</a> </p></li><li><p><a target="_blank" rel="noopener" href="https://developer.unity.cn/u/yu-song-momo-1?tab=article">Profiler深挖-托管堆(9)</a></p></li><li><p><a target="_blank" rel="noopener" href="https://developer.unity.cn/projects/5d3bb5b2edbc2a001f766eeb">Profiler深挖-图解内存管理(10)</a></p></li></ul><h2 id="堆内存与垃圾回收"><a href="#堆内存与垃圾回收" class="headerlink" title="堆内存与垃圾回收"></a>堆内存与垃圾回收</h2><ul><li>托管内存</li></ul><p>.NET 有自己的垃圾回收,会帮我们回收堆内存,回收时间是不确定的,当我们new一个对象的时候就会产生<code>托管堆内存</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span> : <span class="title">System.Object</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="keyword">new</span> A();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>因为new了一个新的对象 所以产生了堆内存</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162156075.jpg"></p><ul><li>非托管内存</li></ul><p> 不是被.NET分配出来的内存，比如Unity里的贴图、网格、模型、材质Shader等等一些文件内存 ,如下代码所示，分别创建一个10X10和1024X1024的贴图资源。（Resources.Load或者AssetBundle.Load也一样） </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span> &#123;</span><br><span class="line">        Profiler.BeginSample(<span class="string">&quot;10 x 10&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Texture2D(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">        Profiler.EndSample();</span><br><span class="line"></span><br><span class="line">        Profiler.BeginSample(<span class="string">&quot;1024 x 1024&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Texture2D(<span class="number">1024</span>, <span class="number">1024</span>);</span><br><span class="line">        Profiler.EndSample();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 如下图所示，无论是10X10还是1024X1024的图所<strong>占用的堆内存都是一样的</strong>，换句话说堆内存中只是记录了一个文件内存的指针，实际文件则保存在非托管堆中了 </p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162156049.png"></p><p>如下图所示，用Profiler查看一下非托管堆内存，可以看到1024X1024和10X10所占的内存是完全不同的。</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162156567.png" alt="img"></p><p>那么托管堆内存和非托管堆内存如何进行释放呢？很抱歉托管堆内存我们是无法释放的，必须等到垃圾回收的时候释放，但是非托管堆内存我们是可以释放的，Unity就提供了两个API来释放。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Resources.UnloadAsset(obj);</span><br><span class="line">Resources.UnloadUnusedAssets();</span><br></pre></td></tr></table></figure><p>Resources.UnloadAsset需要传入一个<code>资源文件</code>，也就是主动指定释放内存，比如texture、mesh、shader等，不能是GameObject、Component、AssetBundle文件。</p><p> Resources.UnloadUnusedAssets就是卸载无用资源，这个<strong>函数是比较慢</strong>。请大家想象一下在连续的内存中怎么才能确定那些是有引用的内存那些是无引用（垃圾）内存呢？得一个个的循环遍历才能找到垃圾内存吧，可想而知它会有多慢 </p><p>除了Unity的资源，还有<code>文件、数据库</code>，这些都属于非托管堆内存，我们来做一个试验，如下代码所示。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FileStream fileStream;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    fileStream = <span class="keyword">new</span> FileStream(Application.streamingAssetsPath + <span class="string">&quot;/1.txt&quot;</span>,                 FileMode.OpenOrCreate, FileAccess.ReadWrite);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    fileStream = <span class="literal">null</span>;</span><br><span class="line">    fileStream = <span class="keyword">new</span> FileStream(Application.streamingAssetsPath + <span class="string">&quot;/1.txt&quot;</span>,                                   FileMode.OpenOrCreate, FileAccess.ReadWrite);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就会收到下面这个IO错误，代码中虽然让fileStream的指针指向了null，但是由于fileStream所占的非托管内存并没有被delete掉，所以后面再去请求这个fileStream就报错了。</p><blockquote><p>IOException: Sharing violation on path &#x2F;Users&#x2F;momo&#x2F;New Unity Project (2019.1.4f1)&#x2F;Assets&#x2F;StreamingAssets&#x2F;1.txt</p></blockquote><p>如下代码所示，我们来改造一下，只需要进行一下GC，这样就不会再报错了。注意代码中的System.GC.WaitForPendingFinalizers();表示等析构函数执行完毕。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    fileStream = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    System.GC.Collect();</span><br><span class="line">    System.GC.WaitForPendingFinalizers();</span><br><span class="line"></span><br><span class="line">    fileStream = <span class="keyword">new</span> FileStream(Application.streamingAssetsPath + <span class="string">&quot;/1.txt&quot;</span>, FileMode.OpenOrCreate, FileAccess.ReadWrite);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fileStream &#x3D; null;以后自身变成了垃圾，但是堆内存中还没有进行释放。System.GC.Collect();以后就会执行FileStream的析构函数，System.GC.WaitForPendingFinalizers();就是等析构函数执行完毕。FileStream最终在析构函数中将文件句柄Dispose掉，然后就不影响后面再去用它了。</p><p>.NET 中推内存 我们可以不管 但是非托管内存必须要管理,C#提供了一个主动释放托管堆内存的接口</p><blockquote><p>System.IDisposable</p></blockquote><p> 它的目的就是让我们主动释放非托管堆内存的，如下代码所示，只要通过using()包起来就会自动调用类的Dispose方法，从而实现释放。 </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span> : <span class="title">System.IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    FileStream fileStream;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        fileStream = <span class="keyword">new</span> FileStream(Application.streamingAssetsPath + <span class="string">&quot;/1.txt&quot;</span>, FileMode.OpenOrCreate, FileAccess.ReadWrite);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        fileStream.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> a = <span class="keyword">new</span> A())</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> a = <span class="keyword">new</span> A())</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并不是所有人都会用using()，万一有个新手程序员不知道这么用，那System.IDisposable岂不是形同虚设了么？所以这时候就要引入一个新概念那就是析构函数。</p><p>析构函数的执行时机，并不是fileStream&#x3D;null的时候执行。而是托管堆被真正GC垃圾回收后执行的，所以我们可以在析构函数中只进行非托管堆内存的释放工作。如下代码所示(<code>简单来说 析构函数 就是用来让我们自己释放非托管堆内存</code>)</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span> : <span class="title">System.IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    FileStream fileStream;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        fileStream = <span class="keyword">new</span> FileStream(Application.streamingAssetsPath + <span class="string">&quot;/1.txt&quot;</span>, FileMode.OpenOrCreate, FileAccess.ReadWrite);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        fileStream.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line">    ~A()</span><br><span class="line">    &#123;</span><br><span class="line">        fileStream.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样析构函数也能正确的释放资源了，但是又出现一个新问题，如果是代码主动调用Dispose那岂不是还要多进行一次GC？所以我们在代码中要区分主动释放资源和析构函数自动释放资源的时机。如下代码所示，这样就完整了。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span> : <span class="title">System.IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    FileStream fileStream;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        fileStream = <span class="keyword">new</span> FileStream(Application.streamingAssetsPath + <span class="string">&quot;/1.txt&quot;</span>, FileMode.OpenOrCreate, FileAccess.ReadWrite);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Dispose(<span class="literal">true</span>);</span><br><span class="line">        GC.SuppressFinalize(<span class="keyword">this</span>);<span class="comment">//告诉.NET我不需要GC了，别再遍历我了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~A()</span><br><span class="line">    &#123;</span><br><span class="line">        Dispose(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"><span class="built_in">bool</span> disposing</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (disposing)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//释放托管堆内存</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放非托管堆内存</span></span><br><span class="line">        fileStream.Close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>强行解释一下这里为什么在方法一个传入true 一个传入false,在我们手动调用Dispose()方法的时候其实就是释放这个类的托管资源和非托管资源,在析构函数中 析构函数表示这个类就准备给GC了 他的托管资源.NET帮我们回收 我们只要负责回收非托管资源就可以了 这里有一篇分析很好的关于IDisposeable接口的<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wyt007/p/9304564.html">文章</a></p><p>我们在回头说一下堆栈，.NET规定值类型数据保存在栈上，class类型数据保存在堆上。栈内存由系统自行管理，不需要垃圾回收。其实就是值类型数据系统方便复用，而class类型数据系统也没法搞，你们还是GC吧。成</p><p>员内存分配，由于A是一个class类对象，它本真就会占堆内存，那么A对象里即使是值类型数据，那么它也会跟A类一样占在堆内存中。所以请大家记住，<code>值类型数据不一定不占堆内存，但是class数据一定会占堆内存</code>。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NewBehaviourScript</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> B &#123;&#125;</span><br><span class="line">    <span class="keyword">class</span>  <span class="title">A</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//堆</span></span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">100</span>;</span><br><span class="line">        <span class="comment">//堆</span></span><br><span class="line">        B b = <span class="literal">default</span>(B);</span><br><span class="line">        <span class="comment">//堆</span></span><br><span class="line">        <span class="comment">//A a = new A();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//栈</span></span><br><span class="line">    <span class="built_in">int</span> i = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//栈</span></span><br><span class="line">    B b = <span class="literal">default</span>(B);</span><br><span class="line">    <span class="comment">//堆</span></span><br><span class="line">    A a = <span class="keyword">new</span> A();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> A();<span class="comment">//分配内存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可是为什么NewBehaviourScript类中的值类型成员对象并没有占堆内存呢？原因是NewBehaviourScript并不是new出来的，Unity内部用的是反射。</p><p>大家可以回想一下unity中常用的Vector3，这就是一个标准的struct对象。unity之所以这么用就是因为想减少堆内存。</p><p>再来说说值类型和class类型的区别，值类型可以说是个体，而 class类型可以说是引用。个体永远不会被别人改，而引用就很可能被别人改。如下代码所示，b虽然等于a，然是a在后面改了，b的值并没有跟着改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a = 100;</span><br><span class="line">int b = a;</span><br><span class="line">a = 200;</span><br><span class="line">Debug.Log(a); //200</span><br><span class="line">Debug.Log(b); //100</span><br></pre></td></tr></table></figure><p>如下代码所示，如果是class那么一个改了就会影响到另一个，我想这些大家应该都很很好理解。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    A a = <span class="keyword">new</span> A();</span><br><span class="line">    A b = a;</span><br><span class="line">    a.a = <span class="number">100</span>;</span><br><span class="line">    b.a = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    Debug.Log(a.a); <span class="comment">//200</span></span><br><span class="line">    Debug.Log(b.a); <span class="comment">//200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面代码我们还可以看出class的赋值是非常廉价的，代码中的 A b &#x3D; a; 就是添加了一个新指针指向了一块相同的地址而已。</p><p>但是值类型就不一样了。如下代码所示，因为结构体是数值类型，所以A b &#x3D; a;的时候需要将结构体里的每一个数据都进行一次完全拷贝，如果结构体比较大那么拷贝势必就会慢，但是优点就是没有GC。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> A</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="built_in">int</span> a;</span><br><span class="line">     <span class="keyword">public</span> <span class="built_in">int</span> b;</span><br><span class="line">     <span class="keyword">public</span> <span class="built_in">int</span> c;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line"> &#123;</span><br><span class="line">     A a = <span class="keyword">new</span> A();</span><br><span class="line">     A b = a;</span><br><span class="line">     a.a = <span class="number">100</span>;</span><br><span class="line">     b.a = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">     Debug.Log(a.a); <span class="comment">//100</span></span><br><span class="line">     Debug.Log(b.a); <span class="comment">//200</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>我们在来看看参数传递，值类型参数传递其实就是在栈上拷贝了一份新的，此时栈上有两个int 值都是100。方法体内改了参数并不会影响外面的，结果肯定还是100。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> a = <span class="number">100</span>;</span><br><span class="line">    Test(a);</span><br><span class="line">    Debug.Log(a); <span class="comment">//100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"><span class="built_in">int</span> a</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    a--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看类对象，这时候你可能会有疑问，传入的类对象是否也进行了拷贝，答案是肯定的。此时堆上只有1个A对象，但是有两个指针指向它。Test方法体内接收的就已经是拷贝出来的指针，但是由于两个指针指向了同一块内存，所以改了方法体里的外面的也就跟着变了，结果就是99了。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    A a = <span class="keyword">new</span> A() &#123; a = <span class="number">100</span> &#125;;</span><br><span class="line">    Test(a);</span><br><span class="line">    Debug.Log(a.a); <span class="comment">//99</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params">A a</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    a.a--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说数值类型传递慢，但是没GC ，class类型传递快，但有GC，还有一个ref out的用法，就是把真正的引用传进去，而不是拷贝，如下代码所示，因为是引用所以值类型数据传进去也会跟着改了。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> a = <span class="number">100</span>;</span><br><span class="line">    Test(<span class="keyword">ref</span> a);</span><br><span class="line">    Debug.Log(a); <span class="comment">//99</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> a</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    a--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来说一下装箱和拆箱，装箱就是将int值类型数据转成object类对象，拆箱就是将object类对象转回值类型数据，写法上是可以进行隐式转换的。如下代码所示，我们来看个经典的例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private void Awake()</span><br><span class="line">&#123;</span><br><span class="line">    Test(A.TestA);</span><br><span class="line">    Test(B.TestB);</span><br><span class="line">&#125;</span><br><span class="line">void Test(object o)  //传进来就隐式被装箱了</span><br><span class="line">&#123;</span><br><span class="line">    if(o is A)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log((A)o);//这里又显示拆箱了</span><br><span class="line">    &#125;</span><br><span class="line">    if (o is B)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log((B)o);//这里又显示拆箱了</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">enum A</span><br><span class="line">&#123; </span><br><span class="line">    TestA =0</span><br><span class="line">&#125;</span><br><span class="line">enum B &#123;</span><br><span class="line">    TestB =0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C#讲究个万物皆对象， 任何东西都可以通过参数传到object对象来接受，但是这一步就被隐式转换成堆内存了。。再来看个例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i = 100;</span><br><span class="line">var a = string.Format(&quot;&#123;0&#125;&quot;, i); //完了这里又被隐式装箱了</span><br></pre></td></tr></table></figure><p>正确的写法应该是先转成字符串，这样就不需要装箱了。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> i = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">string</span>.Format(<span class="string">&quot;&#123;0&#125;&quot;</span>, i.ToString());</span><br></pre></td></tr></table></figure><p>凭啥int就是值类型？int就是System.int32对象，对应的还有float、double、等等，但是他们都继承了struct，所以统统都是值类型了。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Int32 : IComparable, IFormattable, IConvertible</span><br><span class="line">        , IComparable&lt;Int32&gt;, IEquatable&lt;Int32&gt;</span><br><span class="line"><span class="comment"><span class="doctag">///</span>     , IArithmetic<span class="doctag">&lt;Int32&gt;</span></span></span><br></pre></td></tr></table></figure><p>装箱的效率是不如拆箱要高的，比如把一个 int装箱成object，那么此时需要在堆中开辟一块内存，并且赋值给它。而拆箱并不需要在栈上分开辟新的内存，只需要值重新赋到栈上就行了。赋值完后，堆上的这块内存就变成了垃圾等待下次垃圾回收掉。</p><p>注意一下，struct和enum对象，如果放在 Dictionary&lt;T,T&gt; List<T>数据结构里，用法不当就会产生大量的堆内存，就是上面说的隐式装箱，我们来看看代码。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> S </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//list</span></span><br><span class="line">    S s = <span class="keyword">new</span> S() &#123; a = <span class="number">10</span> &#125;;</span><br><span class="line">    List&lt;S&gt; list = <span class="keyword">new</span> List&lt;S&gt;() &#123; s &#125;;</span><br><span class="line">    Dictionary&lt;S, S&gt; dict = <span class="keyword">new</span> Dictionary&lt;S, S&gt;() &#123; &#123; s, s &#125; &#125;;</span><br><span class="line"></span><br><span class="line">    Profiler.BeginSample(<span class="string">&quot;struct list contains&quot;</span>);</span><br><span class="line">    list.Contains(s);  <span class="comment">//装箱40b</span></span><br><span class="line">    Profiler.EndSample();</span><br><span class="line"></span><br><span class="line">    Profiler.BeginSample(<span class="string">&quot;struct dictionary ContainsKey&quot;</span>);</span><br><span class="line">    dict.ContainsKey(s);<span class="comment">//装箱60b</span></span><br><span class="line">    Profiler.EndSample();</span><br><span class="line"></span><br><span class="line">    Profiler.BeginSample(<span class="string">&quot;struct dictionary ContainsValue&quot;</span>);</span><br><span class="line">    dict.ContainsValue(s); <span class="comment">//装箱40b</span></span><br><span class="line">    Profiler.EndSample();</span><br><span class="line"></span><br><span class="line">    Profiler.BeginSample(<span class="string">&quot;struct dictionary [a]&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> n  = dict[s]; <span class="comment">//装箱60b</span></span><br><span class="line">    Profiler.EndSample();</span><br><span class="line"></span><br><span class="line">    Profiler.BeginSample(<span class="string">&quot;struct dictionary out&quot;</span>);</span><br><span class="line">    S o;</span><br><span class="line">    dict.TryGetValue(s, <span class="keyword">out</span> o); <span class="comment">//装箱60b</span></span><br><span class="line">    Profiler.EndSample();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>List和Dictionary在调用以上API时C#都会转成object类型，然后就产生堆内存了。以上代码换成enum也有同样效果。</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162156987.png" alt="img"></p><p>感谢下面留言的朋友，其实之前我这里是想写enum类型的。因为之前向项目里遇到了这个坑，之前想把枚举放入Dictionary中，结果在取值的时候就产生了大量的GC，后来就规定了enum不写在Dictionary和List中。如下代码所示。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> E </span><br><span class="line">&#123;</span><br><span class="line">    Name=<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    Dictionary&lt;E,E&gt; dict = <span class="keyword">new</span> Dictionary&lt;E, E&gt;() &#123; &#123; E.Name , E.Name &#125; &#125;;</span><br><span class="line">    Profiler.BeginSample(<span class="string">&quot;enum dict1 []&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> e = dict[E.Name];  <span class="comment">//装箱60b</span></span><br><span class="line">    Profiler.EndSample();</span><br><span class="line"></span><br><span class="line">    Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; dict1 = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt;() &#123; &#123; <span class="number">1</span>, <span class="number">1</span> &#125; &#125;;</span><br><span class="line">    Profiler.BeginSample(<span class="string">&quot;int dict2 []&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> e1 = dict1[<span class="number">1</span>];  <span class="comment">//无gc</span></span><br><span class="line">    Profiler.EndSample();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162156650.png" alt="img"></p><p>说了这么多最后我们在聊聊C#的垃圾回收，如果内存中有50M左右的堆内存，每个都遍历一遍判断是否垃圾其实是非常慢的，C#引入了一个代的概念，C#认为新分配的内存最容易是垃圾，比如方法体内的临时变量，每新的 一帧都会来回调用其实全都是需要垃圾回收的。</p><p>首次垃圾回收前所有的内存只是第0代，扫描垃圾后会将不是垃圾的内存标记到第1代。这样下次在进行垃圾回收就不再扫描第1代了，而只扫描第0代（除非内存实在不够了才会继续向上扫描）。这样将大大减少垃圾扫描的时间。整个流程依次类推C#会总共会保留 0 1 2  一共有3代垃圾标志，直到你的程序太猛把所有内存都吃满了，C#不得不来个内存溢出。</p><p>垃圾回收其实是不建议主动调用的，因为系统会自动调用。C#会在new 的时候进行检查是否需要触发垃圾回收。本身这套机制是没问题的，但是放到Unity里就有问题了，因为Unity的资源texture、mesh、shader等都被放到了托管堆中无法及时释放。为啥释放不了其实还是写法有问题，太依赖Resources.UnloadUnusedAssets。有些不常用的资源用过以后要及时主动Resources.UnloadAsset(obj); 从非托管堆中干掉。</p><p>时刻要注意的是非托管内存，.NET在厉害也只能回收自己的内存，非托管内存它是毫无办法的。前面我们已经举了一些实际例子，这里我在补充一下，非托管内存还有一些第三方SDK可能占的内存，或者用 lua开发可能很多人都见过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.IntPtr   </span><br></pre></td></tr></table></figure><p>它可以指向一个非托管的内存地址，比如文件句柄。一定要注意非托管内存的回收。</p><p>最后在说一下IL2CPP，可能会有人有疑问不是都转成c++代码？C++哪里有垃圾回收啊。C++确实没有垃圾回收，但是IL2CPP模拟了一套垃圾回收。在怎么IL2CPP它也无法知道何时准确的delete掉你的内存，所以IL2CPP和真正的C++效率还是不一样的。</p><h2 id="Unity-中的非托管资源卸载"><a href="#Unity-中的非托管资源卸载" class="headerlink" title="Unity 中的非托管资源卸载"></a>Unity 中的非托管资源卸载</h2><p>非托管资源 简单说就是自己从外部加载的资源,例如图片 音频 文本….</p><h3 id="卸载图片"><a href="#卸载图片" class="headerlink" title="卸载图片"></a>卸载图片</h3><p>加载图片有Texture.load(bytes),直接从外部加载图片,卸载的时候只需要调用 Destoty(xxx)就可以卸载</p><h3 id="卸载AssetBundle资源"><a href="#卸载AssetBundle资源" class="headerlink" title="卸载AssetBundle资源"></a>卸载AssetBundle资源</h3><p>ab中有一个卸载方法<code>Unload(false/true)</code></p><p>当<code>Unload(false)</code>的时候卸载的只是这个包的镜像文件,已经加载的资源不会被删除</p><p>当<code>Unload(true)</code>的时候卸载的是整个ab包的资源,加入有一个图片是从ab中加载的,那么调用这个方法 这个图片直接会<code>miss</code></p><h3 id="使用Resources-UnloadUnusedAssets和Resources-UnloadAsset卸载"><a href="#使用Resources-UnloadUnusedAssets和Resources-UnloadAsset卸载" class="headerlink" title="使用Resources.UnloadUnusedAssets和Resources.UnloadAsset卸载"></a>使用Resources.UnloadUnusedAssets和Resources.UnloadAsset卸载</h3><p><code>Resources.UnloadUnusedAssets</code>:比较耗费,一是这个是全局的,二是这个会检查内存中没有引用的资源.<strong>卸载的东西必须是场景中没有关联的资源</strong></p><p><code>Resources.UnloadAsset</code>:可以从Ab包中卸载资源,<strong>不用管场景是否有关联</strong>音频和Texture可以卸载(已经确认),但是测试中发现<code>Unity SpriteAtlas</code>是没法卸载的</p><hr><p><strong>更新于2021年12月19日</strong></p><p><code>Resources.UnloadAsset</code>:<strong>This function can only be called on Assets that are stored on disk.</strong>(只能卸载磁盘中存在的文件,也就是只能卸载加载到Unity 内存中的文件,可以通过Profiler的Memory的Asset中查看.</p><ul><li><p>不管是否关联,都可以卸载资源</p></li><li><p>关于之前记载的为啥<code>SpriteAtlas</code>不能卸载其实<code>SA</code>已经卸载,只是SA的Texture没有卸载,</p><p><a target="_blank" rel="noopener" href="https://answer.uwa4d.com/question/5fd4de5210a17c6c2b09d625">Unity 从assetbundle中加载图集之后使用Resources.UnloadAsset 卸载不了 – UWA问答：帮助开发者找到更好的答案 (uwa4d.com)</a></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202204291832919.png" alt="image-20211219205953695"></p><p>前后对比<code>SpriteAtals</code>已经卸载,但是对应的Texture没有卸载, 查看链接回答</p></li></ul><h3 id="切换场景卸载"><a href="#切换场景卸载" class="headerlink" title="切换场景卸载"></a>切换场景卸载</h3><p>切换场景的时候,会自动卸载没有用的资源和GC,也就是执行了</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Resources.UnloadUnusedAssets();</span><br><span class="line">System.GC.Collect();</span><br><span class="line">System.GC.WaitForPendingFinalizers();</span><br></pre></td></tr></table></figure><p>但是要注意的是,必须要清空场景中的引用,如下代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> RawImage rawImage;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">byte</span>[] bs = File.ReadAllBytes(<span class="string">@&quot;M:\Image\壁纸\fuse.png&quot;</span>);</span><br><span class="line">    Texture2D tex = <span class="keyword">new</span> Texture2D(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    tex.LoadImage(bs);</span><br><span class="line">    tex.Apply();</span><br><span class="line">    rawImage.texture = tex;</span><br><span class="line">    GetComponent&lt;Button&gt;().onClick.AddListener(()=&gt;</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">//这里如果没有设置rawimg=null 那么就不会卸载这个图片资源 </span></span><br><span class="line">       <span class="comment">//必须设置=null 断开这个链接 才能保证资源卸载</span></span><br><span class="line">       <span class="comment">// rawImage = null;</span></span><br><span class="line">        SceneManager.LoadScene(<span class="string">&quot;222&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>如果是从Assetbundle中加载的资源,切换场景时候会自动卸载资源,AB包需要手动卸载</code></p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 内存 </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git操作记录</title>
      <link href="/2019/11-23-2019-1-25-git%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/11-23-2019-1-25-git%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><ul><li>git clone 克隆远程项目</li><li>git add . 添加所有文件到缓存中</li><li>git add   具体文件名 只提交相关文件</li><li>git commit -m “信息”   提交信息</li><li>git push origin master 提交到github库中<ul><li>git push 推送到默认分支</li><li>git push -f 强制推送</li></ul></li><li>git clone -b xxx <a target="_blank" rel="noopener" href="https://github/">https://github</a>……  下载分支代码   -b  &#x3D;branch</li><li>放弃本地强制更新<ul><li>git fetch –all<br>git reset –hard origin&#x2F;main   main是分支<br>git pull</li></ul></li></ul><h2 id="git-submodule"><a href="#git-submodule" class="headerlink" title="git submodule"></a>git submodule</h2><ul><li>git submodule add <code>git地址</code> <code>路径</code>   添加子模块 路径是相对于该项目下的文件夹例如:Assets&#x2F;Res<ul><li>git submodule add <options> <code>git地址</code> <code>路径</code>   例如添加分支 -b v1</li></ul></li><li>git submodule init  </li><li>git submodule update  这两个命令一起会添加子模块git</li><li>git  submodule deinit <code>路径</code> 删除子模块</li><li>git rm <code>路径</code> 删除某个目录以及缓存信息</li><li>rm -rf .git&#x2F;modules&#x2F;&lt;子目录路径&gt;  删除主仓库中的子模块信息</li><li>git submodule update –remote 更新版本到远程库</li></ul><h2 id="svn"><a href="#svn" class="headerlink" title="svn"></a>svn</h2><p>SVN dump导出最新版</p><p><code>svnadmin dump G:\SVN\Repositories\A-Shuangtong -r head &gt; G:\SVN\Backup\dump\mdj_demo003.dump</code></p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> svn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub+Hexo 搭建博客--我的第一篇博客</title>
      <link href="/2019/11-22-2019-1-24-myblog/"/>
      <url>/2019/11-22-2019-1-24-myblog/</url>
      
        <content type="html"><![CDATA[<h1 id="首先恭喜我…终于搭建好博客了"><a href="#首先恭喜我…终于搭建好博客了" class="headerlink" title="首先恭喜我…终于搭建好博客了"></a>首先恭喜我…终于搭建好博客了</h1><p>​我来记录一下搭建的过程</p><h1 id="工善其事-利先其器-下载所需工具"><a href="#工善其事-利先其器-下载所需工具" class="headerlink" title="工善其事 利先其器 下载所需工具"></a>工善其事 利先其器 下载所需工具</h1><ol><li>首先下载<a target="_blank" rel="noopener" href="https://nodejs.org/en/">node.js</a> 安装</li><li>下载 <code>node.js&#39;</code>之后,cmd打开,执行命令  <code>npm install hexo-cli -g</code>  安装<code>hexo</code>,  <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/">hexo官网</a></li><li>然后执行命令<code>npm install hexo-deployer-git    --save</code>  安装部署到github的插件</li><li>选择一款你喜欢的主题 官方主题网址 <a target="_blank" rel="noopener" href="https://hexo.io/themes/"> https://hexo.io/themes/ </a>  官方wiki网址<a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/wiki/Themes"> https://github.com/hexojs/hexo/wiki/Themes </a>  然后使用git下载, 本网站使用了<del><a target="_blank" rel="noopener" href="https://github.com/yscoder/hexo-theme-indigo">indigo</a></del> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">butterfly</a></li></ol><h1 id="cmd走起-搭建博客"><a href="#cmd走起-搭建博客" class="headerlink" title="cmd走起 搭建博客"></a>cmd走起 搭建博客</h1><p>​搭配hexo官方文档使用</p><ol><li><p>找一个空文件夹.打开cmd 使用如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>hexo init 有可能clone 失败,也可能中途一些其他问题,请多次尝试,下载成功界面</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162153392.png"></p><p>下载完成之后完整目录结构</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162153296.jpg"></p></li><li><p>hexo 常用的几个命令</p><ul><li>清除缓存 <code>hexo clean</code></li></ul></li></ol><ul><li>生成静态文件：<code>hexo generate</code>，简写<code>hexo g</code><ul><li>启动服务器：<code>hexo server</code>，简写<code>hexo s</code></li></ul></li><li>部署到远程站点： <code>hexo deploy</code>，简写<code>hexo d</code><ul><li>写新文章: <code>hexo n &lt;title&gt;</code> 新文章在 source&#x2F;_posts文件夹下面,更多查看<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/commands">https://hexo.io/zh-cn/docs/commands</a></li></ul></li><li>添加新页面：<code>hexo new page xxxx</code></li></ul><p>现在使用命令 <code>hexo s</code> 然后打开 <code>http://localhost:4000/ </code>查看</p><h1 id="博客的一些设置"><a href="#博客的一些设置" class="headerlink" title="博客的一些设置"></a>博客的一些设置</h1><p>​Everything&#96;s ok~~~ </p><p>​配合<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/configuration">hexo</a>设置一些内容</p><h2 id="更改主题"><a href="#更改主题" class="headerlink" title="更改主题"></a>更改主题</h2><p>​在你的网站文件夹下面有个<code>themes</code> 文件夹,然后把你下载的主题文件全部拷贝.</p><p>​然后修改<code>_config.yml</code>配置</p><p>​找到<code>theme: landscape</code>  然后将landscape替换成你的主题文件夹名字</p><p>​然后运行<code>hexo clear</code>  <code>hexo s</code>重启,再打开网址查看</p><h2 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h2><p>​还是打开<code>_config.yml</code>然后修改<code>deploy</code>部分,例如我的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type: git</span><br><span class="line">repo: https://github.com/ZeroUltra/ZeroUltra.github.io</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure><p>​    然后使用 <code>hexo d</code> 提交到githubpage</p><h2 id="定义文章链接-存放位置"><a href="#定义文章链接-存放位置" class="headerlink" title="定义文章链接,存放位置"></a>定义文章链接,存放位置</h2><p>hexo 新的文章位置默认在<code>*source\_posts</code> 文件夹下面,修改配置文件的<code>Url</code>部分,可以自定义文件夹</p><p>我的就是在_posts文件夹下面在用年份命名就可以这样配置</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162153210.jpg"></p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162153969.jpg"></p><h2 id="在hexo中插入图片"><a href="#在hexo中插入图片" class="headerlink" title="在hexo中插入图片"></a>在hexo中插入图片</h2><p>插入图片有两种方式,第一是在source文件夹下面建立一个文件夹用来存放图片,例如<strong>imgs</strong>,然后把图片插入md     中<code>![](/imgs/picname.jpg)</code>就可以显示.但是推荐第二种找到<code>Writing</code>,设置<code>post_asset_folder</code>为true</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162153900.jpg"></p><p>然后新建一个文章就可以发现在同名md文件夹下面会对应一个文件夹,把你的资源放在这个文件夹,然后设置路径就可以了,例如插入一个1.jpg就直接写<code>![](1.jpg)</code>即可.</p><h2 id="修改默认模板"><a href="#修改默认模板" class="headerlink" title="修改默认模板"></a>修改默认模板</h2><p>​在<code>*\scaffolds</code>文件夹下面有三个模板,文章的模板是post,可以定制自己所需要内容</p><h2 id="加入Live2D，更新于2020-2-8-22-00"><a href="#加入Live2D，更新于2020-2-8-22-00" class="headerlink" title="加入Live2D，更新于2020.2.8 22:00"></a>加入Live2D，更新于2020.2.8 22:00</h2><p>​加入live2d 看了几篇博客，基础版很简单，高级版（添加互动效果）我也没仔细试，后面需要在添加吧，先看看基础版本，相关文章</p><ol><li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4b61d8702cfa">https://www.jianshu.com/p/4b61d8702cfa</a> </li><li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a7f4a42e4b49">https://www.jianshu.com/p/a7f4a42e4b49</a> </li><li>live2d github仓库: <a target="_blank" rel="noopener" href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md">https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md</a> </li><li>live2d模型： <a target="_blank" rel="noopener" href="https://github.com/xiazeyu/live2d-widget-models">https://github.com/xiazeyu/live2d-widget-models</a> </li><li>live2d模型效果： <a target="_blank" rel="noopener" href="https://huaji8.top/post/live2d-plugin-2.0/">https://huaji8.top/post/live2d-plugin-2.0/</a></li></ol><p>因为我主要是进行Unity开发，所以模型用了UnityChan</p><h2 id="加入点击爱心效果，更新于2020-2-9-15-48"><a href="#加入点击爱心效果，更新于2020-2-9-15-48" class="headerlink" title="加入点击爱心效果，更新于2020.2.9 15:48"></a>加入点击爱心效果，更新于2020.2.9 15:48</h2><p>​<img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162153947.gif" style="zoom:80%;" /></p><p>​鼠标爱心点击效果，晚上搜了好几个大多数都是Next主题的，看了其他几个文章，大概做法是理解了，建立一个clicklove.js脚本</p><p>​<img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162153306.png"></p><p>这个脚本接收点击事件然后在相应的位置出现爱心效果，麻烦的就是我们需要在哪里调用这个效果，经过我摸索最终确定了只要这个地方添加就可以。</p><p>​<img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162153297.png"></p><p>直接在这个脚本最后面添加如下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;/js/clicklove.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>当然了，我们也可以像<code>_config.yml</code>添加配置，通过设置<code>true/jfalse</code>来开启关闭爱心效果</p><p>所以我们在layout中添加如下代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (theme.Clicklove)&#123; %&gt;</span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/js/clicklove.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>效果图：</p><p>​<img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162154025.png"></p><p>然后在<code>_config.yml</code>中（注意是indigo中的配置）</p><p>​<img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162154180.png"></p><p>这样我们可以自己设置开启或者关闭了。</p><p>最后附上<code>clicklove.js</code>脚本代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">! <span class="keyword">function</span> (<span class="params">e, t, a</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">n</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">c</span>(<span class="string">&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#x27;&#x27;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;</span>), <span class="title function_">o</span>(), <span class="title function_">r</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">r</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> e = <span class="number">0</span>; e &lt; d.<span class="property">length</span>; e++) d[e].<span class="property">alpha</span> &lt;= <span class="number">0</span> ? (t.<span class="property">body</span>.<span class="title function_">removeChild</span>(d[e].<span class="property">el</span>), d.<span class="title function_">splice</span>(e, <span class="number">1</span>)) : (d[e].<span class="property">y</span>--, d[e].<span class="property">scale</span> += <span class="number">.004</span>, d[e].<span class="property">alpha</span> -= <span class="number">.013</span>, d[e].<span class="property">el</span>.<span class="property">style</span>.<span class="property">cssText</span> = <span class="string">&quot;left:&quot;</span> + d[e].<span class="property">x</span> + <span class="string">&quot;px;top:&quot;</span> + d[e].<span class="property">y</span> + <span class="string">&quot;px;opacity:&quot;</span> + d[e].<span class="property">alpha</span> + <span class="string">&quot;;transform:scale(&quot;</span> + d[e].<span class="property">scale</span> + <span class="string">&quot;,&quot;</span> + d[e].<span class="property">scale</span> + <span class="string">&quot;) rotate(45deg);background:&quot;</span> + d[e].<span class="property">color</span> + <span class="string">&quot;;z-index:99999&quot;</span>);</span><br><span class="line">        <span class="title function_">requestAnimationFrame</span>(r)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">o</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> t = <span class="string">&quot;function&quot;</span> == <span class="keyword">typeof</span> e.<span class="property">onclick</span> &amp;&amp; e.<span class="property">onclick</span>;</span><br><span class="line">        e.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">            t &amp;&amp; <span class="title function_">t</span>(), <span class="title function_">i</span>(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">i</span>(<span class="params">e</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> a = t.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">        a.<span class="property">className</span> = <span class="string">&quot;heart&quot;</span>, d.<span class="title function_">push</span>(&#123;</span><br><span class="line">            <span class="attr">el</span>: a,</span><br><span class="line">            <span class="attr">x</span>: e.<span class="property">clientX</span> - <span class="number">5</span>,</span><br><span class="line">            <span class="attr">y</span>: e.<span class="property">clientY</span> - <span class="number">5</span>,</span><br><span class="line">            <span class="attr">scale</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">alpha</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">color</span>: <span class="title function_">s</span>()</span><br><span class="line">        &#125;), t.<span class="property">body</span>.<span class="title function_">appendChild</span>(a)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">c</span>(<span class="params">e</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> a = t.<span class="title function_">createElement</span>(<span class="string">&quot;style&quot;</span>);</span><br><span class="line">        a.<span class="property">type</span> = <span class="string">&quot;text/css&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            a.<span class="title function_">appendChild</span>(t.<span class="title function_">createTextNode</span>(e))</span><br><span class="line">        &#125; <span class="keyword">catch</span> (t) &#123;</span><br><span class="line">            a.<span class="property">styleSheet</span>.<span class="property">cssText</span> = e</span><br><span class="line">        &#125;</span><br><span class="line">        t.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>].<span class="title function_">appendChild</span>(a)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">s</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;rgb(&quot;</span> + ~~(<span class="number">255</span> * <span class="title class_">Math</span>.<span class="title function_">random</span>()) + <span class="string">&quot;,&quot;</span> + ~~(<span class="number">255</span> * <span class="title class_">Math</span>.<span class="title function_">random</span>()) + <span class="string">&quot;,&quot;</span> + ~~(<span class="number">255</span> * <span class="title class_">Math</span>.<span class="title function_">random</span>()) + <span class="string">&quot;)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> d = [];</span><br><span class="line">    e.<span class="property">requestAnimationFrame</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> e.<span class="property">requestAnimationFrame</span> || e.<span class="property">webkitRequestAnimationFrame</span> || e.<span class="property">mozRequestAnimationFrame</span> || e.<span class="property">oRequestAnimationFrame</span> || e.<span class="property">msRequestAnimationFrame</span> || <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(e, <span class="number">1e3</span> / <span class="number">60</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(), <span class="title function_">n</span>()</span><br><span class="line">&#125;(<span class="variable language_">window</span>, <span class="variable language_">document</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="给背景添加雪花效果，更新于2020-2-9-19-26"><a href="#给背景添加雪花效果，更新于2020-2-9-19-26" class="headerlink" title="给背景添加雪花效果，更新于2020.2.9 19:26"></a>给背景添加雪花效果，更新于2020.2.9 19:26</h2><p>​添加雪花背景 参考链接: <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41287260/article/details/103050877">https://blog.csdn.net/weixin_41287260/article/details/103050877</a> </p><p>第二个雪花无齿状的参考之前<code>点击爱心</code>效果做法，主要是第一个<code>大雪花(有齿轮)</code>效果搞了半天不会搞，究其原因就是我不会网页前端😅，在代码中主要就是有个jquery,我也不知道是个啥，就是出不来效果。后来查了资料才知道这是个js库，然后雪花代码依赖这个js库，然后又搜素的很久，终于知道怎么添加了。</p><blockquote>  <script type="text/javascript" src="jquery.js"></script>    <script type="text/javascript" src="我的代码.js"></script>  <p> 先引入jquery.js后，后面的所有JS代码都可以直接调用jquery.js中的方法<br> 所以你直接在“我的代码.js”文件中写就可以了 </p></blockquote><p>写好<code>snow.js</code>代码然后放在<code>js</code>文件夹中，在<code>layout.ejs</code>中添加如下代码</p><p>​<img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162154850.png"></p><p>然后在配置一下<code>_config.yml</code></p><p>​<img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162154477.png"></p><p>OK！！！ 完成</p><h2 id="修改主题颜色-更新于2020-2-10-20-25"><a href="#修改主题颜色-更新于2020-2-10-20-25" class="headerlink" title="修改主题颜色,更新于2020.2.10 20:25"></a>修改主题颜色,更新于2020.2.10 20:25</h2><p> <a target="_blank" rel="noopener" href="https://www.materialpalette.com/blue/indigo">https://www.materialpalette.com/blue/indigo</a> </p><h2 id="2020年5月19-22-23遇到hexo上传Github出现css丢失"><a href="#2020年5月19-22-23遇到hexo上传Github出现css丢失" class="headerlink" title="2020年5月19 22:23遇到hexo上传Github出现css丢失"></a>2020年5月19 22:23遇到hexo上传Github出现css丢失</h2><p>​当我帮别人弄一个blog的时候,我在自己仓库新建一个github page,尽管我怎么命名仓库名字总是会以<code>https://&#123;myname&#125;/github.io/&#123;仓库名&#125;</code>形式命名,但是我打开网页 发现各种找不到东西,我查看了错误</p><p><img src="https://raw.githubusercontent.com/ZeroUltra/MediaLibrary/main/Imgs/202206162155804.png"></p><p>可以看到这个地址是错了 应该还要有个加个仓库名. 最后没办法 ,我只能用别人的建立了一个仓库,然后我加入协作,不知道这是hexo的错误,还是github问题还是我用的模板的问题.记录一下</p><h2 id="2023年7月26日-更新node-modules里面的插件"><a href="#2023年7月26日-更新node-modules里面的插件" class="headerlink" title="2023年7月26日 更新node_modules里面的插件"></a>2023年7月26日 更新node_modules里面的插件</h2><ul><li><code>npm ls</code> 列出所有插件</li><li><code>npm outdated</code> 查看所有插件对应版本</li><li>如果要更新的话 使用<code>npm install 插件名@4.0.0</code></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><p><a target="_blank" rel="noopener" href="https://brianway.github.io/2019/04/14/hexo-github-pages-practice/"> 使用GitHub+Hexo搭建个人网站 </a></p></li><li><p><a target="_blank" rel="noopener" href="http://threehao.com/2016/08/22/Github%20Pages%20+%20Hexo/"> Hexo搭建个人网站 </a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
